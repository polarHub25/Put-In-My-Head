
### Java

## 1. JVM의 구조와 Java의 실행방식을 설명해주세요. 

> java의 실행방식 <br>
- java 코드는 javac 컴파일러에 의해 java 바이트 코드(.class)로 변환
- java 바이트 코드는 jvm에 의해 메모리로 로드되고, 검증된 후 실행
- jvm의 Execution Engine은 인터프리터와 JIT 컴파일러를 사용해 바이트코드를 해석하거나 기계어로 
변환해 실행
- jvm은 메모리를 자동으로 관리하며, 필요시 JNI를 통해 네이티브 메서드(c, c++ 등)도 호출
- 프로그램 실행이 완료되면 jvm은 gc과 리소스 해제를 통해 메모리를 정리하고 종료

> jvm 역할 <br>

자바 애플리케이션을 클래스 로더를 통해 읽어 자바 api와 함께 실행하는 것

- Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올림
- Runtine Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석 
- 이 과정에서 Execution Engine에 의해 gc의 작동과 스레드 동기화가 이루어짐.

> jvm 구조 <br>

클래스 로더 <br>
 - jvm 내로 .class 파일을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치 
 
실행엔진 ( Execution Engine ) 
 - 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행 <br>
   ( 인터프리터와 JIT 컴파일러 방식을 혼합하여 바이트 코드 실행) 
 * 인터프리터 <br>
   : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 ( 전체적인 속도는 느림 ) 
 * JIT 컴파일러 (Just in time) <br>
   : 인터프리터의 단점을 보완하기 위해 도입. 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 native code로 변경하고, 
   그 이후에는 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드(c, c++) 로 직접 실행하는 방식
 * 가비지 콜렉터 (Garbage Collector) <br>
 : heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수. 개발자가 따로 메모리 관리를 하지않아도 됨.


런타임 데이터 영역 (Runtime Data Areas)
 - jvm의 메모리 영역. 자바 애플리케이션이 실행할 때 사용되는 데이터들을 적재하는 영역

 * 메소드 영역 (Method Area) <br>
 : jvm이 시작될때 생성되는 공간. 바이트 코드를 처음 메모리 공간에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간 <br>
 : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름, 리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성 
 * 힙 영역 (Heap Area) <br>
 : 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역. <br>
 : new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 <br>
 : GC 대상
 
 * 스택 영역 (Stack Area) <br>
 : 메소드가 호출될때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장 <br>
 : 임시적으로 사용되는 변수, 정보들이 저장되는 영역
 * PC Register ( Program Counter register ) <br>
 : 스레드가 시작될때 생성. 현재 수행중인 jvm 명령어 주소를 저장하는 공간. <br>
 * 네이티브 메소드 스택 (Native Method Stack) <br>
 : 기계어로 작성된 프로그램을 실행시키는 영역
 
자바 네이티브 인터페이스
- 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공 <br>

네이티브 메소드 라이브러리 
- c, c++ 로 작성된 라이브러리를 칭함.


java, jvm 설명
자바 소스코드는 컴파일러가 바이트 코드(.class)로 변환합니다.  <br>
이렇게 변경된 바이트 코드는 클래스 로더가 runtime data area로 로딩시킵니다.  <br>
이 영역은 5가지 영역으로 이루어져 있으며, 메소드와 힙 영역은 모든 스레드가 공유하는 영역이고, <br>
 스택, pc 레지스터, 네이티브 메소드 스택은 스레드 마다 하나씩 생성되는 공간입니다.  <br>
 
메소드 영역은 jvm이 시작될때 생성되는 공간으로,  <br>
모든 스레드가 공유하는 영역으로 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름,  <br>
리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성등이 저장이 됩니다.  <br>

힙영역은 동적으로 생성된 객체가 저장되는 영역으로, 뉴 연산을 통하여 동적으로 생성된  <br>
인스턴스 변수가 저장됩니다.  <br>
뉴 연산을 통해 생성된 데이터는 예를 들어 클래스의 객체, 배열등이 있고,  <br>
그렇게 생성된 변수는 해당 객체가 소멸되기 전이나 gc가 정리하기전까지는 남아있습니다.  <br>

스택 영역은 지역변수, 메서드의 매개변수, 임시적으로 사용되는 변수, 메서드의 정보가 저장되는  <br>
영역입니다. 지역변수와 매개변수의 특성상 해당 메서드에 호출이 종료되면 이 안에  <br>
선언된 변수들은 사라집니다. 주로 금방 사용되고 끝나는 데이터가 저장되는 영역입니다.  <br>

pc 레지스터는 현재 수행중인 jvm의 명령어 주소를 저장하는 공간입니다. <br>
 스레드가 어떤 부분을 어떤 명령어로 수행할지를 저장하는 공간  <br>
 
네이티브 메서드 스택은 자바가 아닌 다른언어로 작성된 코드를 위한 공간으로 ,  <br>
c, c++를 수행하기 위한 공간이고, 실제 실행할 수 있는 기계어를 실행시키는 영역  <br>
이제 runtinme area에 로딩된 클래스 파일이 execution engine을 통해  <br>
해석될 차례로, 바이트코드를 기계어로 바꾸는 작업이 필요한데 , 여기서 2가지 방법이 있다.  <br>

먼저 인터프리터는 명령어를 한줄한줄 해석하면서 실행을 한다. 그리고 <br>
JIT (Just in time) 컴파일러는 인터프리터의 단점을 해결하기 위해  <br>
런타임 시간에 한꺼번에 변경하여 실행합니다.  <br>
이렇게 기계어로 변경된 것들이 runtime data area에 배치되어  <br>
스레드 동기화 또는 가비지 컬렉션을 수행하게 됩니다.  <br>

마지막으로 네이티브 메소드 인터페이스와 라이브러리는  <br>
jvm에 의해 실행되는 코드중에 네이티브로 실행되는 것이 있다면,  <br>
해당 네이티브 코드를 호출하거나 호출 될수 있더록 만든 프레임 워크이고,  <br>
네이티브 메소드 라이브러리는 네이티브 메소드 실행에 필요한 라이브러리라고 합니다.  <br>


## 2. GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

> 정의 
 - 자바의 메모리 관리 방법중 하나로 jvm의 heap 영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

> 필요이유 
 - 메모리 누수 방지 : 사용하지 않는 객체를 해제하지않으면, 메모리 누수 발생 
 - 안전성 향상 : 수동으로 메모리 관리시의 오류를 방지하여 프로그램의 안정성 증진
동작방식 
 : Mark and Sweep 알고리즘 기반으로 동작
 - Marking : 루트 객체에서 그래프 순회를 통해 참조되고 있는 모든 객체 추적
 - Sweeping : 마킹 단계에서 unreachable 상태로 표시된 객체들을 heap에서 제거
 - Compacting : 메모리 단편화를 방지하기 위해 남아있는 객체들을 한쪽으로 모아서 연속적인 메모리 블록을 만듬

## 3. 컬렉션 프레임워크에 대해서 설명해주세요.
> 정의
-  객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스들의 집합.( 자료구조의 종류를 자바 클래스로 구현한 모음집 ) <br>
- Collection 인터페이스와 Map 인터페이스로 나뉨 
> 종류 
- List : 순서가 있는 요소의 집합. 중복 요소 허용 (arraylist, linkedlist, vector) 
( 배열과 리스트의 차이점은 리스트는 자료형 크기가 고정이 아닌데, 배열은 고정) 
- Set : 순서 보장 없음. 중복되지않는 요소의 집합 (hashset, linkedhashset..), 순서가 없으므로 get 메서드 없음
- Queue : 선입선출 구조. 
- Map : key-value 쌍으로 데이터 저장. 키 중복 불가. value 중복 가능 (hashmap, linkedhashmap..) 


## 4. 제네릭에 대해서 설명해주세요.
> 정의
- java에서 코드의 재사용성과 타입 안정성을 높이기 위해 도입된 기능.
> 특징
- 제네릭을 사용하면 클래스나 메서드에서 사용할 데이터 타입을 외부에서 지정할 수 있어, 다양한 타입에 대해 동일한 코드를 작성할 수 있다. 
- 제네릭을 사용하면 컴파일 시점에서 타입 검사가 이루어지기 때문에 런타임에서 발생할 수 있는 classCastException을 방지할 수 있다. 


## 5. 애노테이션에 대해서 설명해주세요.
> 정의
- java에서 메타데이터를 제공하는 일종의 마커로, 코드에 추가적인 정보 제공 및 특정 동작을 수행하도록 하는데 사용
> 특징
- 주석처럼 코드에 부가적인 정보를 제공, 컴파일러나 런타임시에도 정보 활용 가능
> 예시
- 컴파일러 지시 : @Override, @deprecated 처럼 컴파일러에게 특정 동작을 지시
- 런타임 지시 : @Autowired 처럼 스프링 프레임워크에서 빈 주입 등 런타임 시 특정 기능을 자동으로 처리하는 동작 지시
- 빌드 및 배포 도구 : @Entity, @Table 등 JPA 어노테이션으로 ORM을 정의하며, 엔티티 클래스가 디비 데이블과 어떻게 매핑되는지 지정.
- 커스텀 어노테이션을 정의도 가능. @interface 어노테이션을 지정.


## 6. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
> 오버라이딩 
- 부모 클래스의 메소드의 동작만을 재정의하는것이므로, 메소드의 선언부(매개변수 갯수, 리턴타입)는 기존 메소드와 같아야함
- 부모 클래스의 메소드보다 좁은 접근 제어자로 변경할수 있음

> 오버로딩 (overloading) 
- 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 정의해서 다양한 상황에서 사용하는 것을 의미
- 반환 타입과는 관계가 없음
- 오버로딩의 개념없이 메서드명을 다르게하여 각기 다른 메서드로 정의해서 사용해도 상관은 없으나, 객체지향의 다형성을 추구하기 위해 사용

## 7. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 추상 클래스는 단일 상속이지만, 인터페이스는 다중 구현이 가능 
- 추상 클래스는 필드와 메서드를 모두 가질 수 있지만, 인터페이스는 기본적인 메서드만 정의 가능
- 추상 클래스는 관계를 명확히 하고, 부모의 기능을 확장시키는데 목적이 있지만, 인터페이스는 클래스가 특정 기능을 구현하도록 강제하는 목적이 있습니다. 


## 8. 클래스는 무엇이고 객체는 무엇인가요?
> 클래스
- 객체를 정의하는 틀 또는 설계도. 객체의 속성과 메서드를 정의. jvm에 메서드 영역에 저장.
> 객체
- 클래스를 기반으로 만들어진 실제 인스턴스. jvm의 힙 영역에 할당
> 정리
- 클래스는 객체 지향 프로그래밍의 기본 단위로 객체를 생성하지 위한 설계도이고, 객체는 이 클래스를 기반으로 생성된 데이터와 기능을 포함한 인스턴스.


