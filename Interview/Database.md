# 데이터베이스

## 데이터베이스란 무엇인가요?
> 데이터베이스 정의
- 체계적으로 정리된 데이터의 집합으로, 애플리케이션에서 데이터를 효율적으로 저장, 검색, 수정할 수 있도록 설계된 시스템. 데이터 베이스는 데이터베이스 관리시스템(DBMS)에 의해 제어됨.
- 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터(Operational Data) : 업무를 수행하는데 반드시 필요한 자료
- 공용 데이터(Shared Data) : 여러 시스템들이 공동으로 소유하고 유지하는 자료

> 데이터베이스 특징
- 실시간 접근성(Real-Time Accessibility) : 실시간 처리에 의한 응답이 가능해야한다
- 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적. 새로운 데이터의 Insert, Delete, Update로 최신 데이터를 유지한다
- 동시공용(Concurrent Sharing) : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야한다
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는데이터를 참조할 때 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터 내용으로 찾는다

> 데이터베이스와 파일 시스템의 차이점은?
- 데이터베이스는 구조화된 방식으로 데이터를 저장하고 관계를 정의할 수 있지만, 파일 시스템은 단순히 데이터를 파일 형태로 저장.

> 데이터와 정보의 차이점은?
- 데이터(Data) : 현실 세계에서 측정하고 수집한 사실이나 값
- 정보(Information) : 어떤 목적이나 의도에 맞게 데이터를 가공 처리한 것

## RDBMS와 NoSQL의 차이점은 무엇인가요?
> RDBMS
- 관계형 데이터베이스 관리 시스템 (관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어)
- 정해진 스키마를 기반으로 데이터를 테이블 형식으로 저장
- 테이블 간의 관계는 외래키를 통해 정의, 데이터의 무결성과 참조 무결성 유지
- ACID 트랜잭션을 지원하여 데이터 무결성 보장
- 성능 향상은 Scale up 
- MySQL, Oracle, SQLite, PostgreSQL..

> NoSQL
- Document Database, Graph Database, Key-Value Database, Wide Column Database 등 다양한 데이터 모델 지원
- 스키마가 없어서 데이터 구조가 자주 변경되거나 다양한 형태의 데이터 저장 가능
- BASE 속성을 통해 일관성을 약하지만 가용성을 높임
- 성능 향상은 Scale out

> 차이점
- RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터가 고정된 스키마를 가진 테이블 형태로 저장. 데이터 간의 관계를 명확하게 정의하고, SQL을 통해 데이터를 관리. 주로 ACID 속성을 준수하여 트랜잭션의 일관성과 무결성을 보장
- NoSQL은 비관계형 데이터베이스로, 다양한 모델을 지원하며, 스키마가 유연. 수평 확장을 통해 대규모 데이터를 효율적으로 처리하며, 일관성보다는 가용성을 우선시하는 경우가 많아서 BASE 속성을 따르는 경우가 많음

> 적합한 사용 사례
- RDBMS는 은행, 금융 시스템과 같이 데이터 무결성과 일관성이 중요한 애플리케이션에 적합
- NoSQL은 대규모 데이터를 빠르게 처리해야 하거나 스키마가 자주 변경되는 애플리케이션에 적합

> 수직확장과 수평확장 비교
- RDBMS의 수직확장은 서버의 하드웨어 성능을 향상시켜 처리 능력을 높이는 방법. 데이터의 일관성을 유지하면서 성능을 개선할 수 있지만, 하드웨어 업그레이드 비용이 높고 확장성이 제한적
- NoSQL의 수평 확장은 여러 서버를 추가하여 데이터와 트래픽을 분산 처리하는 방식. 확장성이 뛰어나 대규모 데이터를 처리하는데 적합하지만, 데이터 일관성을 유지하기 어려울 수 있고, 복잡한 분산 처리 로직을 구현해야함

> BASE 속성 ( 기본적으로 가용성을 유지하며 데이터가 결국 일관적이게 되는 상태 ) 
- Basically Available: 시스템에 장애가 발생하더라도 항상 작동해야한다. 
- Soft state: 데이터가 반드시 항상 일관성을 유지할 필요는 없다 
- Eventually consistent: 결국 데이터는 결국 일관성을 유지하게 된다.
  

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
> 정의
- SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위해 사용하는 표준 프로그래밍 언어입니다. SQL의 주요 기능은 데이터 조회(SELECT), 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE) 등이 있으며, DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 

> DDL
- DDL(Data Definition Language)은 데이터베이스 구조를 정의하는 SQL 명령어 집합으로, CREATE, ALTER, DROP 등이 있습니다.
> DML
- DML(Data Manipulation Language)은 데이터베이스에 저장된 데이터를 조작하는 SQL 명령어로, SELECT, INSERT, UPDATE, DELETE 등이 있습니다.
> DCL
- DCL(Data Control Language)은 데이터베이스 사용 권한을 제어하는 SQL 명령어로, GRANT와 REVOKE가 있습니다.


## 데이터베이스 스키마란 무엇인가요?
> 정의
- 데이터베이스의 구조(개체, 속성, 관계)와 제약 조건에 대한 정의

> 종류
1. 외부 스키마(External Schema, 서브 스키마, 사용자 뷰)
  - 사용자들이 사용할 데이터들을 보여주는 것이므로 추상화가 되어있고, 여러 사용자가 바라보는 관점에 따라 여러 스키마가 존재할 수 있음 
  - 사용자는 데이터베이스에서 데이터를 사용하는 사람이므로 응용 프로그래머로 볼수있음
  - 사용자는 어떤 데이터가 필요한지 결정하므로 쿼리를 이용해서 데이터 조작 가능
  - 응용 프로그래머는 외부 스키마를 통해 구조를 확인하고, DML을 사용해서 데이터를 이용 

2. 개념 스키마(Conceptual Schema, 전체적인 뷰)
  - 데이터베이스의 전체적인 논리적 구조
  - 데이터베이스의 구조, 구체적으로 어떤 데이터가 있고, 각 테이블간의 관계 정의
  - 데이터베이스 관리자(DBA)에 의해서 구성
  - DDL, DCL를 사용하여 구조를 설계
    
3. 내부 스키마(Internal SCheam, 저장 스키마)
  - 물리적 저장장치의 입장에서 본 데이터베이스 구조
  - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  - 데이터의 필드 이름, 해당 필드는 몇 바이트이며 인덱스가 있는지 등을 정의
  - 시스템 프로그래머나 설계자가 보는 관점의 스키마

> 내부 스키마에서 인덱스를 설계할 때 고려해야할 사항은?
- 쿼리 성능을 최적화하기 위해 자주 조회되는 열에 대해서 인덱스를 생성하는것이 중요합니다. 또한 너무 많은 인덱스는 쓰기 성능에 영향을 줄 수 있으므로, 필요한 인덱스만 생성하는것이 중요합니다.

> 스키마 변경이 필요한 상황에서 어떻게 처리하나요?
- 변경의 필요성을 분석하고, 데이터 무결성 및 기존 데이터와의 호환성을 고려해야합니다. 또한 변경사항에 따른 영향도 파악과 테스트를 진행해야하며, 백업, 변경 계힉, 스키마 변경 진행, 데이터 마이그레이션, 테스트, 롤백 계획을 진행해야합니다. 


## 테이블과 뷰(View)의 차이점은 무엇인가요?
> 테이블
- 데이터베이스에서 데이터를 실제로 저장하는 구조
- 테이블에 데이터를 삽입, 수정, 삭제 가능
- 제약 조건 정의 가능

> 뷰(View)
- 하나 이상의 테이블을 기반으로 하는 가상의 테이블
- 실제 데이터를 저장하지 않고, 쿼리 결과를 동적으로 생성하여 제공하는 논리적 구조
- 보안 목적으로 특정 사용자에게만 필요한 데이터를 제공하는데 유용
- 데이터를 삽입, 수정, 삭제할 수 없으나, 특정 조건 만족시에는 가능한 경우도 존재
- CREATE VIEW 뷰이름 AS SELECT 구문;

> 차이점
- 테이블은 데이터를 물리적으로 저장하는 구조이고 뷰는 데이터를 저장하지 않고 데이터를 조회하는 가상의 테이블. 테이블에서는 데이터를 삽입, 삭제, 수정 할수 있지만, 뷰에서는 기본적으로는 불가능. 또한 뷰는 특정 데이터를 쉽게 조회하거나 보안 목적으로 사용

> VIEW와 Materialized View 차이점에 대해서 설명해주세요
- VIEW는 실시간 데이터를 조회하며, 물리적으로 데이터를 저장하지 않는 가상 테이블이고, 데이터가 실시간으로 반영되지만, 복잡한 쿼리에서는 성능이 저하될수 있습니다. Materialized View는 쿼리 결과를 사전에 계산하여 저장하는 테이블로, 빠른 조회 성능을 제공하지만, 갱신이 필요하며 데이터가 항상 최신이 아닐수 있습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
> 기본키
- 테이블 내에서 각 행을 고유하게 식별하는 키
- 중복과 NULL을 가질수 없음
- 기본키는 자동으로 인덱싱되어 검색 성능 향상

> 외래키
- 두 테이블 간의 관계를 설정
- 참조 무결성 유지
- 외래키는 중복될 수 있으며, NULL 값도 가질수있음
  
> 차이점
- 기본키는 테이블 내에서 각 행을 고유하게 식별하기 위한 키이며, 중복될 수 없고 NULL 값을 가질 수 없습니다. 반면, 외래키는 한 테이블이 다른 테이블의 기본키를 참조하여 관계를 설정하는 키로, 중복될 수 있으며 NULL 값을 가질 수 있습니다. 기본키는 테이블의 고유성을 보장하고, 외래키는 테이블 간의 참조 무결성을 유지합니다.

> 외래키가 참조하는 테이블에서 행이 삭제되면 어떻게 되나요?
- 외래키 제약 조건에 따라 달라짐.
- CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블에서도 삭제와 수정이 같이 이루어짐
- SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 NULL로 변경
- NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 변경되지않음
- RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
> ACID 란
- ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 속성 

- Atomicity(원자성): 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 한다. 
- Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스가 일관된 상태를 유지해야한다.
- Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 보장합니다.
- Durability(영속성): 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야한다.

> ACID 속성 중 어느 하나가 실패하면 어떤 일이 발생하나요?
- 데이터베이스가 일관된 상태를 유지하지 못하며, 트랜잭션이 중단되거나 롤백될 수 있습니다.
> 트랜잭션 격리 수준이란 무엇인가요?
- 트랜잭션이 서로 얼마나 격리되어 있는지를 정의하는 설정으로 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등의 수준이 있습니다.

## 트랜잭션이란 무엇인가요?
> 트랜잭션이란
- 데이터베이스에서 일련의 연산을 수행하는 논리적 작업 단위로, 하나의 트랜잭션 내에서 모든 작업이 성공하거나 모두 실패해야 합니다. 트랜잭션은 데이터의 일관성을 유지하고, 데이터베이스에 대한 여러 연산을 하나의 단위로 묶어 처리합니다.

> 트랜잭션의 네 가지 특성은 무엇인가요?
- ACID 속성(원자성, 일관성, 격리성, 영속성)입니다.
> 트랜잭션이 롤백되는 상황은 언제인가요?
- 오류가 발생하거나, 조건이 만족되지 않을 때 롤백이 발생할 수 있습니다.
> 트랜잭션에서 SAVEPOINT란 무엇인가요?
- 트랜잭션 내에서 설정할 수 있는 임시 저장점으로, 롤백 시 특정 SAVEPOINT까지 되돌릴 수 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
> 정의
- 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 최적화하는 과정입니다. 정규화를 통해 데이터의 무결성을 유지하고, 업데이트, 삭제 시 발생할 수 있는 이상 현상을 방지합니다.
- 제 1정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는것
- 제 2정규화 : 제 1정규화를 진행한 테이블에 대해 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안되는것을 의미)을 만족하도록 테이블을 분해하는것
- 제 3정규화 : 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것
- BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는것

> 정규화의 단점은 무엇인가요?
- 과도한 정규화는 성능 저하를 초래할 수 있으며, 복잡한 쿼리를 생성할 수 있습니다.
> 정규화와 반정규화의 차이점은 무엇인가요?
- 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 것이 목적이며, 반정규화는 성능 최적화를 위해 의도적으로 데이터 중복을 허용하는 과정입니다.

- https://datarian.io/blog/database-normalization

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
> 정의
- 역정규화(Denormalization)는 성능 최적화를 위해 의도적으로 정규화된 데이터베이스를 일부 비정규화하는 과정입니다. 이를 통해 데이터 조회 성능을 향상시키고, 복잡한 JOIN 연산을 줄일 수 있습니다. 주로 읽기 성능을 중시하는 시스템에서 사용됩니다.

> 역정규화의 단점은 무엇인가요?
- 데이터 중복이 증가하여 데이터 무결성이 저하될 수 있으며, 저장 공간이 더 많이 필요할 수 있습니다.
> 역정규화의 구체적인 예를 들어보세요.
- 고객 정보와 주문 정보를 하나의 테이블로 합쳐, 각 주문 조회 시 고객 정보를 함께 조회할 수 있도록 하는 것이 예입니다.
> 정규화와 역정규화의 균형을 어떻게 맞추나요?
- 시스템의 요구사항에 따라, 읽기 및 쓰기 성능, 데이터 무결성, 유지보수 용이성 등을 고려해 결정합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
- INNER JOIN: 두 테이블에서 공통적으로 존재하는 데이터 반환 ( 교집합 ) 
- LEFT JOIN: 왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환. 오른쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- RIGHT JOIN: 오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환. 왼쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- FULL JOIN: 양쪽 테이블에서 일치하는 모든 행을 반환하며, 일치하지 않는 행은 NULL

> SELF JOIN이란 무엇인가요?
- 자기 자신과의 JOIN을 의미하며, 같은 테이블의 다른 행을 연결하여 조회할 때 사용됩니다.
> CROSS JOIN이란 무엇인가요?
- 두 테이블의 모든 행 조합을 반환하는 JOIN입니다. 결과는 테이블의 곱(Cartesian Product)입니다.
> JOIN에서 ON과 USING의 차이점은 무엇인가요?
- ON은 모든 조건을 사용해 조인을 설정할 수 있으며, USING은 동일한 이름의 열에 대해 자동으로 조인을 설정합니다.


## GROUP BY와 HAVING의 차이점은 무엇인가요?
- GROUP BY는 결과 집합을 그룹화하는 데 사용되며, HAVING은 그룹화된 결과에 조건을 적용하는 데 사용됩니다.

> GROUP BY에서 COUNT와 함께 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;
> HAVING에서 COUNT를 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name HAVING COUNT(*) > 1;

## WHERE와 HAVING의 차이점은 무엇인가요?
- WHERE는 SQL 쿼리에서 개별 행에 대해 조건을 적용하여 필터링하고, HAVING은 GROUP BY 절로 그룹화된 결과에 조건을 적용하여 필터링합니다. WHERE는 그룹화 전에 필터링을 수행하고, HAVING은 그룹화 후에 필터링을 수행합니다.

> WHERE 절에서 사용할 수 없는 SQL 함수를 예로 들어보세요.
- 집계 함수(예: COUNT, SUM, AVG 등)는 WHERE 절에서 사용할 수 없고, HAVING 절에서 사용해야 합니다.
> HAVING을 WHERE 대신 사용하는 경우는 언제인가요?
- 집계된 데이터에 조건을 적용할 때 HAVING을 사용합니다.

## DISTINCT 키워드는 무엇을 하는가요?
- DISTINCT 키워드는 SELECT 문에서 사용하여 중복된 값을 제거하고 고유한 값을 반환합니다. 이를 통해 쿼리 결과에서 중복된 행을 제외하고 고유한 결과를 얻을 수 있습니다.

> DISTINCT와 GROUP BY의 차이점은 무엇인가요?
- DISTINCT는 중복된 값을 제거하여 고유한 결과를 반환하고, GROUP BY는 데이터를 그룹화하여 집계함수를 사용하는 데 주로 사용됩니다.
> DISTINCT를 사용하는 예를 들어보세요.
- SELECT DISTINCT column_name FROM table_name;


## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
- 서브쿼리(Subquery)는 하나의 SQL 문 안에 포함된 또 다른 쿼리입니다. 
- 복잡한 계산이나 연산을 괄호로 묶어서 수행할 수 있음
- 서브 쿼리는 메인 쿼리의 속성을 그대로 받지만, 메인 쿼리에서는 서브 쿼리의 내용을 참조할 수 없음. 반대로 서브쿼리에서 메인 쿼리의 내용을 참조는 가능

> 종류
1. 스칼라 서브쿼리
   - SELECT 절에 위치하며 한 레코드당 하나의 값을 반환하는 서브쿼리(단일행, 단일컬럼을 반환)
   - 다중행 값 조회되면 "ORA-01427: single-row subquery returns more than one row" 오류 발생
2. 인라인 뷰
   - FROM 절에 위치하는 서브쿼리로 결과는 반드시 하나의 테이블로 리턴
   - 인라인 뷰는 SQL 문이 실행될때 임시적으로 생성되는 동적인 뷰
   - 단점 : SQL을 좀 더 빠른 속도로 사용하기 위한 것이지만, 잘못 사용하게 되면 액세스 속도를 저하 시키는 경우도 많음 
3. 중첩 서브쿼리
   - WHERE 절에 위치하며 메인쿼리 테이블의 특정 컬럼 값과 비교한 값을 반환하는 용도로 주로 사용
   - 단일행, 다중행 반환 가능 

> 서브쿼리와 JOIN 중 어느 것이 더 효율적인가요?
- 상황에 따라 다르지만, JOIN이 일반적으로 더 효율적일 수 있습니다.

## UNION과 UNION ALL의 차이점은 무엇인가요?
- UNION은 두 개의 SELECT 결과를 결합하여 중복된 행을 제거한 후 반환합니다. 반면, UNION ALL은 두 SELECT 결과를 결합하여 중복된 행을 포함한 모든 결과를 반환합니다.

> UNION을 사용한 쿼리의 예를 들어보세요.
- SELECT column_name FROM table1 UNION SELECT column_name FROM table2;
> UNION ALL을 사용하는 이유는 무엇인가요?
- 중복된 데이터를 포함한 전체 결과를 반환하려는 경우 사용합니다.
> UNION과 JOIN의 차이점은 무엇인가요?
- UNION은 두 개의 쿼리 결과를 수직으로 결합하는 반면, JOIN은 두 개의 테이블을 수평으로 결합합니다.

## EXISTS와 IN의 차이점은 무엇인가요?
> EXISTS
- 서브쿼리가 결과를 반환하는지 여부를 확인
- 서브쿼리가 하나 이상의 행을 반환하면 TRUE, 그렇지 않으면 FALSE 반환
- 메인 쿼리의 각 행에 대해 서브쿼리를 싱행하고, 조건을 만족하는 첫 번째 행을 찾으면 실행을 중단
- 서브쿼리가 결과를 반환할 수 있는지 여부만을 확인하므로, 서브쿼리 결과가 크더라도 비교적 효율적으로 작동
- 처리 순서 : 메인쿼리 -> 서브쿼리 
``` SQL
SELECT department_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.department_id);
```
> IN
- 서브쿼리가 반환한 결과 중 하나라도 메인 쿼리의 조건과 일치하는지 확인
- 서브쿼리에서 반환된 모든 값을 메모리에 로드한 후, 메인 쿼리의 각 행에 대해 서브쿼리 목록과 비교
- 반환하는 결과가 작은 경우에 효율적으로 작동
-  처리 순서 : 서브쿼리 -> 메인쿼리 
``` SQL
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1700);
```

> 어떤 상황에서 EXISTS를 사용하는 것이 IN보다 더 효율적인가요?
- 서브쿼리가 매우 큰 결과 집합을 반환하거나, 메인 쿼리와 서브쿼리의 테이블 간에 상관 관계가 있을 때 EXISTS를 사용하는 것이 더 효율적일 수 있습니다. EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 실행을 중지하기 때문에, 서브쿼리의 결과가 클 때 성능이 더 좋습니다. 또한, 서브쿼리가 인덱스된 열에 대해 실행될 때 EXISTS가 더 효율적으로 동작할 수 있습니다.
>  IN 연산자를 사용할 때 주의해야 할 점은 무엇인가요?
- IN 연산자를 사용할 때 주의해야 할 점은 서브쿼리가 반환하는 결과 목록이 너무 크지 않도록 하는 것입니다. 서브쿼리의 결과가 큰 경우 성능이 저하될 수 있습니다. 또한, IN 연산자 사용 시 NULL 값을 포함한 비교가 이루어질 때 결과가 예상과 다를 수 있으므로, NULL 처리에 유의해야 합니다. NULL 값이 포함된 경우, 비교 연산에서 불확실성을 초래할 수 있습니다.
  
## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
- 여러 행으로부터 하나의결과값을 반환하는 함수. 
> 종류 
- COUNT: 행의 개수를 반환
- SUM: 열의 합계를 반환
- AVG: 열의 평균값을 반환
- MIN: 열의 최소값을 반환
- MAX: 열의 최대값을 반환

> COUNT와 DISTINCT를 함께 사용하는 방법은 무엇인가요?
- SELECT COUNT(DISTINCT column_name) FROM table_name;
> 집계 함수에서 NULL 값은 어떻게 처리되나요?
- 대부분의 집계 함수는 NULL 값을 무시합니다. 그러나 COUNT(*)는 NULL 값을 포함합니다.
> 집계 함수를 GROUP BY와 함께 사용하는 예를 보여주세요.
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;


## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
- 하나 이상의 테이블을 기반으로 생성된 가상의 테이블
- 실제 데이터를 저장하지 않고 기본 테이블의 데이터를 조회할 수 있는 SQL 쿼리의 결과를 저장한 논리적 구조
- 복잡한 쿼리를 단순화하고, 특정 데이터를 쉽게 조회하거나 보안을 강화하기 위해 사용

> 장점
- 사용자가 접근할 수 있는 데이터를 제한하여 보안 강화
- 자주 사용하는 복잡한 쿼리를 뷰로 정의해 두면 간단한 SELECT 문으로 동일한 결과 반환 가능
- 특정 데이터를 표준화된 방식으로 제공함으로써 여러 사용자에게 일관된 데이터를 사용할 수 있게 함
- 동일한 뷰를 여러 쿼리에서 사용하므로 코드의 중복을 줄이고, 유지보수 쉽게 가능

> 단점
- 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 복잡한 뷰나 조인이 많은 뷰는 성능 저하를 초래할 수 있음
- 데이터의 삽입, 수정, 삭제하는것이 제한
- 기본 테이블의 구조가 변경되면 오류가 발생할 수 있어 유지보수 필요

> VIEW가 기본 테이블에서 데이터를 가져올 때 실시간으로 쿼리를 실행하는데, 이로 인해 어떤 문제점이 발생할 수 있나요?
- VIEW는 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 기본 테이블이 큰 경우 또는 VIEW가 복잡한 조인을 포함하는 경우 성능 문제가 발생할 수 있습니다. 특히, 여러 테이블을 조인하거나 중첩된 VIEW를 사용하는 경우 쿼리 실행 시간이 길어질 수 있으며, 전체 시스템 성능에 부정적인 영향을 미칠 수 있습니다.


## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- CASE문은 SQL에서 조건에 따라 다른 값을 반환할 수 있도록 하는 조건부 표현식
  
```` SQL
SELECT column_name,
       CASE
           WHEN 조건1 THEN 결과1
           WHEN 조건2 THEN 결과2
           ELSE 결과3
       END AS new_column_name
FROM table_name;
````

> CASE문을 사용하여 집계 데이터를 구분하는 예를 들어보세요.
- SELECT SUM(CASE WHEN column_name > 100 THEN 1 ELSE 0 END) FROM table_name;

> CASE 문을 사용해서 조건부로 데이터를 업데이트할 수 있나요?
```SQL
UPDATE employees
SET bonus = CASE
               WHEN salary > 100000 THEN salary * 0.1
               WHEN salary BETWEEN 50000 AND 100000 THEN salary * 0.05
               ELSE 0
           END;
```


# 데이터베이스

## 데이터베이스란 무엇인가요?
> 데이터베이스 정의
- 체계적으로 정리된 데이터의 집합으로, 애플리케이션에서 데이터를 효율적으로 저장, 검색, 수정할 수 있도록 설계된 시스템. 데이터 베이스는 데이터베이스 관리시스템(DBMS)에 의해 제어됨.
- 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터(Operational Data) : 업무를 수행하는데 반드시 필요한 자료
- 공용 데이터(Shared Data) : 여러 시스템들이 공동으로 소유하고 유지하는 자료

> 데이터베이스 특징
- 실시간 접근성(Real-Time Accessibility) : 실시간 처리에 의한 응답이 가능해야한다
- 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적. 새로운 데이터의 Insert, Delete, Update로 최신 데이터를 유지한다
- 동시공용(Concurrent Sharing) : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야한다
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는데이터를 참조할 때 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터 내용으로 찾는다

> 데이터베이스와 파일 시스템의 차이점은?
- 데이터베이스는 구조화된 방식으로 데이터를 저장하고 관계를 정의할 수 있지만, 파일 시스템은 단순히 데이터를 파일 형태로 저장.

> 데이터와 정보의 차이점은?
- 데이터(Data) : 현실 세계에서 측정하고 수집한 사실이나 값
- 정보(Information) : 어떤 목적이나 의도에 맞게 데이터를 가공 처리한 것

## RDBMS와 NoSQL의 차이점은 무엇인가요?
> RDBMS
- 관계형 데이터베이스 관리 시스템 (관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어)
- 정해진 스키마를 기반으로 데이터를 테이블 형식으로 저장
- 테이블 간의 관계는 외래키를 통해 정의, 데이터의 무결성과 참조 무결성 유지
- ACID 트랜잭션을 지원하여 데이터 무결성 보장
- 성능 향상은 Scale up 
- MySQL, Oracle, SQLite, PostgreSQL..

> NoSQL
- Document Database, Graph Database, Key-Value Database, Wide Column Database 등 다양한 데이터 모델 지원
- 스키마가 없어서 데이터 구조가 자주 변경되거나 다양한 형태의 데이터 저장 가능
- BASE 속성을 통해 일관성을 약하지만 가용성을 높임
- 성능 향상은 Scale out

> 차이점
- RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터가 고정된 스키마를 가진 테이블 형태로 저장. 데이터 간의 관계를 명확하게 정의하고, SQL을 통해 데이터를 관리. 주로 ACID 속성을 준수하여 트랜잭션의 일관성과 무결성을 보장
- NoSQL은 비관계형 데이터베이스로, 다양한 모델을 지원하며, 스키마가 유연. 수평 확장을 통해 대규모 데이터를 효율적으로 처리하며, 일관성보다는 가용성을 우선시하는 경우가 많아서 BASE 속성을 따르는 경우가 많음

> 적합한 사용 사례
- RDBMS는 은행, 금융 시스템과 같이 데이터 무결성과 일관성이 중요한 애플리케이션에 적합
- NoSQL은 대규모 데이터를 빠르게 처리해야 하거나 스키마가 자주 변경되는 애플리케이션에 적합

> 수직확장과 수평확장 비교
- RDBMS의 수직확장은 서버의 하드웨어 성능을 향상시켜 처리 능력을 높이는 방법. 데이터의 일관성을 유지하면서 성능을 개선할 수 있지만, 하드웨어 업그레이드 비용이 높고 확장성이 제한적
- NoSQL의 수평 확장은 여러 서버를 추가하여 데이터와 트래픽을 분산 처리하는 방식. 확장성이 뛰어나 대규모 데이터를 처리하는데 적합하지만, 데이터 일관성을 유지하기 어려울 수 있고, 복잡한 분산 처리 로직을 구현해야함

> BASE 속성 ( 기본적으로 가용성을 유지하며 데이터가 결국 일관적이게 되는 상태 ) 
- Basically Available: 시스템에 장애가 발생하더라도 항상 작동해야한다. 
- Soft state: 데이터가 반드시 항상 일관성을 유지할 필요는 없다 
- Eventually consistent: 결국 데이터는 결국 일관성을 유지하게 된다.
  

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
> 정의
- SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위해 사용하는 표준 프로그래밍 언어입니다. SQL의 주요 기능은 데이터 조회(SELECT), 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE) 등이 있으며, DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 

> DDL
- DDL(Data Definition Language)은 데이터베이스 구조를 정의하는 SQL 명령어 집합으로, CREATE, ALTER, DROP 등이 있습니다.
> DML
- DML(Data Manipulation Language)은 데이터베이스에 저장된 데이터를 조작하는 SQL 명령어로, SELECT, INSERT, UPDATE, DELETE 등이 있습니다.
> DCL
- DCL(Data Control Language)은 데이터베이스 사용 권한을 제어하는 SQL 명령어로, GRANT와 REVOKE가 있습니다.


## 데이터베이스 스키마란 무엇인가요?
> 정의
- 데이터베이스의 구조(개체, 속성, 관계)와 제약 조건에 대한 정의

> 종류
1. 외부 스키마(External Schema, 서브 스키마, 사용자 뷰)
  - 사용자들이 사용할 데이터들을 보여주는 것이므로 추상화가 되어있고, 여러 사용자가 바라보는 관점에 따라 여러 스키마가 존재할 수 있음 
  - 사용자는 데이터베이스에서 데이터를 사용하는 사람이므로 응용 프로그래머로 볼수있음
  - 사용자는 어떤 데이터가 필요한지 결정하므로 쿼리를 이용해서 데이터 조작 가능
  - 응용 프로그래머는 외부 스키마를 통해 구조를 확인하고, DML을 사용해서 데이터를 이용 

2. 개념 스키마(Conceptual Schema, 전체적인 뷰)
  - 데이터베이스의 전체적인 논리적 구조
  - 데이터베이스의 구조, 구체적으로 어떤 데이터가 있고, 각 테이블간의 관계 정의
  - 데이터베이스 관리자(DBA)에 의해서 구성
  - DDL, DCL를 사용하여 구조를 설계
    
3. 내부 스키마(Internal SCheam, 저장 스키마)
  - 물리적 저장장치의 입장에서 본 데이터베이스 구조
  - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  - 데이터의 필드 이름, 해당 필드는 몇 바이트이며 인덱스가 있는지 등을 정의
  - 시스템 프로그래머나 설계자가 보는 관점의 스키마

> 내부 스키마에서 인덱스를 설계할 때 고려해야할 사항은?
- 쿼리 성능을 최적화하기 위해 자주 조회되는 열에 대해서 인덱스를 생성하는것이 중요합니다. 또한 너무 많은 인덱스는 쓰기 성능에 영향을 줄 수 있으므로, 필요한 인덱스만 생성하는것이 중요합니다.

> 스키마 변경이 필요한 상황에서 어떻게 처리하나요?
- 변경의 필요성을 분석하고, 데이터 무결성 및 기존 데이터와의 호환성을 고려해야합니다. 또한 변경사항에 따른 영향도 파악과 테스트를 진행해야하며, 백업, 변경 계힉, 스키마 변경 진행, 데이터 마이그레이션, 테스트, 롤백 계획을 진행해야합니다. 


## 테이블과 뷰(View)의 차이점은 무엇인가요?
> 테이블
- 데이터베이스에서 데이터를 실제로 저장하는 구조
- 테이블에 데이터를 삽입, 수정, 삭제 가능
- 제약 조건 정의 가능

> 뷰(View)
- 하나 이상의 테이블을 기반으로 하는 가상의 테이블
- 실제 데이터를 저장하지 않고, 쿼리 결과를 동적으로 생성하여 제공하는 논리적 구조
- 보안 목적으로 특정 사용자에게만 필요한 데이터를 제공하는데 유용
- 데이터를 삽입, 수정, 삭제할 수 없으나, 특정 조건 만족시에는 가능한 경우도 존재
- CREATE VIEW 뷰이름 AS SELECT 구문;

> 차이점
- 테이블은 데이터를 물리적으로 저장하는 구조이고 뷰는 데이터를 저장하지 않고 데이터를 조회하는 가상의 테이블. 테이블에서는 데이터를 삽입, 삭제, 수정 할수 있지만, 뷰에서는 기본적으로는 불가능. 또한 뷰는 특정 데이터를 쉽게 조회하거나 보안 목적으로 사용

> VIEW와 Materialized View 차이점에 대해서 설명해주세요
- VIEW는 실시간 데이터를 조회하며, 물리적으로 데이터를 저장하지 않는 가상 테이블이고, 데이터가 실시간으로 반영되지만, 복잡한 쿼리에서는 성능이 저하될수 있습니다. Materialized View는 쿼리 결과를 사전에 계산하여 저장하는 테이블로, 빠른 조회 성능을 제공하지만, 갱신이 필요하며 데이터가 항상 최신이 아닐수 있습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
> 기본키
- 테이블 내에서 각 행을 고유하게 식별하는 키
- 중복과 NULL을 가질수 없음
- 기본키는 자동으로 인덱싱되어 검색 성능 향상

> 외래키
- 두 테이블 간의 관계를 설정
- 참조 무결성 유지
- 외래키는 중복될 수 있으며, NULL 값도 가질수있음
  
> 차이점
- 기본키는 테이블 내에서 각 행을 고유하게 식별하기 위한 키이며, 중복될 수 없고 NULL 값을 가질 수 없습니다. 반면, 외래키는 한 테이블이 다른 테이블의 기본키를 참조하여 관계를 설정하는 키로, 중복될 수 있으며 NULL 값을 가질 수 있습니다. 기본키는 테이블의 고유성을 보장하고, 외래키는 테이블 간의 참조 무결성을 유지합니다.

> 외래키가 참조하는 테이블에서 행이 삭제되면 어떻게 되나요?
- 외래키 제약 조건에 따라 달라짐.
- CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블에서도 삭제와 수정이 같이 이루어짐
- SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 NULL로 변경
- NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 변경되지않음
- RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
> ACID 란
- ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 속성 

- Atomicity(원자성): 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 한다. 
- Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스가 일관된 상태를 유지해야한다.
- Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 보장합니다.
- Durability(영속성): 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야한다.

> ACID 속성 중 어느 하나가 실패하면 어떤 일이 발생하나요?
- 데이터베이스가 일관된 상태를 유지하지 못하며, 트랜잭션이 중단되거나 롤백될 수 있습니다.
> 트랜잭션 격리 수준이란 무엇인가요?
- 트랜잭션이 서로 얼마나 격리되어 있는지를 정의하는 설정으로 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등의 수준이 있습니다.

## 트랜잭션이란 무엇인가요?
> 트랜잭션이란
- 데이터베이스에서 일련의 연산을 수행하는 논리적 작업 단위로, 하나의 트랜잭션 내에서 모든 작업이 성공하거나 모두 실패해야 합니다. 트랜잭션은 데이터의 일관성을 유지하고, 데이터베이스에 대한 여러 연산을 하나의 단위로 묶어 처리합니다.

> 트랜잭션의 네 가지 특성은 무엇인가요?
- ACID 속성(원자성, 일관성, 격리성, 영속성)입니다.
> 트랜잭션이 롤백되는 상황은 언제인가요?
- 오류가 발생하거나, 조건이 만족되지 않을 때 롤백이 발생할 수 있습니다.
> 트랜잭션에서 SAVEPOINT란 무엇인가요?
- 트랜잭션 내에서 설정할 수 있는 임시 저장점으로, 롤백 시 특정 SAVEPOINT까지 되돌릴 수 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
> 정의
- 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 최적화하는 과정입니다. 정규화를 통해 데이터의 무결성을 유지하고, 업데이트, 삭제 시 발생할 수 있는 이상 현상을 방지합니다.
- 제 1정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는것
- 제 2정규화 : 제 1정규화를 진행한 테이블에 대해 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안되는것을 의미)을 만족하도록 테이블을 분해하는것
- 제 3정규화 : 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것
- BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는것

> 정규화의 단점은 무엇인가요?
- 과도한 정규화는 성능 저하를 초래할 수 있으며, 복잡한 쿼리를 생성할 수 있습니다.
> 정규화와 반정규화의 차이점은 무엇인가요?
- 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 것이 목적이며, 반정규화는 성능 최적화를 위해 의도적으로 데이터 중복을 허용하는 과정입니다.

- https://datarian.io/blog/database-normalization

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
> 정의
- 역정규화(Denormalization)는 성능 최적화를 위해 의도적으로 정규화된 데이터베이스를 일부 비정규화하는 과정입니다. 이를 통해 데이터 조회 성능을 향상시키고, 복잡한 JOIN 연산을 줄일 수 있습니다. 주로 읽기 성능을 중시하는 시스템에서 사용됩니다.

> 역정규화의 단점은 무엇인가요?
- 데이터 중복이 증가하여 데이터 무결성이 저하될 수 있으며, 저장 공간이 더 많이 필요할 수 있습니다.
> 역정규화의 구체적인 예를 들어보세요.
- 고객 정보와 주문 정보를 하나의 테이블로 합쳐, 각 주문 조회 시 고객 정보를 함께 조회할 수 있도록 하는 것이 예입니다.
> 정규화와 역정규화의 균형을 어떻게 맞추나요?
- 시스템의 요구사항에 따라, 읽기 및 쓰기 성능, 데이터 무결성, 유지보수 용이성 등을 고려해 결정합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
- INNER JOIN: 두 테이블에서 공통적으로 존재하는 데이터 반환 ( 교집합 ) 
- LEFT JOIN: 왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환. 오른쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- RIGHT JOIN: 오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환. 왼쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- FULL JOIN: 양쪽 테이블에서 일치하는 모든 행을 반환하며, 일치하지 않는 행은 NULL

> SELF JOIN이란 무엇인가요?
- 자기 자신과의 JOIN을 의미하며, 같은 테이블의 다른 행을 연결하여 조회할 때 사용됩니다.
> CROSS JOIN이란 무엇인가요?
- 두 테이블의 모든 행 조합을 반환하는 JOIN입니다. 결과는 테이블의 곱(Cartesian Product)입니다.
> JOIN에서 ON과 USING의 차이점은 무엇인가요?
- ON은 모든 조건을 사용해 조인을 설정할 수 있으며, USING은 동일한 이름의 열에 대해 자동으로 조인을 설정합니다.


## GROUP BY와 HAVING의 차이점은 무엇인가요?
- GROUP BY는 결과 집합을 그룹화하는 데 사용되며, HAVING은 그룹화된 결과에 조건을 적용하는 데 사용됩니다.

> GROUP BY에서 COUNT와 함께 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;
> HAVING에서 COUNT를 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name HAVING COUNT(*) > 1;

## WHERE와 HAVING의 차이점은 무엇인가요?
- WHERE는 SQL 쿼리에서 개별 행에 대해 조건을 적용하여 필터링하고, HAVING은 GROUP BY 절로 그룹화된 결과에 조건을 적용하여 필터링합니다. WHERE는 그룹화 전에 필터링을 수행하고, HAVING은 그룹화 후에 필터링을 수행합니다.

> WHERE 절에서 사용할 수 없는 SQL 함수를 예로 들어보세요.
- 집계 함수(예: COUNT, SUM, AVG 등)는 WHERE 절에서 사용할 수 없고, HAVING 절에서 사용해야 합니다.
> HAVING을 WHERE 대신 사용하는 경우는 언제인가요?
- 집계된 데이터에 조건을 적용할 때 HAVING을 사용합니다.

## DISTINCT 키워드는 무엇을 하는가요?
- DISTINCT 키워드는 SELECT 문에서 사용하여 중복된 값을 제거하고 고유한 값을 반환합니다. 이를 통해 쿼리 결과에서 중복된 행을 제외하고 고유한 결과를 얻을 수 있습니다.

> DISTINCT와 GROUP BY의 차이점은 무엇인가요?
- DISTINCT는 중복된 값을 제거하여 고유한 결과를 반환하고, GROUP BY는 데이터를 그룹화하여 집계함수를 사용하는 데 주로 사용됩니다.
> DISTINCT를 사용하는 예를 들어보세요.
- SELECT DISTINCT column_name FROM table_name;

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
- 서브쿼리(Subquery)는 하나의 SQL 문 안에 포함된 또 다른 쿼리입니다. 
- 복잡한 계산이나 연산을 괄호로 묶어서 수행할 수 있음
- 서브 쿼리는 메인 쿼리의 속성을 그대로 받지만, 메인 쿼리에서는 서브 쿼리의 내용을 참조할 수 없음. 반대로 서브쿼리에서 메인 쿼리의 내용을 참조는 가능

> 종류
1. 스칼라 서브쿼리
   - SELECT 절에 위치하며 한 레코드당 하나의 값을 반환하는 서브쿼리(단일행, 단일컬럼을 반환)
   - 다중행 값 조회되면 "ORA-01427: single-row subquery returns more than one row" 오류 발생
2. 인라인 뷰
   - FROM 절에 위치하는 서브쿼리로 결과는 반드시 하나의 테이블로 리턴
   - 인라인 뷰는 SQL 문이 실행될때 임시적으로 생성되는 동적인 뷰
   - 단점 : SQL을 좀 더 빠른 속도로 사용하기 위한 것이지만, 잘못 사용하게 되면 액세스 속도를 저하 시키는 경우도 많음 
3. 중첩 서브쿼리
   - WHERE 절에 위치하며 메인쿼리 테이블의 특정 컬럼 값과 비교한 값을 반환하는 용도로 주로 사용
   - 단일행, 다중행 반환 가능 

> 서브쿼리와 JOIN 중 어느 것이 더 효율적인가요?
- 상황에 따라 다르지만, JOIN이 일반적으로 더 효율적일 수 있습니다.

## UNION과 UNION ALL의 차이점은 무엇인가요?
- UNION은 두 개의 SELECT 결과를 결합하여 중복된 행을 제거한 후 반환합니다. 반면, UNION ALL은 두 SELECT 결과를 결합하여 중복된 행을 포함한 모든 결과를 반환합니다.

> UNION을 사용한 쿼리의 예를 들어보세요.
- SELECT column_name FROM table1 UNION SELECT column_name FROM table2;
> UNION ALL을 사용하는 이유는 무엇인가요?
- 중복된 데이터를 포함한 전체 결과를 반환하려는 경우 사용합니다.
> UNION과 JOIN의 차이점은 무엇인가요?
- UNION은 두 개의 쿼리 결과를 수직으로 결합하는 반면, JOIN은 두 개의 테이블을 수평으로 결합합니다.

## EXISTS와 IN의 차이점은 무엇인가요?
> EXISTS
- 서브쿼리가 결과를 반환하는지 여부를 확인
- 서브쿼리가 하나 이상의 행을 반환하면 TRUE, 그렇지 않으면 FALSE 반환
- 메인 쿼리의 각 행에 대해 서브쿼리를 싱행하고, 조건을 만족하는 첫 번째 행을 찾으면 실행을 중단
- 서브쿼리가 결과를 반환할 수 있는지 여부만을 확인하므로, 서브쿼리 결과가 크더라도 비교적 효율적으로 작동
- 처리 순서 : 메인쿼리 -> 서브쿼리 
``` SQL
SELECT department_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.department_id);
```
> IN
- 서브쿼리가 반환한 결과 중 하나라도 메인 쿼리의 조건과 일치하는지 확인
- 서브쿼리에서 반환된 모든 값을 메모리에 로드한 후, 메인 쿼리의 각 행에 대해 서브쿼리 목록과 비교
- 반환하는 결과가 작은 경우에 효율적으로 작동
-  처리 순서 : 서브쿼리 -> 메인쿼리 
``` SQL
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1700);
```

> 어떤 상황에서 EXISTS를 사용하는 것이 IN보다 더 효율적인가요?
- 서브쿼리가 매우 큰 결과 집합을 반환하거나, 메인 쿼리와 서브쿼리의 테이블 간에 상관 관계가 있을 때 EXISTS를 사용하는 것이 더 효율적일 수 있습니다. EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 실행을 중지하기 때문에, 서브쿼리의 결과가 클 때 성능이 더 좋습니다. 또한, 서브쿼리가 인덱스된 열에 대해 실행될 때 EXISTS가 더 효율적으로 동작할 수 있습니다.
>  IN 연산자를 사용할 때 주의해야 할 점은 무엇인가요?
- IN 연산자를 사용할 때 주의해야 할 점은 서브쿼리가 반환하는 결과 목록이 너무 크지 않도록 하는 것입니다. 서브쿼리의 결과가 큰 경우 성능이 저하될 수 있습니다. 또한, IN 연산자 사용 시 NULL 값을 포함한 비교가 이루어질 때 결과가 예상과 다를 수 있으므로, NULL 처리에 유의해야 합니다. NULL 값이 포함된 경우, 비교 연산에서 불확실성을 초래할 수 있습니다.
  
## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
- 여러 행으로부터 하나의결과값을 반환하는 함수. 
> 종류 
- COUNT: 행의 개수를 반환
- SUM: 열의 합계를 반환
- AVG: 열의 평균값을 반환
- MIN: 열의 최소값을 반환
- MAX: 열의 최대값을 반환

> COUNT와 DISTINCT를 함께 사용하는 방법은 무엇인가요?
- SELECT COUNT(DISTINCT column_name) FROM table_name;
> 집계 함수에서 NULL 값은 어떻게 처리되나요?
- 대부분의 집계 함수는 NULL 값을 무시합니다. 그러나 COUNT(*)는 NULL 값을 포함합니다.
> 집계 함수를 GROUP BY와 함께 사용하는 예를 보여주세요.
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;


## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
- 하나 이상의 테이블을 기반으로 생성된 가상의 테이블
- 실제 데이터를 저장하지 않고 기본 테이블의 데이터를 조회할 수 있는 SQL 쿼리의 결과를 저장한 논리적 구조
- 복잡한 쿼리를 단순화하고, 특정 데이터를 쉽게 조회하거나 보안을 강화하기 위해 사용

> 장점
- 사용자가 접근할 수 있는 데이터를 제한하여 보안 강화
- 자주 사용하는 복잡한 쿼리를 뷰로 정의해 두면 간단한 SELECT 문으로 동일한 결과 반환 가능
- 특정 데이터를 표준화된 방식으로 제공함으로써 여러 사용자에게 일관된 데이터를 사용할 수 있게 함
- 동일한 뷰를 여러 쿼리에서 사용하므로 코드의 중복을 줄이고, 유지보수 쉽게 가능

> 단점
- 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 복잡한 뷰나 조인이 많은 뷰는 성능 저하를 초래할 수 있음
- 데이터의 삽입, 수정, 삭제하는것이 제한
- 기본 테이블의 구조가 변경되면 오류가 발생할 수 있어 유지보수 필요

> VIEW가 기본 테이블에서 데이터를 가져올 때 실시간으로 쿼리를 실행하는데, 이로 인해 어떤 문제점이 발생할 수 있나요?
- VIEW는 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 기본 테이블이 큰 경우 또는 VIEW가 복잡한 조인을 포함하는 경우 성능 문제가 발생할 수 있습니다. 특히, 여러 테이블을 조인하거나 중첩된 VIEW를 사용하는 경우 쿼리 실행 시간이 길어질 수 있으며, 전체 시스템 성능에 부정적인 영향을 미칠 수 있습니다.


## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- CASE문은 SQL에서 조건에 따라 다른 값을 반환할 수 있도록 하는 조건부 표현식
  
```` SQL
SELECT column_name,
       CASE
           WHEN 조건1 THEN 결과1
           WHEN 조건2 THEN 결과2
           ELSE 결과3
       END AS new_column_name
FROM table_name;
````

> CASE문을 사용하여 집계 데이터를 구분하는 예를 들어보세요.
- SELECT SUM(CASE WHEN column_name > 100 THEN 1 ELSE 0 END) FROM table_name;

> CASE 문을 사용해서 조건부로 데이터를 업데이트할 수 있나요?
```SQL
UPDATE employees
SET bonus = CASE
               WHEN salary > 100000 THEN salary * 0.1
               WHEN salary BETWEEN 50000 AND 100000 THEN salary * 0.05
               ELSE 0
           END;
```

# 인덱스
## 인덱스란 무엇인가요?
> 인덱스란?
- 데이터베이스에서 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조

> 인덱스 생성 컬럼을 where 조건으로 걸었을 경우의 동작 과정
1. 쿼리 작성 후 실행
2. 쿼리 옵티마이저(query optimizer)가 쿼리 처리 시작.
- 옵티마이저 : 가장 효율적인 방법으로 SQL을 수행할 최적의 쿼리실행 계획을 생성해주는 DBMS의 핵심 엔진 ( DBMS의 두뇌는 옵티마이저 )
- 옵티마이저는 쿼리에서 사용된 where 조건의 컬럼에 인덱스가 존재하는지 확인
- 테이블과 인덱스에 대한 통계를 참조하여, 인덱스를 사용하는것이 효율적인지 판단
- 옵티마이저는 여러 실행 계획에 대한 비용(리소스) 계산
3. 다양한 실행 계획을 평가한 옵티마이저는 인덱스를 사용하는것이 효율적이라고 판단되면, 인덱스를 사용하는 계획 선택
4. 인덱스를 사용한 데이터 검색
5. 데이터베이스는 조건을 만족하는 행을 찾은 후, 메모리에 로드하고, 데이터를 추출하여 사용자에게 반환

> 인덱스가 없는 경우에 데이터베이스는 데이터를 어떻게 검색하나요?
- 인덱스가 없는 경우에는 테이블의 모든 행을 순차적으로 스캔하여 조건에 맞는 데이터를 찾습니다. (FUll Scan) 대규모 데이터에서는 매우 비효율적일수 있음


## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?
> 클러스터드 인덱스
- 클러스터드 인덱스는 테이블의 실제 데이터가 인덱스 키 값에 따라 정렬된 상태로 저장
- 테이블의 행들이 인덱스 순서대로 물리적으로 정렬
- 1개 테이블에는 1개의 클러스터드 인덱스만 생성 가능
  - 장점
     + 데이터가 물리적으로 정렬되어 있어 범위 검색에 효율 좋음
  - 단점
     +  데이터 삽입, 삭제, 업데이트 경우 데이터의 물리적 위치를 변경해야 하므로 오버헤드 발생

> 넌클러스터드 인덱스 
- 넌클러스터드 인덱스는 테이블과는 별도로 저장
- 인덱스에는 인덱스 키와 해당 키에 대응하는 데이터의 위치가 저장
- 1개의 테이블에는 여러개의 넌클러스터드 인덱스 생성 가능
  - 장점
      + 특정 열, 열의 조합에 대한 검색 성능 향상
      + 여러개의 인덱스 생성 가능
  - 단점
      + 테이블의 데이터와 별도로 저장되므로 추가적인 저장 공간 필요
      + 데이터의 실제 위치를 가리키는 포인터를 사용하므로 클러스터드 인덱스에 비해 검색 성능이 떨어질수 있음 

> 클러스터드 인덱스와 넌클러스터드 인덱스 선택 기준은?
- 예 ) ORDERS 테이블 : orderId, customerId, orderDate, totalAmount
- orderDate 컬럼에 각 인덱스를 생성해주었을 경우, 둘다 특정 상황에서 빠를수 있다.
- 즉, 쿼리 패턴과 요구사항 패턴에 따라서 클러스터디 인덱스와 넌클러스터드 인덱스를 선택해야함
- 클러스터드 인덱스가 좋은 경우 : 클러스터드 인덱스는 범위 내의 모든 데이터를 물리적으로 연속된 블록에서 읽으므로 맑은 양의 데이터를 조회할때 유리. 그러므로 orderDate에 대한 검색이 빈번하고, 다른 컬럼의 검색의 패턴이 적을때 사용 
- 넌클러스터드 인덱스가 좋은 경우 : 여러 컬럼과의 검색 패턴이 많다면 넌클러스터드 인덱스 생성이 좋을 수 있다. 

## 인덱스를 언제 사용하는 것이 적합한가요?
- 데이터가 많아지면서 데이터 검색에 시간이 오래 걸리는 경우
- where, join, order by, group by 절에서 자주 사용되는 컬럼에 대해 인덱스 설정시 성능 향상

> 인덱스가 불필요한 경우는 ?
- 테이블에 데이터가 적거나, select가 빈번하게 발생하지 않는 경우
  
## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?
- 테이블 조회, 정렬 성능은 향상 시킬수 있지만, 데이터 삽입, 수정, 삭제 시에는 인덱스를 갱신해야하므로 성능이 저하될수 있음

## 인덱스의 구조는 무엇인가요? (예: B-Tree)
> B-Tree
- 균형 트리 구조
- 데이터가 정렬된 상태로 저장
- 검색, 삽입, 삭제 작업이 모두 효율적이고, 범위 검색이나 순차적 접근이 필요한 경우 적합
> B+Tree
- B-Tree 변형으로 리프 노드만이 실제 데이터를 포함
- 리프 노드들이 연결리스트로 연결되어 있어 범위 검색이 더 효율적
- 대부분 관계형 데이터베이스에서 기본 인덱스 구조로 사용
> Hash 인덱스
- 해시 함수를 사용하여 키 값을 계산하고, 해당 위치에 데이터를 저장하거나 검색
- 특정 값 검색에는 유리하지만, 범위 검색에는 적합하지 않음
> Bitmap 인덱스
- 각 열의 값을 비트맵으로 표현하여 저장
- 특정 컬럼에 다양한 값이 많지 않고 데이터 중복이 많은 경우에 적합
- OLAP (Online Analytical Processing) 시스템에서 대량의 데이터에 대한 복합 조건 처리시에 자주 사용
> GiST (Generalized Search Tree) 인덱스
-  다양한 데이터 유형( 공간 데이터, 텍스트 데이터 )을 검색하기 위해 설계된 범용 트리 구조
-  복잡한 검색 조건에 적합
-  PostgreSQL 에서 많이 사용 
> GIN (Generalized Inverted Index)
- 주로 텍스트 검색과 같이 각 값이 여러 요소로 구성된 데이터에 대한 검색을 최적화하는 인덱스 구조
- 문서 검색에서 특정 단어를 빠르게 찾기 위해 사용
- 비정형 데이터, 배열 데이터에 대한 검색시 사용
> R-Tree
- 공간 데이터(GIS)에서 사용하는 구조
- 2차원 이상의 데이터에 최적화
- 데이터의 공간적 관계를 트리 구조로 표현, 범위 질의나 like 검색에 효율적 
> Full-Text 인덱스
- 텍스트 데이터에서 단어나 구문을 검색하기 위해 설계된 인덱스
- 대량의 텍스트 데이터를 다루는 애플리케이션에서 많이 사용 
> Suffix Tree/Array
- 문자열 검색에 특화된 인덱스 구조
- 특정 패턴이 문자열에서 어디에 있는지에 대한 검색에 효율적
- DNA서열 분석, 텍스트 편집기에 사용
> Trie 인덱스
- 문자열의 공통 접두사를 이용해 데이터를 정리하는 트리 구조
- 사전식 문자열 검색, 자동 완성 기능을 구현하는데 적합
> Inverted 인덱스
- 문서에서 단어와 같은 요소들이 어느 위치에 나타나는지 매핑하여 저장하는 구조
- 덱스트 검색 엔진에서 주로 사용

> B-Tree vs B+Tree
1. 검색 방법 : 데이터를 검색할 때 항상 리프 노드까지 이동하므로 검색 경로가 단순
- B-Tree : 모든 노드(internal node + leaf node)에 키와 값이 함께 저장
- B+Tree : internal 노드에는 키만 저장, leaf 노드에는 키와 값 저장

2. 포인터 사용 
- B-Tree : internal노드의 포인터를 통해서만 리프 노드로 이동 가능
- B+Tree : leaf 노드끼리 서로 연결 리스트로 연결되어있음

3. 범위 쿼리와 범위 검색
- B-Tree : 범위 쿼리를 수행하려면 트리의 루트에서부터 리프 노드 까지 이동하면서 전체 데이터 함께 조회
- B+Tree : 데이터는 리프 노드에만 존재하므로, 범위 쿼리는 리프 노드를 시작으로 연결된 리스트를 따라가면 모든 데이터 조회 가능
4. 순차 탐색 및 정렬
- B-Tree: 순차적인 탐색이나 정렬을 위한 추가적인 알고리즘이 필요해서 (예. inorder traversal) B+Tree보다 더 복잡
- B+Tree: 연결된 리스트를 따라가면서 순차 탐색이 용이하며, 키들은 항상 정렬된 상태를 유지하면서 저장
5. 메모리 사용
- B-Tree: 리프 노드와 내부 노드가 각각 데이터와 포인터까지 가지고 있기 때문에 B+Tree보다 더 많은 메모리 공간을 차지
- B+Tree: 데이터는 리프 노드에만 저장되고, internal 노드는 키만 갖고 있으면 되므로, 메모리 효율이 좋음

https://engineerinsight.tistory.com/336#%E2%9C%94%EF%B8%8F%C2%A0B-Tree%20vs%20B%2BTree-1

## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?
- 테이블에 로우를 추가했을때, 해당 테이블에 설정되어 있는 인덱스의 기준에 맞춰 정렬 작업이 필요한데, 여러개의 인덱스가 존재할 경우 생성된 인덱스 만큼의 B-Tree 구조에 데이터가 추가되며, 트리 구조의 재배치 작업이 발생하게 되므로 성능적으로 영향을 줄 수 있음
- 인덱스도 생성시에 인덱스 테이블을 생성하므로 너무 많은 인덱스 생성시 그만큼의 메모리를 차지하게됨
- 데이터 수정 작업시 오버헤드가 증가하고, 옵티마이저가 잘못된 실행계획을 선택할 수 있음
  
## Composite Index(복합 인덱스)란 무엇인가요?
- 2개 이상의 컬럼을 결합하여 만든 인덱스

> 복합 인덱스를 사용하는 이유는?
- 특정 쿼리에서 2개 이상의 컬럼이 결합되어 자주 사용될때 복합 인덱스로 사용하면 유리
  
## 인덱스 설계 시 주의해야 할 점은 무엇인가요?
- 프로세스나 요구사항에 따른 패턴을 분석하여 자주 사용되는 컬럼을 파악
- 중복되지 않은 값이 많은 컬럼
- 조건절에서 자주 사용되는 컬럼 순
- 데이터의 변경 빈도가 낮은 컬럼
  
## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?
> index rebuild
- 기존 인덱스를 삭제하고 새로운 인덱스를 만들어 데이터를 정렬
- 리소스를 많이 사용하며, 작업 도중에 테이블에 대한 lock이 발생할 수 있음
- 인덱스 단편화가 심한 경우에 사용하는 것이 좋음 
> index reorganize
- 기존 인덱스를 유지하면서 페이지를 정렬하고 공간을 재활용
- 리소스 사용이 상대적으로 적으며, 데이터베이스 성능에 큰 영향을 주진 않음
- 인덱스 단편화가 비교적 적은 경우에 사용하는 것이 좋음

> rebuild, reorganize를 사용하는 이유
- 데이터베이스 인덱스는 데이터의 삽입, 삭제, 수정으로 인해 단편화(Fragmentation)이 발생할 수 있음. 단편화가 발생하면 인덱스의 성능이 저하될수 있으므로 rebuild, reorganize 작업을 수행
- 단편화 : 데이터 페이지가 비효율적으로 사용되며, 인덱스 검색 시 추가적인 I/O가 발생하는 상황


## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?
> 정의 
- 힌트는 쿼리에서 특정 인덱스를 강제로 사용하도록 지정하는 방법
> 사용하는 경우
- 옵티마이저가 쿼리의 실행계획을 생성할 때 잘못된 인덱스를 선택할때
- 대규모 데이터를 가진 테이블에서 full scan이 발생하는 것을 방지할때

# 트랜잭션 및 동시성 제어

## 트랜잭션의 고립 수준(Isolation Level)에 대해 설명해주세요.
https://tlatmsrud.tistory.com/118
> 정의
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 격리되어 있는가에 대한 수준
- DBMS 마다 격리 수준에 대한 내용은 다를 수 있음
  
> 4가지 Isolation level ( 격리 수준이 낮은순 -> 격리 수준이 높은순 ) 
1. Read UnCommitted
- 트랜잭션에서의 변경 내용이 commit, rollback 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있음
- 정합성에 문제가 많은 격리 수준이므로 일반적으로 사용하지 않음
- Dirty Read 발생 : 커밋되지 않은 트랜잭션에 접근하여 부정합을 일으킬 수 있는 데이터를 읽는 것
  
2. Read Committed
- 다른 트랜잭션에서 commit 된 데이터만 접근 할 수 있게 하는 격리 수준
- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
- Dirty Read 같은 현상은 발생하지 않지만, Non-Repeatable read 발생
- Non-Repeatable read : 하나의 트랜잭션 내에서 동일한 select 쿼리 실행했을때, 항상 같은 결과를 보장해야하는 Repeatable read 정합성에 어긋나는것
- 예) 1번 트랜잭션과 2번트랜잭션이 있을 경우, 1번 트랜잭션에서 '바나나' 데이터를 '바나'로 update 이후에 커밋을 하기 전 시점에서 2번 트랜잭션이 '바나나'라는 데이터를 조회시에는 1번 트랜잭션이 update 하기 전 데이터인 '바나나'가 조회된다. Dirty read는 발생하지않는다. 원리는 무엇인가?
  + 2번 트랜잭션이 트랜잭션에 대한 로그 중 하나인 Undo영역에 있는 데이터를 읽어오기 때문.
  + Undo 영역 : 변경 전 데이터가 저장된 영역
  
3. Repeatable read
- Non Repeatable Read 문제를 해결하는 격리 수준으로 커밋된 데이터만 읽을 수 있되 자신보다 낮은 트랜잭션 번호를 갖는 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준
- MySQL, MariaDB 에서 기본으로 사용하는 격리 수준

4. Serializable
- 가장 고수준의 격리 수준으로 트랜잭션을 무조건 순차적으로 진행
- 트랜잭션이 중간에 끼어들수 없어서 데이터의 부정합은 발생하지 않지만, 동시 처리가 불가능하여 처리 속도가 느려짐

> 드랜잭션 격리 수준이 성능에 미치는 영향은?
- 격리 수준이 높아질수록 데이터 무결성은 높아지지만, 처리 서능은 저하 될 수 있음

## Dirty Read, Non-repeatable Read, Phantom Read에 대해 설명해주세요.
>  Dirty Read
- commit 되지 않은 데이터를 다른 트랜잭션에서 select 했을때 발생하는 현상
- 2번 트랜잭션에서 아직 실행이 끝나지 않은 1번 트랜잭션에 의한 변경사항을 보게 되는 경우
- Read Uncommitted 수준일때 발생
>  Non-repeatable Read
- 1번 트랜잭션에서 같은 쿼리를 2번 실행할 때 그 사이에 2번 트랜잭션이 값을 update, delete 하면서 1번이 실행한 2개의 쿼리의 결과의 일관성이 깨진 현상
- Read Committed, Read Uncommitted 수준일 때 발생
>  Phantom Read
- 한 트랜잭션 안에서 일정 범위의 레코드를 2번 이상 select 했을때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에 나타나는 현상
- 트랜잭션 도중 새로운 레코드 insert를 허용하기 때문에 나타나는 현상
- Read Committed, Read Uncommitted, Repeatable read 수준일 때 발생

> 트랜잭션 격리 수준에서 insert 쿼리를 막지 않는 이유는?
- 트랜잭션의 격리 수준은 주로 트랜잭션 간의 select 에서 발생하는 데이터의 일관성을 보장하는데 중점을 가짐 
- insert를 아예 막는다면, 시스템의 유연성이 저하되고, 트랜잭션이 차단되어 성능 문제가 발생 할 수 있음
- 데이터베이스의 동시성을 최대한 유지하기 위해, 격리 수준을 조절하여, Phantom read 와 같은 문제를 해결하거나 완화하는 방법을 사용

## 트랜잭션의 전파(Propagation)에 대해 설명해주세요.
> 정의
- 하나의 트랜잭션이 다른 트랜잭션과 어떤 기준을 가지고 실행할지를 정의하는 방식
> 옵션
1. REQUIRED
- 현재 트랜잭션이 있으면 이를 사용하고, 없으면 새로운 트랜잭션 실행
2. REQUIRES_NEW
- 트랜잭션의 존재 여부와 관계없이 무조건 새로운 트랜잭션을 생성
- 기존 트랜잭션이 존재한다면, 기존 트랜잭션을 보류하고, 새로운 트랜잭션 생성
- 서로 각각의 디비 커넥션을 가짐. 롤백시 서로의 트랜잭션에 영향을 주지 않음
- 서로 독립적이지만, 동시에 실행되지않는 이유는 데이터의 일관성과 관리의 복잡성을 줄이기 위함
- 사용 사례 : 로그 기록을 위해 REQUIRES_NEW 사용하는 경우
3. NESTED
- 기존 트랜잭션이 없으면 새로운 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 중첩 트랜잭션을 생성
- 중첩 트랜잭션으로, 부모와 자식의 개념이 있으며 커밋시점은 부모 트랜잭션이 완료될때이고, 부모 트랜잭션에서 롤백이 발생하면 자식 트랜잭션에서도 롤백이 발생
4. MANDATORY
- 반드시 기존 트랜잭션 내에서 실행되어야 하며, 트랜잭션이 없으면 IllegalTransactionStateException 예외 발생
5. SUPPORTS
- 트랜잭션이 있으면, 트랜잭션 내에서 실행되고, 없으면 트랜잭션 없이 실행
6. NOT_SUPPORTED
- 트랜잭션이 존재하면 이를 일시 중단하고, 트랜잭션 없이 실행
7. NEVER
- 어떤 경우에도 트랜잭션을 생성하지 않음


## 낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?
> 낙관적 잠금(Optimistic Locking)
- 자원에 lock을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리하자는 방법론
- 여러 트랜잭션이 동일한 데이터에 업데이트를 시도할 수 있고, 커밋할 때 유효성 검사
- 데이터베이스 단에서 동시성 처리하는 것이 아닌, Application 레벨에서 개발자가 롤백 처리
- 동시 레코드 업데이트 빈도가 적거나, lock 오버헤드가 높은 것으로 예상될때 사용 

> 비관적 잠금(Pessimistic Locking)
- 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법
- 데이터에 대한 동시 업데이트 방지
- 데이터베이스 레벨에서 동작, SQL 쿼리에서 SELECT FOR UPDATE 구문 또는 LOCK 구문을 통해 구현
- 강력한 동시성 제어를 제공하지만, LOCK이 길어질 경우 성능 저하와 교착 상태 발생 가능성 있음


## 트랜잭션에서 발생할 수 있는 동시성 문제에는 어떤 것들이 있나요?
> Dirty read
- 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 상황
> Non-repeatable read
- 동일한 트랜잭션 내에서 같은 데이터를 2번 읽었을때, 다른 트랜잭션이 중간에 데이터를 수정, 삭제하여 select 결과가 다르게 나타나는 상황
> Phantom read
- 트랜잭션이 동일한 쿼리를 여러번 실행할때, 다른 트랙잭션이 중간에 새로운 로우를 삽입, 삭제했을 경우 결과 로우 수가 달라지는 현상 
> Lost update
- 2개의 트랜잭션이 동일한 데이터를 동시에 수정할때, 한 트랙잭션의 수정 내용이 다른 트랜잭션에 의해 수정 내용이 사라지는 현상
> Write Skew (쓰기 편향)
- 두개의 트랜잭션이 서로 다른 데이터를 읽고, 그 데이터를 기반으로 조건에 맞게 데이터를 수정할때 발생하는 문제. 


## Deadlock이란 무엇이며, 이를 방지하는 방법은 무엇인가요?
> 정의
- 두개 이상의 트랜잭션이 서로가 필요로 하는 자원을 점유하고 있어, 각각의 트랜잭션이 자원의 해제를 기다리며 무한 대기 상태로 빠지는 상황

> 방지 방법
1. 예방 기법
- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 lock 한다 -> 병행성이 떨어짐
- lock_timeout을 통해 일정 시간이 지나면 lock을 해제 -> 근복적인 해결책은 아님
2. 회피 기법
- 자원을 할달할 때 time stamp를 활용해서 교착상태가 일어나지 않도록 회피하는 방법
- wait-die 방식
  + 트랜잭션 A가 트랜잭션 B에 의해 lock된 자원을 요청할 때 트랜잭션 A가 먼저 들어온 트랜잭션이라면 A는 대기(wait)
  + 트랜잭션 A가 나중에 들어온 트랜잭션이라면 중단(die)하고 나중에 다시 요청
- wound-wait 방식
  + 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 자원을 선점(wound)
  + 트랜잭션 A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(wait)
- 시나리오 예시
``` 
트랜잭션 A는 10초에 시작되었습니다. (타임스탬프 = 10)
트랜잭션 B는 20초에 시작되었습니다. (타임스탬프 = 20)
트랜잭션 A와 트랜잭션 B는 각각 자원 X와 자원 Y에 접근하려고 합니다. 초기에는 자원 X와 자원 Y는 모두 사용 중이지 않다고 가정합니다.

상황: 트랜잭션 A가 자원 X를 점유하고, 트랜잭션 B가 자원 Y를 점유한 상태에서 서로 상대방의 자원을 요청할 때 발생하는 상황

1. Wait-Die 방식
10초: 트랜잭션 A가 시작되어 자원 X를 점유합니다. (타임스탬프 A = 10)
20초: 트랜잭션 B가 시작되어 자원 Y를 점유합니다. (타임스탬프 B = 20)

이제 트랜잭션 A는 자원 Y를, 트랜잭션 B는 자원 X를 필요로 하게 됩니다.

트랜잭션 A가 자원 Y를 요청:

트랜잭션 A는 타임스탬프가 10이고, 자원 Y를 이미 점유한 트랜잭션 B의 타임스탬프는 20입니다.
트랜잭션 A의 타임스탬프가 더 작으므로, 트랜잭션 A는 **대기(wait)**하게 됩니다.
트랜잭션 B가 자원 X를 요청:

트랜잭션 B의 타임스탬프는 20이고, 자원 X를 이미 점유한 트랜잭션 A의 타임스탬프는 10입니다.
트랜잭션 B의 타임스탬프가 더 크므로, 트랜잭션 B는 **중단(die)**됩니다. 트랜잭션 B는 롤백되고 나중에 다시 시도할 수 있습니다.
결과: 트랜잭션 A는 대기 상태로 유지되며, 트랜잭션 B는 중단됩니다. 나중에 트랜잭션 A가 완료되면 트랜잭션 B가 다시 실행됩니다.

2. Wound-Wait 방식
10초: 트랜잭션 A가 시작되어 자원 X를 점유합니다. (타임스탬프 A = 10)
20초: 트랜잭션 B가 시작되어 자원 Y를 점유합니다. (타임스탬프 B = 20)

트랜잭션 A는 자원 Y를, 트랜잭션 B는 자원 X를 필요로 하게 됩니다.

트랜잭션 A가 자원 Y를 요청:

트랜잭션 A는 타임스탬프가 10이고, 자원 Y를 점유한 트랜잭션 B의 타임스탬프는 20입니다.
트랜잭션 A의 타임스탬프가 더 작으므로, 트랜잭션 A는 트랜잭션 B를 **중단(wound)**시키고 자원 Y를 획득합니다.
트랜잭션 B는 롤백되고, 나중에 다시 시도할 수 있습니다.
트랜잭션 B가 자원 X를 요청:

트랜잭션 B의 타임스탬프는 20이고, 자원 X를 점유한 트랜잭션 A의 타임스탬프는 10입니다.
트랜잭션 B의 타임스탬프가 더 크므로, 트랜잭션 B는 **대기(wait)**합니다.
결과: 트랜잭션 A는 트랜잭션 B를 중단시키고 자원 Y를 획득합니다. 트랜잭션 B는 나중에 다시 시도할 수 있습니다.

```
3. 낙관적 병행 제어 기법
- 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백하는 방법

4. 교착상태 빈도 줄이기
-  자원 할당 순서 지정
-  자원 요청과 해제의 순서를 일관되게 유지
-  트랜잭션이 처리하는 작업의 범위를 작게 유지

## 트랜잭션 로그(Transaction Log)란 무엇인가요?
- 데이터 베이스 시스템에서 트랜잭션의 모든 변경 사항을 기록하는 파일
- 데이터베이스의 복구 및 일관성을 유지하는데 중요
- 데이터베이스에 대한 변경 사항이 커밋되기 전에 로그 파일에 먼저 기록되며, 시스템 장애시 로그를 이용해 복구 가능
- 저장되는 정보 : 트랜잭션 id, 타임스탬프, 변경된 데이터의 위치

## 데이터베이스 커밋과 롤백의 차이점은 무엇인가요?
> Commit
- 트랜잭션에서 수행된 모든 변경 사항을 영구적으로 데이터베이스에 반영하는 작업
> Rollback
- 트랜잭션에서 수행된 모든 변경사항을 취소하고, 트랜잭션이 실행되기 전 상태로 되돌리는 작업

## 트랜잭션 타임아웃이란 무엇인가요?
- 트랜잭션이 일정 시간내에 완료되지 않으면, 자동으로 롤백되도록 설정된 시간 제한
- 교착상태나 무한 대기 상태를 방지하기 위해 사용

## 분산 트랜잭션이란 무엇이며, 이를 관리하는 방법은 무엇인가요?
> 분산 트랜잭션
- 하나의 트랜잭션이 여러 시스템(데이터베이스)에 걸쳐서 수행되는 경우
- 트랙잭션의 일관성과 원자성을 유지하기 위해 트랜잭션 코디네이터가 모든 자원 관리자를 조율

> 관리하는 방법 
1. Two-Phase Commit (2PC) 프로토콜
- 트랜잭션 코디네이터가 모든 자원 관리자와 협력하여 트랜잭션의 원자성 보장
- 2가지 주요 단계(Prepare 단계, 커밋/롤백 단계)를 통해 분산 트랜잭션 조율
- 네트워크 지연 또는 자원 관리자의 응답 지연으로 인해 트랜잭션이 오랜시간 대기할 수 있음
2. XA 트랜잭션
- 여러 자원 관리자가 하나의 트랜잭션에서 원자성을 유지할 수 있도록 지원
- XA 트랜잭션은 대부분 상용 데이터 베이스 시스템에서 지원되며, 2PC프로토콜 기반으로 동작
- 트랜잭션 관리자와 자원 관리자의 상호작용이 복잡해지고, 네트워크 오버헤드가 발생할 수 있음
3. Saga 패턴
- Choreography 방식
  + 각 서비스가 독립적으로 이벤트를 처리하며, 중앙 관리자가 없으므로 유연하지만 관리가 어려움
- Orchestration 방식
  + 중앙 관리자가 트랜잭션의 흐름을 제어하며, 복잡한 트랜잭션을 쉽게 관리할 수 있지만, 시스템 복잡도가 높음
  
> Two-Phase Commit (2PC) 프로토콜, XA 트랜잭션 의 차이점
- 둘다 분산 트랜잭션에서 여러 자원 관리자를 조욜하여 트랜잭션의 원자성을 보장하는데 사용되지만, 적용하는 범위와 구체적인 구현에 차이점 존재
- 2PC 프로토콜은 모든 자원이 준비되면 커밋하고, 하나라도 안되면 롤백하라는 규치이고, XA 트랜잭션은 2PC 프로토콜을 포함하여 여러 자원 관리자들이 서로 협력하여 트랜잭션을 처리할 수 있게 만드는 시스템
--> 이거 다시 이해하기!

## 커버링 인덱스(Covering Index)란? 
- 인덱스가 쿼리에서 필요한 모든 컬럼을 포함하고 있어서 데이터 페이지로 추가적인 접근 없이 인덱스만으로 쿼리 결과를 처리할 수 있는 경우.
- I/O 작업을 줄이고 쿼리 성능을 향상 시킬수 있음

## 카디널리티가 높은것과 낮은것의 차이는? 
> 카디널리티(Cardinality)
- 데이터베이스에서 특정 컬럼에 저장된 데이터의 고유 값의 수를 나타내는 용어 
> 카디널리티가 높은 경우
- 특정 컬럼에 저징된 데이터의 값이 다양하고, 고유값이 많은 경우
- 예) 테이블의 ID값, 주민번호 등
- 카디널리티가 높은 컬럼은 인덱스 효율이 높을 수 있고, 검색 시에 특정 값을 빠르게 찾을 수 있음
> 카디널리티가 낮은 경우
- 특정 컬럼에 저장된 값이 제한적이고, 중복된 값들이 많은 경우
- 예) 성별, 부서
- 카디널리티가 낮은 컬럼을 인덱스로 사용하면 오히려 성능 저하를 일으킬 수 있음 

## 복합인덱스와 단일 인덱스로 인덱스가 생성되어 있는 컬럼을 where 절에 동시에 실행시 어떤게 성능이 더 빠른가? 

## join이 걸린 컬럼에는 왜 인덱스를 걸어줘야하는가? 
## 인덱스에서 페이지와 노드란? 

## 인덱스 구조는 db 종류마다 다른가? 그리고 인덱스 구조는 인덱스 종류에 따라서 어떻게 지정되는건가요? 


# 성능 최적화 및 쿼리 튜닝 ( 9월 14일) 

## 쿼리 튜닝(Query Tuning)이란 무엇인가요?
> 쿼리 튜닝이란?
- 데이터베이스 성능을 최적화하기 위해 SQL 쿼리를 분석하고 최적화 하는 과정으로 쿼리의 실행시간을 줄이고, 리소스 사용을 최소화하며, 시스템의 전반적인 응답 속도를 개선하는 과정.

> 쿼리 튜닝의 방법
- 인덱스 최적화, 쿼리 구조 개선, 조인 최적화, 쿼리 캐싱, 파티셔닝, 실행 계획 분석 등이 존재 

## 쿼리 실행 계획(Execution Plan)이란 무엇이며, 이를 분석하는 방법을 설명해주세요.
https://harris91.vercel.app/query-plan

> 쿼리 실행 계획
- 쿼리가 실행될 때 데이터베이스가 어떤 방식으로 데이터를 검색하고 처리할지에 대한 정보와 함께, 데이터베이스 옵티마이저가 선택한 가장 효율적인 실행 경로를 제공
- 조인의 순서, 사용된 인덱스, 테이블 스캔 여부 등의 정보를 포함
- 데이터베이스 종류 마다 실행계획 항목이 다를 수 있음

``` SQL
-- 실행계획 수집
EXPLAIN PLAN FOR 
SELECT first_name, last_name 
FROM employees 
WHERE department_id = 10 
AND salary > 5000;
-- 실행계획 조회 
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

------------------------------------------------------------------------------------
| Id  | Operation                    | Name                  | Rows  | Bytes | Cost |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                       |   10  |   260 |   5  |
|   1 |  TABLE ACCESS BY INDEX ROWID | EMPLOYEES             |   10  |   260 |   5  |
|*  2 |   INDEX RANGE SCAN           | IDX_EMP_DEPT_SALARY   |   10  |       |   3  |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
2 - access("DEPARTMENT_ID"=10 AND "SALARY">5000)

```

> 실행 계획 항목
1. id
- 쿼리의 각 단계를 식별하는 고유한 번호
- 쿼리의 실행 순서 파악할 수 있음
- 같은 값이면, 순서가 상관없이 병렬로 실행될수 있는 작업을 의미
2. Operation
- 데이터베이스가 쿼리를 처리하기 위해 수행하는 작업 유형
- 작업 유형이 효율적인지, 인덱스가 제대로 사용되고 있는지 확인
- 항목 예시 
  + TABLE ACCESS FULL: 테이블 전체를 스캔.
  + INDEX RANGE SCAN: 인덱스 범위를 지정하여 데이터에 접근.
  + INDEX FULL SCAN: 인덱스의 모든 항목을 스캔.
  + INDEX UNIQUE SCAN: 유니크 인덱스를 사용하여 단일 행을 반환.
  + SORT ORDER BY: ORDER BY 절에 따라 데이터를 정렬
  + NESTED LOOPS: 하나의 테이블에서 데이터를 읽고, 그 데이터를 다른 테이블과 비교하는 반복 작업 (Nested Loops Join)
  + HASH JOIN : 대규모 데이터셋에서 두 테이블을 해시 테이블로 변환하여 효율적으로 조인. 정렬이나 인덱스 필요하지않음
  + MERGE JOIN : 두 테이블이 정렬된 상태에서 병합하여 조인.
3. Name
- 테이블 , 인덱스 이름
4. Rows
- 각 단계에서 처리될 것으로 예상되는 행의 수
- 행의 수가 많은 경우 성능 병목 지점이 될수 있으므로 최적화 필요
5. Cost
- 각 작업의 상대적인 비용 , DBMS가 계산한 결
- 비용이 높은 작업을 식별해서 최적화 해야함
6. Predicate Information
- WHERE 절과 같은 필터 조건이 어떻게 적용되는지 나타내는 항목
- 항목 예시
    + FILTER: 인덱스를 사용하지 않고, 테이블의 모든 행을 스캔한 후 조건에 맞는 데이터를 필터링할 때 사용
    + ACCESS : 인덱스를 사용해 조건을 만족하는 데이터를 검색할 때 사용
- ex) 2 - access("DEPARTMENT_ID"=10 AND "SALARY">5000)
    + 2 : 실행계획의 id에 해당하는 작업 ( INDEX RANGE SCAN )
    + access : 이 작업이 인덱스에 접근할 때 사용하는 조건

> 분석 방법 ( oracle )
1. 전체 구조 이해
- 실행 계획읜 순서 파악 (id 값)
2. 비효율적인 작업 식별
- Operation 항목을 통해 TABLE ACCESS FULL과 같은 비효율적인 작업이 발생하는지 확인
3. 인덱스 사용 여부 확인
- OPERATION 항목에서 INDEX RANGE SCAN, INDEX UNIQUE SCAN과 같은 작업이 발생하는지 확인
4. 비용 분석
- COST 항목을 분석하여, 비용이 높은 작업을 우선으로 최적화 진행
5. 카디널리티 및 필터링 정보 확인
- Rows 항목에서 예상 처리 행 수 확인
- Predicate Information에서 필터링 조건이 제대로 작동하는지 확인
6. 필요한 부분 최적화 진행

> 실행계획에서 볼 수 있는 JOIN 방식 3가지는 무엇인가요?
https://memories95.tistory.com/178

1. Nested Loop Join
- 한 테이블의 Row를 읽고 다른 테이블에서 조인 조건에 해당되는 행들을 찾아가는 방식
2. Sort Merge Join
- 각각의 테이블을 검색 조건에 의하여 정렬한 후 조인 조건에 의하여 값을 조인하는 방식
3. Hash Join
- 각각의 테이블을 Full 검색하여 해시 테이블에 저장한 후 값을 비교하여 조인

> 옵티마이저는 저런 JOIN 방식을 어떤 기준으로 정하는건가요?
1. 데이터 규모, 상태
- 적은 데이터 : NESTED LOOPS 선호. 인덱스를 사용해서 한 로우씩 처리하는 방식이 효율적일때 사용
- 큰 데이터 : HASH JOIN 선호. 해시 테이블로 변환해 대량의 데이터를 처리(해시 테이블로 변환시에 리소스가 소모되긴하지만, 전체 테이블을 순차적으로 비교하는 대신 해시 함수를 사용해서 데이터 찾는게 더 효율적) 
- 정렬된 데이터 : MERGE JOIN 선호. 두 테이블이 정렬된 상태일때, 두 테이블을 병합하여 조인
2. 인덱스 사용 가능성
- 인덱스가 유용한 경우 : NESTED LOOPS
- 인덱스가 필요없는 경우 : HASH JOIN

> 옵티마이저는 어떻게 인덱스 사용이 효율적인지 판단하는건가요?
- 통계 정보 : 카디널리티, 데이터 분포 등을 판단
- WHERE, JOIN 조건이 인덱스를 통해 효율적으로 처리될 수 있는지 분석
- 인덱스 사용 여부에 따른 예상 비용을 비교
- 현재 사용되는 옵티마이저는 비용 기반 옵티마이저로 위와 같은 절차를 빠르게 결정함

## 인덱스 스캔(Index Scan)과 테이블 스캔(Table Scan)의 차이점은 무엇인가요?
> 인덱스 스캔
- 인덱스를 구성하는 컬럼의 값을 기반으로 데이터를 추출
> 테이블 스캔 
- 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞는 결과 추출

## 데이터베이스에서 Partitioning이란 무엇인가요?
> 파디셔닝 이란?
- 큰 테이블이나 인덱스를 작은 Partition 단위로 나누어 관리하는 기법
- 데이터베이스의 튜닝 기법으로 대규모 데이터의 관리 용이성, 성능 향상을 위해 진행함
- 분할 키(partition key) : 데이터를 파티션으로 나누기 위해 사용하는 기준이 되는 컬럼
> 장점 , 단점
- 장점
  + 쿼리 실행시 전체 테이블이 아닌 관련 파티션에 대해서만 작업을 수행하므로 쿼리 성능 향상
  + 특정 파티션에 대한 백업, 복구, 유지보수 가능
  + 파티션 간의 독립성으로 장애 발생 시 특정 파티션만 영향 받을 수 있음
- 단점
  + 데이터 모델이 복잡해지고, 파티셔닝 설계를 잘 짜야함
  + 잘못된 파티셔닝은 특정 쿼리에서 모든 파티션을 검색하게 되는 경우 성능 저하 발생
  + 테이블과 인텍스를 같이 파티셔닝 해야하므로 더 많은 디스크 공간이 필요
> 종류
- 수평 파티셔닝 (Horizontal Partitioning)
  + 하나의 테이블의 각 행을 다른 테이블에 분산시키는 방식
  + 데이터의 개수를 기준으로 나누어 파티셔닝
  + 데이터, 인덱스의 개수가 줄어들어 성능 향상
  + 데이터를 찾는 과정이 복잡해짐(Latency 증가)
- 수직 파티셔닝 (Vertical Partitioning)
  + 테이블의 일부 열을 빼내는 형태로 분할 . 컬럼을 기준으로 나눔
  + 자주 사용되는 컬럼을 분리하여 성능 향상 가능
  + 같은 타입의 데이터가 저장되어 데이터 압축률 높일 수 있음
  + 조회시 필요없는 컬럼을 조회하지 않아도 됨
  + 데이터를 찾는 과정이 복잡해짐(Latency 증가)
> 분할 키 기준 분할 기법 (범위, 목록, 해시, 합성)
- 범위 분할 (range partitioning)
  + 연속적인 숫자나 날짜를 기준으로 파티셔닝
  + 분할 키 값이 범위 내에 있는지 여부로 구분 
- 목록 분할 (list partitioning)
  + 특정 값의 목록을 기준으로 데이터 분할
- 해시 분할 (hash partitioning)
  + 해시 함수를 사용해 데이터를 고르게 분산
  + 데이터 관리 보다는 성능 향상 목적
- 합성 분할 (composite partitioning)
  + 두 개 이상의 파티셔닝 기법을 결합하여 사용 

## Sharding이란 무엇이며, 언제 사용하나요?
> 샤딩이란?
- 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 기법

> 사용 이유
- 하나의 데이터베이스로 처리할 수 없는 대규모 데이터인 경우
- 대규모 데이터로 인해 성능이 저하됐을 경우

## 데이터베이스의 캐싱 전략에는 어떤 것들이 있나요?


## 풀 테이블 스캔(Full Table Scan)이 발생하는 원인은 무엇인가요?
1. 적용 가능한 인덱스가 없는 경우
2. 넓은 범위의 데이터 액세스

## SQL 쿼리 최적화 방법에는 어떤 것이 있나요?


## 조회 성능을 높이기 위한 방법에는 무엇이 있나요?


## 데이터베이스 성능 모니터링 도구나 기법에 대해 설명해주세요.




