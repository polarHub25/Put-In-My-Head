
## JVM의 구조와 Java의 실행방식을 설명해주세요. 

> java의 실행방식 <br>
- java 코드는 javac 컴파일러에 의해 java 바이트 코드(.class)로 변환
- java 바이트 코드는 jvm에 의해 메모리로 로드되고, 검증된 후 실행
- jvm의 Execution Engine은 인터프리터와 JIT 컴파일러를 사용해 바이트코드를 해석하거나 기계어로 
변환해 실행
- jvm은 메모리를 자동으로 관리하며, 필요시 JNI를 통해 네이티브 메서드(c, c++ 등)도 호출
- 프로그램 실행이 완료되면 jvm은 gc과 리소스 해제를 통해 메모리를 정리하고 종료

> jvm 역할 <br>

자바 애플리케이션을 클래스 로더를 통해 읽어 자바 api와 함께 실행하는 것

- Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올림
- Runtine Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석 
- 이 과정에서 Execution Engine에 의해 gc의 작동과 스레드 동기화가 이루어짐.

> jvm 구조 <br>

클래스 로더 <br>
 - jvm 내로 .class 파일을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치 
 
실행엔진 ( Execution Engine ) 
 - 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행 <br>
   ( 인터프리터와 JIT 컴파일러 방식을 혼합하여 바이트 코드 실행) 
 * 인터프리터 <br>
   : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 ( 전체적인 속도는 느림 ) 
 * JIT 컴파일러 (Just in time) <br>
   : 인터프리터의 단점을 보완하기 위해 도입. 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 native code로 변경하고, 
   그 이후에는 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드(c, c++) 로 직접 실행하는 방식
 * 가비지 콜렉터 (Garbage Collector) <br>
 : heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수. 개발자가 따로 메모리 관리를 하지않아도 됨.


런타임 데이터 영역 (Runtime Data Areas)
 - jvm의 메모리 영역. 자바 애플리케이션이 실행할 때 사용되는 데이터들을 적재하는 영역

 * 메소드 영역 (Method Area) <br>
 : jvm이 시작될때 생성되는 공간. 바이트 코드를 처음 메모리 공간에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간 <br>
 : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름, 리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성 
 * 힙 영역 (Heap Area) <br>
 : 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역. <br>
 : new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 <br>
 : GC 대상
 
 * 스택 영역 (Stack Area) <br>
 : 메소드가 호출될때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장 <br>
 : 임시적으로 사용되는 변수, 정보들이 저장되는 영역
 * PC Register ( Program Counter register ) <br>
 : 스레드가 시작될때 생성. 현재 수행중인 jvm 명령어 주소를 저장하는 공간. <br>
 * 네이티브 메소드 스택 (Native Method Stack) <br>
 : 기계어로 작성된 프로그램을 실행시키는 영역
 
자바 네이티브 인터페이스
- 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공 <br>

네이티브 메소드 라이브러리 
- c, c++ 로 작성된 라이브러리를 칭함.


java, jvm 설명
자바 소스코드는 컴파일러가 바이트 코드(.class)로 변환합니다.  <br>
이렇게 변경된 바이트 코드는 클래스 로더가 runtime data area로 로딩시킵니다.  <br>
이 영역은 5가지 영역으로 이루어져 있으며, 메소드와 힙 영역은 모든 스레드가 공유하는 영역이고, <br>
 스택, pc 레지스터, 네이티브 메소드 스택은 스레드 마다 하나씩 생성되는 공간입니다.  <br>
 
메소드 영역은 jvm이 시작될때 생성되는 공간으로,  <br>
모든 스레드가 공유하는 영역으로 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름,  <br>
리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성등이 저장이 됩니다.  <br>

힙영역은 동적으로 생성된 객체가 저장되는 영역으로, 뉴 연산을 통하여 동적으로 생성된  <br>
인스턴스 변수가 저장됩니다.  <br>
뉴 연산을 통해 생성된 데이터는 예를 들어 클래스의 객체, 배열등이 있고,  <br>
그렇게 생성된 변수는 해당 객체가 소멸되기 전이나 gc가 정리하기전까지는 남아있습니다.  <br>

스택 영역은 지역변수, 메서드의 매개변수, 임시적으로 사용되는 변수, 메서드의 정보가 저장되는  <br>
영역입니다. 지역변수와 매개변수의 특성상 해당 메서드에 호출이 종료되면 이 안에  <br>
선언된 변수들은 사라집니다. 주로 금방 사용되고 끝나는 데이터가 저장되는 영역입니다.  <br>

pc 레지스터는 현재 수행중인 jvm의 명령어 주소를 저장하는 공간입니다. <br>
 스레드가 어떤 부분을 어떤 명령어로 수행할지를 저장하는 공간  <br>
 
네이티브 메서드 스택은 자바가 아닌 다른언어로 작성된 코드를 위한 공간으로 ,  <br>
c, c++를 수행하기 위한 공간이고, 실제 실행할 수 있는 기계어를 실행시키는 영역  <br>
이제 runtinme area에 로딩된 클래스 파일이 execution engine을 통해  <br>
해석될 차례로, 바이트코드를 기계어로 바꾸는 작업이 필요한데 , 여기서 2가지 방법이 있다.  <br>

먼저 인터프리터는 명령어를 한줄한줄 해석하면서 실행을 한다. 그리고 <br>
JIT (Just in time) 컴파일러는 인터프리터의 단점을 해결하기 위해  <br>
런타임 시간에 한꺼번에 변경하여 실행합니다.  <br>
이렇게 기계어로 변경된 것들이 runtime data area에 배치되어  <br>
스레드 동기화 또는 가비지 컬렉션을 수행하게 됩니다.  <br>

마지막으로 네이티브 메소드 인터페이스와 라이브러리는  <br>
jvm에 의해 실행되는 코드중에 네이티브로 실행되는 것이 있다면,  <br>
해당 네이티브 코드를 호출하거나 호출 될수 있더록 만든 프레임 워크이고,  <br>
네이티브 메소드 라이브러리는 네이티브 메소드 실행에 필요한 라이브러리라고 합니다.  <br>


## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

> 정의 
 - 자바의 메모리 관리 방법중 하나로 jvm의 heap 영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

> 필요이유 
 - 메모리 누수 방지 : 사용하지 않는 객체를 해제하지않으면, 메모리 누수 발생 
 - 안전성 향상 : 수동으로 메모리 관리시의 오류를 방지하여 프로그램의 안정성 증진
동작방식 
 : Mark and Sweep 알고리즘 기반으로 동작
 - Marking : 루트 객체에서 그래프 순회를 통해 참조되고 있는 모든 객체 추적
 - Sweeping : 마킹 단계에서 unreachable 상태로 표시된 객체들을 heap에서 제거
 - Compacting : 메모리 단편화를 방지하기 위해 남아있는 객체들을 한쪽으로 모아서 연속적인 메모리 블록을 만듬

## 컬렉션 프레임워크에 대해서 설명해주세요.
> 정의
-  객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스들의 집합.( 자료구조의 종류를 자바 클래스로 구현한 모음집 ) <br>
- Collection 인터페이스와 Map 인터페이스로 나뉨 
> 종류 
- List : 순서가 있는 요소의 집합. 중복 요소 허용 (arraylist, linkedlist, vector) 
( 배열과 리스트의 차이점은 리스트는 자료형 크기가 고정이 아닌데, 배열은 고정) 
- Set : 순서 보장 없음. 중복되지않는 요소의 집합 (hashset, linkedhashset..), 순서가 없으므로 get 메서드 없음
- Queue : 선입선출 구조. 
- Map : key-value 쌍으로 데이터 저장. 키 중복 불가. value 중복 가능 (hashmap, linkedhashmap..) 


## 제네릭에 대해서 설명해주세요.
> 정의
- java에서 코드의 재사용성과 타입 안정성을 높이기 위해 도입된 기능.
> 특징
- 제네릭을 사용하면 클래스나 메서드에서 사용할 데이터 타입을 외부에서 지정할 수 있어, 다양한 타입에 대해 동일한 코드를 작성할 수 있다. 
- 제네릭을 사용하면 컴파일 시점에서 타입 검사가 이루어지기 때문에 런타임에서 발생할 수 있는 classCastException을 방지할 수 있다. 


## 애노테이션에 대해서 설명해주세요.
> 정의
- java에서 메타데이터를 제공하는 일종의 마커로, 코드에 추가적인 정보 제공 및 특정 동작을 수행하도록 하는데 사용
> 특징
- 주석처럼 코드에 부가적인 정보를 제공, 컴파일러나 런타임시에도 정보 활용 가능
> 예시
- 컴파일러 지시 : @Override, @deprecated 처럼 컴파일러에게 특정 동작을 지시
- 런타임 지시 : @Autowired 처럼 스프링 프레임워크에서 빈 주입 등 런타임 시 특정 기능을 자동으로 처리하는 동작 지시
- 빌드 및 배포 도구 : @Entity, @Table 등 JPA 어노테이션으로 ORM을 정의하며, 엔티티 클래스가 디비 데이블과 어떻게 매핑되는지 지정.
- 커스텀 어노테이션을 정의도 가능. @interface 어노테이션을 지정.


## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
> 오버라이딩 
- 부모 클래스의 메소드의 동작만을 재정의하는것이므로, 메소드의 선언부(매개변수 갯수, 리턴타입)는 기존 메소드와 같아야함
- 부모 클래스의 메소드보다 좁은 접근 제어자로 변경할수 있음

> 오버로딩 (overloading) 
- 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 정의해서 다양한 상황에서 사용하는 것을 의미
- 반환 타입과는 관계가 없음
- 오버로딩의 개념없이 메서드명을 다르게하여 각기 다른 메서드로 정의해서 사용해도 상관은 없으나, 객체지향의 다형성을 추구하기 위해 사용

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 추상 클래스는 단일 상속이지만, 인터페이스는 다중 구현이 가능 
- 추상 클래스는 필드와 메서드를 모두 가질 수 있지만, 인터페이스는 기본적인 메서드만 정의 가능
- 추상 클래스는 관계를 명확히 하고, 부모의 기능을 확장시키는데 목적이 있지만, 인터페이스는 클래스가 특정 기능을 구현하도록 강제하는 목적이 있습니다. 


## 클래스는 무엇이고 객체는 무엇인가요?
> 클래스
- 객체를 정의하는 틀 또는 설계도. 객체의 속성과 메서드를 정의. jvm에 메서드 영역에 저장.
> 객체
- 클래스를 기반으로 만들어진 실제 인스턴스. jvm의 힙 영역에 할당
> 정리
- 클래스는 객체 지향 프로그래밍의 기본 단위로 객체를 생성하지 위한 설계도이고, 객체는 이 클래스를 기반으로 생성된 데이터와 기능을 포함한 인스턴스.

## Static이란 무엇인가요?
- 클래스 레벨에서 변수, 메서드, 초기화 블록을 정의할때 사용
- static 으로 선언된 변수나 메서드는 클래스에 속하며, 이는 클래스가 메모리에 로드될때 초기화되며, 인스턴스화 없이 클래스 이름을 통해 직접 접근
> static 변수와 인스턴스 변수의 차이점은 ? 
- static 변수는 클래스에 속하며, 모든 인스턴스가 공유하는 반면, 인스턴스 변수는 각 객체에 속하며 객체마다 고유한 값을 가짐
> static 메서드에서는 인스턴스 변수를 사용할 수 없는 이유는? 
- static 메서드는 클래스 레벨에서 호출되므로, 인스턴스화되지 않은 상태에서 실행
> static 블록의 역할은? 
- 클래스가 메모리에 로드될때 한번 실행되며, 복잡한 정적 변수 초기화나 외부 리소스 로드에 사용
> static 메서드를 오버라이딩 할 수 있는가? 
- 클래스 레벨에 속하므로 오버라이딩 할 수 없음. 대신 자식 클래스에서 동일한 이름의 static 메서드를 정의하는 것을 메서드 숨김으로 처리
> static import와 일반 import의 차이? 
- static import를 사용하면 클래스 이름을 명시하지않고도 직접사용가능 
> static은 jvm에 어느 메모리 영역에 로딩되나요? 
- 메서드 영역에 로딩. 
- java 7 이전에는 메서드 영역이 permge에 구현. java 8 이후에는 메서드 영역이 metaspace 에 구현되어 네이티브 메모리 사용
-> jvm의 런타임 데이터 영역이 변경된건 아니지만, 메서드 영역이 어떻게 관리되는지에 변화가 있는것(permgen -> metaspace) 

## 자바의 원시타입(Primitive type)들은 무엇이 있으며 각각 몇 바이트를 차지하나요?

정수형: byte (1바이트), short (2바이트), int (4바이트), long (8바이트)
실수형: float (4바이트), double (8바이트)
문자형: char (2바이트, 유니코드)
논리형: boolean (크기 명시 없음, 보통 1비트 또는 1바이트)
> primitive type과 wrapper class 차이점은?
- primitive type은 값 자체를 저장하며, 메모리 효율적이고 성능이 좋음
- wrapper class는 primitive type을 객체로 감싸며, null을 허용하고, 제네릭 상황에서 사용

> java에 데이터 타입이란, 변수에 적재할 데이터가 메모리에 어떻게 저장되고 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 키워드
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- 클래스, 변수, 메서드 등에 대한 접근 권한을 설정하여 코드의 캡슐화/정보 은닉를 높이는데 사용
- private : 같은 클래스 내에서만 접근 가능 
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한 없음
> private으로 선언된 변수에 접근할 수 있는 방법은?
- private 변수에 직접 접근할 수는 없지만, 해당 변수를 읽거나 설정하기 위한 public 또는 protected getter/setter 메서드를 통해 접근 가능
> 상속받은 클래스에서 부모 클래스의 private 변수를 사용할 수 있나요?
- 아니요. 부모 클래스의 private 변수는 자식클래스에서 접근 할 수 없습니다. 부모클래스에서 제공하는 protected, public 메서드를 통해 접근해야함 
> 왜 접근 제어자를 제공하나요?
- java의 접근 제어자는 캡슐화를 통해 내부 구현을 숨기고, 데이터 보호 및 코드 재사용성을 높이며, 잘못된 접근을 방지하여 코드의 안정성과 유지보수성을 높이는 역할
> java에서 인터페이스의 메서드는 기본적으로 어떤 제어자를 가지나요? 
- public으로 선언되며, 인터페이스 메서드는 항상 public이며, 이를 구현하는 클래스도 public으로 구현해야함 
> 한 클래스 내에서 두개의 메서드가 같은 이름을 가질 떄, 접근 제어자를 다르게 할 수 있나요? 
- 네. 같은 클래스에서 메서드 오버로딩이 가능하며, 각 메서드는 다른 접근 제어자를 가질수 있다. 하지만 오버라이팅 된 메서드의 접근 제어자는 부모 메서드보다 좁게 설정할수는 없음

## 객체 지향에 대해서 설명해주세요.
- 객체(Objects)들이 모여서 상호 협력하면서 데이터를 처리하는 방식의 프로그래밍 설계 방법 (데이터와 그 데이터를 처리하는 메서드를 하나의 객체로 묶어, 이러한 객체들 간의 상호작용을 통해 프로그램을 설계하고 개발하는 프로그래밍 )
- 객체 지향 프로그래밍 : 객체를 중심으로 소프트웨어를 설계하고 개발하는 패러다임으로, 객체들이 서로 상호작용하여 프로그램이 동작하게됨. 코드의 재사용성, 확장성, 유지보수성을 높이는것
- 객체 지향 4가지 핵심 원칙 : 캡슐화, 상속, 다형성, 추상화
- 추상화 ( Abstraction ) : 클래스를 정의할 때 불필요한 부분들을 생략하고, 객체의 속성에서 중요한 것에 중점을 두어 개략화 하는 것 <br>
&rarr; 데이터 추상화 : 객체의 관련 속성만 표시 ( 대상을 간단한 개념으로 일반화 )  <br>
&rarr; 제어 추상화 : 불필요한 세부정보는 숨김 ( 사용자에게 해당 메서드의 작동방식과 같은 내부 로직은 숨김 )
- 상속 ( Inheritance ) : 상위 클래스의 속성과 기능을 재사용하여 하위 클래스가 전부 물려받는것
- 캡슐화 ( Encapsulation ) : 객체의 속성(Field)과 행위(Method)를 하나로 묶고, 외부로부터 내부를 감싸 숨겨 은닉.
ex) protected, default , private
- 다형성 ( Polymorphism ) : 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
ex) 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 ..

## SOLID 에 대해서 설명해주세요 ( 객체 지향 5대 원칙 ) 
- SRP( Single Responsibility Principle ) : 단일 책임 원칙
- OCP ( Open Closed Principle ) : 개방 폐쇄 원칙
- LSP ( Listov Substution Principle ) : 리스코프 치환 원칙
- ISP ( Interface Segregation Principle ) : 인터페이스 분리 원칙
- DIP ( Dependency Inversion Principle ) : 의존 역전 원칙

- SRP : 하나의 클래스는 하나의 책임만 가져야 함. 즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로 여러개 설계하라는 원칙
- OCP : 확장에 열려있어야 하며, 수정에는 닫혀있어야한다. 즉, 기능 추가 요청이 오면 클래스는 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성하는 설계 기법
        추상화 사용을 통한 관계 구축을 권장-> 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- LSP : 자식 클래스는 부모 클래스의 기능을 확장하되, 부모 클래스의 기능을 깨지 않도록 일관성을 유지해야 한다는 원칙
- ISP : 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙
- DIP : 어떤 class 를 참조해서 사용해야하는 상황이 생긴다면, 그 class 를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스, 인터페이스) 로 참조하라는 원칙

> SOLID 원칙이 왜 중요한가? 
- SOLID 원칙은 코드의 유지보수성, 확장성, 재사용성을 높이기 위해 중요
## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성 : 두 객체가 메모리상에서 같은 객체인지를 판단. 즉, 동일한 메모리 주소를 가리키는지 확인. "==" 연산자를 사용하여 비교
- 동등성 : 두 객체의 값이나 상태가 같은지를 판단. 즉, 객체가 다르더라도 내부 값이 동일하면 동등하다고 판단. "equals()" 메서드를 사용하여 비교
> 동등성을 비교할때 equals() 메서드를 오버라이딩 해야하는 이유는?
- 기본적으로 object 클래스의 equals() 메서드는 동일성을 비교함. 그래서 동등성 비교를 위해서는 오버라이딩을 해야함.

## 원시타입과 참조타입의 차이에 대해 설명해주세요.
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장
> 원시타입과 참조타입의 차이점은 무엇인가요?
- 원시타입은 값 자체를 저장하고, 스택 메모리에 저장. 참조타입은 객체의 주소를 저장하며, 스택에는 주소값이 실제 객체는 힙 메모리에 저장

## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- 모두 문자열을 다루지만, 동작 방식, 성능, 스레드 안정성에 차이가 있음
- String 
: String 클래스는 불변 객체. 한변 생성된 문자열은 변경할 수 없고, 문자열을 수정하는 작업에는 항상 새로운 객체를 생성 
: 문자열을 변경할 때마다 새로운 객체를 생성하므로, 메모리 낭비 발생, 성능 저하, String 객체는 불변이므로 스레드 안전
- Stringbuilder 
: 가변 객체로, 문자열을 수정할 때 객체를 새로 생성하지 않고, 기존 객체를 수정 
: 문자열을 자주 변경한느 작업에서 사용되며, 스레드 안정성이 필요 없는 상황에서 성능 최적화 가능
- StringBuffer 
: Stringbuilder와 유사하지만, 동기화 되어 있어 스레드 안전. 다중 스레드 환경에서 문자열을 자주 수정해야 하는 경우에 사용
> Stringbuilder와 StringBuffer의 차이점은? 
- StringBuilder는 동기화되지 않아 단일 스레드 환경에서 성능 우수. StringBuffer는 동기화되어 스레드안전하므로 멀티 스레드 환경에서 사용

> 동기화란? 
- 자바에서 멀티 스레드 환경에서 공유 자원에 대한 접근을 조절하는 매커니즘 
- 여러 스레드가 동시에 동일한 객체나 메서드에 접근할 때 데이터 무결성이나 일관성을 보장하기 위해 사용

> StringBuffer가 동기화된 클래스라는것은 무슨 의미인가요? 
- StringBuffer는 동기화된 메서드를 제공, 여러 스레드가 동시에 접근해도 안전하게 사용 가능. 한번에 하나의 스레드만 접근하도록 제어하여 데이터 충돌을 방지 



## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 
스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
> Checked Exception
- 컴파일 시점에 체크되는 예외
- 개발자가 명시적으로 처리해야함 ( try-catch-throws )
- Exception 클래스를 직접 상속
- I/O, 파일, 네트워크, DB 작업 등 외부 자원과 관련된 작업에서 발생
- IOException, SQLException, ClassNotFoundException

> Unchecked Exception
- 런타임 시점에 발생하는 예외 
- 컴파일러가 강제하지 않으므로 명시적으로 처리 하지 않아도 됨. 개발자가 코드를 잘 작성하면 피할 수 있는 예외
- RuntimeException 클래스를 상속
- Null 참조, 배열 인덱스 초과, 잘못된 연산 등에서 발생 
- NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException.. 

> 예외( Exception )vs 오류 ( Error ) 
- 예외( Exception )
: 프로그램 실행 중 발생할 수 있는 예상 가능한 문제 

- 오류( Error )
: 시스템 레벨에서 발생하는 문제로, 일반적으로 개발자가 예측하거나 처리할 수 없는 문제. 주로 JVM에서 발생하며, 프로그램의 비정상 종료를 초래할 수 있음

> 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
- Unchecked Exception(RuntimeException)과 Error가 발생할때 트랜잭션을 롤백

> Checked Exception이 발생해도 트랜잭션을 롤백하려면 어떻게 해야 하나요? 
- @Transactional 어노테이션의 rollbackfor 속성을 사용해 롤백 대상 지정 가능 
- @Transactional(rollbackFor = Exception.class) 로 설정하면 롤백 가능

> 스프링 트랜잭션에서 기본적으로 RuntimeException과 Error만 롤백하는 이유는? 
- RuntimeException과 Error는 예측 불가능한 비정상적인 상황을 나타내므로, 데이터의 일관성을 위해 자동으로 롤백. 
- Checked Exception은 비즈니스 로직의 일부로 발생할 수 있어 롤백 여부를 개발자가 선택할수 있음

> OutOfMemoryError에 대해서 발생시점, 예방 방법, 처리 방법에 대해서 알려주세요 
- JVM의 힙 메모리나 메타스페이스 영역에서 사용할 수 있는 메모리가 부족할 때 발생하는 런타임 오류 
- 발생 시점 
: 메모리 누수 , 메모리 과다 사용 ( 대량의 데이터를 힙 메모리에 적재하거나, 대규모 컬렉션을 무한 확장시 ), 잘못된 객체 관리 ( 무한 루프 ) 
- 예방 방법 
: 사용이 끝난 객체를 명시적으로 참조 해제 , 메모리 효율이 좋은 데이터 구조 사용하여 불필요한 메모리 사용 줄임 , JVM 옵션 ( -Xms, -Xmx ) 를 설정하여 힙 메모리 크기 조정 , 불필요한 객체 생성 피함
- 처리 방법 
: 발생 즉시 큰 객체나 불필요한 참조를 해제하여 메모리 확보 후 작업 재시도 , 메모리 부족이 근본적으로 자원의 한계에서 발생했다면, JVM 힙 메모리 설정을 늘리거나, 분산 처리로 재설계하여 시스템 부담 줄이기, 애플리케이션 재시작


## Java8에서 추가된 기능에 대해서 설명해주세요.
- 람다 표현식
: 함수를 간단하게 표현할 수 있는 방법. 주로 익명 내부 클래스를 대체하기 위해 사용. 

``` java 
List<String> names = Arrays.asList("a", "b", "c");
names.forEach(name -> System.out.println(name)); // 람다 표현식 사용
```

- 스트림 API ( Stream API ) 
: 데이터 처리를 함수형 스타일로 처리할 수 있음. 컬렉션 데이터를 필터링, 매핑, 정렬 등 작업을 수행할 때 유용, 병렬 처리 기능도 제공
``` java 
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)
       .forEach(System.out::println); // 짝수만 출력
```

- 인터페이스 디폴트 메서드
: 인터페이스에 디폴트 메서드 정의 가능.

- 메서드 참조 
: 기존 메서드를 람다 표현식처럼 사용할 수 있도록 지원. 간결하고 가독성 높은 코드 작성 가능
``` java 
List<String> names = Arrays.asList("a", "b", "c");
names.forEach(System.out::println); // 메서드 참조 사용
```

- Optional class 
: 값이 있을 수도 있고, 없을 수도 있는 상황을 처리하는데 유용. NPE 방지 가능

``` java 
Optional<String> optionalName = Optional.ofNullable(null);
System.out.println(optionalName.isPresent()); // false 출력
optionalName.ifPresent(System.out::println); // 값이 없으면 아무것도 출력되지 않음
```

- 날짜와 시간 API ( java.time 패키지 ) 
: 기존의 java.util.Date와 Calendar의 단점을 보완한 새로운 API 도입 . 불변 객체를 기반으로 하며 직관적인 날짜와 시간 처리 가능
- 기존 API : 불변성이 없으며, 스레드 안전하지 않음. 월이 0부터 시작, 시간대와의 통합 불편
- 변경된 API : 불변 객체, 스레드 안전. 월이 1부터 시작, 시간대 관련(ZoneDateTime) 제공
``` java 
LocalDate today = LocalDate.now();
System.out.println(today);
``` 

> 스트림 API의 장점은 무엇이며, 실무에서 어떻게 활용해봤나요? 
- 스트림 API는 데이터 처리 로직을 간결하게 구현할 수 있고, 실무에서 스트림 API를 활용하여 컬렉션 데이터를 효율적으로 처리한 경험이 있습니다. 
예를 들어, SubscriptionList라는 리스트안에 각 리스트의 요소는 Subscription 객체였고, 각 Subscription 객체는 Subscriptiontool 객체를 포함한 또 다른 리스트를 가지고 있었습니다. 
즉, 리스트 안에 데이터가 리스트로 들어가 있는 중첩된 형태였습니다. 기존에는 중첩 반복문과 조건문을 사용해 데이터를 처리헀지만, 스트림API의 flatMap() 를 활용해 리스트의 리스트를 평탄화하여( 하나의 리스트 형태로 ) 효율적으로 데이터를 처리할 수 있었습니다. 

> flatMap()의 동작원리 설명해주세요 
- 스트림의 각 요소를 함수로 매핑한 후, 반환된 여러 하위 스트림을 하나의 스트림으로 평탄화하여 단일 스트림을 생성하는 메서드. 주로 리스트 안의 리스트와 같은 중첩된 데이터를 처리할 때 사용

## try-with-resource에 대해서 설명해주세요.
- Java 7에서 도입된 기능으로 자동으로 자원을 해제(Close)해주는 구문
- 파일, DB 연결, 네트워크 소켓 등과 같이 자원을 명시적으로 해제해줘야 하는 경우 사용 
- try-catch-finally 구조에서 자원을 수동으로 해제해야 하는 번거로움과 자원 해제 누락으로 인한 문제를 해결하기 위해 도입
- 자원 해제를 자동으로 처리해 코드가 간결해지며, 예외가 발생해도 자원이 안젼하게 해제. 자원 누수 문제 방지
- try 블록에서 사용하는 자원이 AutoCloseable 인터페이스를 구현하고 있어야함 
- java의 자원 클래스들은 대부분 AutoCloseable을 이미 구현함 
ex) InputStream, OutputStream, Reader, Writer, Connection, BufferReader, FileReader.. 
- AutoCloseable을 구현하면 try 블록이 끝날 때, 자원이 자동으로 해제되도록 close()메서드 호출

> try-with-resource에서 여러 자원을 다룰 때 자원 해제 순서는 어떻게 되나요? 
- 여러 자원을 선언하면, 선언된 순서의 역순으로 자원이 해제되며, 이는 자원들 간의 의존성 문제를 안전하게 처리하기 위함

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
> 강한 결합 ( Tight Coupling )
- 클래스가 서로의 구현에 의존하며, 하나의 클래스가 변경되면 그 클래스를 의존하는 다른 클래스들도 변경 해야함. 시스템 확장이나 유지보수가 어려워짐

> 느슨한 결합 (Loose Coupling ) 
- 클래스나 모듈간의 의존성을 최소화하며 (인터페이스나 추상화를 통해 의존성을 줄임), 변경에 유연하고 확장성이 뛰어남

> 결합도와 응집도는 어떤 관계가 있나요? 
- 결합도는 클래스나 모듈간의 의존성을 의미하고, 응집도는 클래스나 모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는데, 좋은 소프트웨어 설계는 낮은 결합도와 높은 응집도를 목표로 함 
- ex) 하나의 클래스가 단일 책임 원칙 ( SRP )을 따르면서 다른 클래스와의 의존성을 최소화한다면, 이 클래스는 높은 응집도와 낮은 결합도를 가지고 있다고 볼수 있음


## 직렬화와 역직렬화에 대해서 설명해주세요.
> 직렬화(Serialization)
- 객체를 바이트 스트림으로 변환하여, 파일, 데이터베이스, 네트워크를 통해 저장하거나 전송할 수 있도록 하는 과정
- 직렬화된 객체는 프로그램이 종료되더라도 데이터 유지 가능
- java : Serializable 인터페이스를 구현함으로써 객체 직렬화 가능
- 직렬화된 객체는 클래스 버전이 변경되면 역직렬화가 실패할 수도 있으므로 serialVersionUID 정의하는것이 좋음

> 역직렬화 (Deserialization)
- 바이트 스트림으로 저장된 데이터를 다시 객체로 변환하는 과정. 직렬화 데이터를 읽어 원래의 객체 상태로 복원

> serialVersionUID의 역할은 무엇이며, 왜 명시적으로 정의하는 것이 중요한가요?
- serialVersionUID는 클래스의 버전 관리를 위한 고유 식별자. 역직렬화 과정에서 버전 불일치로 인한 오류 방지를 위해 정의하는것이 중요 

> Serializable 인터페이스를 구현하지 않은 객체를 직렬화하려고 할 때 어떤 문제가 발생하나요?
- Serializable 인터페이스를 구현하지 않은 객체는 직렬화할 수 없으며, 이를 직렬화하려고 시도하면 NotSerializableException이 발생

> java에서 직렬화가 필요한 이유는? 
- 직렬화는 객체의 상태를 저장하거나, 네트워크를 통해 객체를 전송하기 위해 필요. 이를 통해 프로그램이 종료되거나 다른 시스템 간의 객체를 주고받을 때도 객체의 상태 유지할수 있음

> 직렬화 시 객체가 참조하는 다른 객체는 어떻게 되는지? 
- 직렬화 과정에서 객체가 참조하는 다른 객체도 함께 직렬화됨. 이때 해당 객체들도 Serializable 인터페이스를 구현해야하며, 그렇지 않으면 NotSerializableException이 발생 

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- 동시성 이슈는 멀티 스레드 환경에서 여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 문제

> 동시성 이슈 주요 원인 / 해결 방법
```java
// 공유자원, 경쟁조건, 원자성 문제 예시
public class Counter {
    private int counter = 0;

    public void increment() {
        counter++;
    }
    public int getCounter() {
        return counter;
    }
}
public class MyThread extends Thread {
    private Counter counter;

    public MyThread(Counter counter) {
        this.counter = counter;
    }
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new MyThread(counter);
        Thread t2 = new MyThread(counter);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final counter value: " + counter.getCounter());
    }
}
```
- 공유 자원 ( Shared Resource ) <br> 
 : 여러 스레드가 동일한 변수나 객체를 동시에 읽거나 쓰는 상황. 공유 자원은 변수, 객체, 파일, 데이터베이스 등이 될수있음 <br>
 : 위 예시에서: Counter 객체의 counter 변수는 힙 영역에 저장되며, t1과 t2 스레드가 동시에 이 변수에 접근하여 값을 변경합니다. 이 변수는 모든 스레드가 공유하는 자원

- 경쟁 조건 ( Race Condition ) <br>
 : 2개 이상의 스레드가 자원에 접근하는 순서가 결과에 영향을 미치는 상황. 스레드 간의 작업 순서를 예측할 수 없고, 이로 인해 결과 불확실 <br>
 :  t1과 t2 스레드가 동시에 counter++ 연산을 수행하려고 할 때 경쟁이 발생합니다. 두 스레드가 동일한 값을 읽고 각각 증가시키는 과정에서 순서에 따라 최종 결과가 달라질 수 있음 <br>
- 경쟁 조건 해결 방법 <br> 
  : synchronized 키워드를 사용함으로써 한번에 하나의 스레드만 특정 코드 블록이나 메서드에 접근할 수 있도록 보장 <br>
  : java.util.concurrent.locks.Lock 인터페이스를 구현한 ReentrantLock 사용 <br>
  : AtomicInteger, AtomicBoolean 등 원자성을 보장하는 클래스 사용하면 내부적으로 CAS(Compare and swap) 알고리즘을 사용해 경쟁 조건 방지 <br>
  
- 원자성 문제 ( Atomicity Issue ) <br>
 : 원자성은 작업이 "분할 불가능"한 단위로 실행되어야 함. 하지만 원자성이 보장되지 않으면, 여러 단계의 작업이 수행되는 도중 다른 스레드가 개입하여 데이터의 일관성 깨질 수 있음 <br>
 : counter++ 연산은 원자적이지 않기 때문에(단일 작업으로 실행되지 않고), 중간에 다른 스레드가 개입해 값이 잘못될 수 있음 <br>
- 원자성 문제 해결 방법 <br>
 : synchronized 키워드를 사용함으로써 한번에 하나의 스레드만 특정 코드 블록이나 메서드에 접근할 수 있도록 보장 <br>
 : java.util.concurrent.locks.Lock 인터페이스를 구현한 ReentrantLock 사용 <br>
 : AtomicInteger, AtomicLong, AtomicReference 등 자바의 Atomic 클래스를 사용하면 원자성을 보장하는 연산을 수행할 수 있습니다. 이 클래스들은 내부적으로 원자성을 보장하여 데이터의 일관성을 유지 <br>

- 가시성 문제 ( Visibility ) <br>
 : 한 스레드에서 변경된 값이 다른 스레드에서 즉시 보이지 않는 경우 발생. CPU캐시나 메모리 구조로 인해 발생하는 문제. <br>
- 가시성 문제 해결 방법 <br>
 : volatile 키워드를 사용하면 변수의 가시성을 보장. volatile로 선언된 변수는 모든 스레드가 항상 최신 값을 읽게 해줌 <br>
 : 다만 volatile 키워드는 가시성 문제는 해결하지만, 원자성은 보장하지않으므로 복잡한 연산에는 적합하지 않음 <br>
 : synchronized는 연산의 원자성을 보장하면서도 메모리의 가시성을 확보. 즉, synchronized 블록 안에서 변경된 값은 다른 스레드에서도 즉시 반영 <br>
 : 객체의 불변성을 유지하기 위해 final 키워드를 사용, 객체 생성 후 값이 변경되지 않음을 보장할 수 있어 가시성 문제를 방지 <br>
 
- 교착 상태 ( Deadlock )
 : 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리면서 무한히 대기 상태에 빠지는 문제  <br>
- 교착 상태 문제 해결 방법 <br>
 : 자원 획득 순서를 고정 <br> 
 : ReentrantLock의 tryLock() 메서드를 사용해, 특정 시간 동안만 Lock을 시도하고, 실패하면 다른 작업을 수행하도록 설계 <br> 
 : 타임아웃 설정 <br>

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
> Mutable
- 객체의 상태를 변경할 수 있는 개체
- 멀티 스레드 환경에서 상태가 변경될 수 있어 동기화 필요
- ArrayList, Hashmap, 사용자 정의 클래스

> Immutable
- 객체 생성 후 상태를 변경할 수 없으며, 모든 필드는 초기화 후 불변
- 멀티 스레드 환경에서 안전 
- String, Integer, 사용자 정의 불변 클래스
- 개체 생성 비용 증가 , 메모리 사용량 증가

> 차이점
- Mutable 객체는 상태를 변경할 수 있지만, Immutable 객체는 한번 설정된 상태를 변경할 수 없다. 또한 Immutable 객체는 동시성 안전성을 제공하지만, 빈번한 변경 작업이 있을 경우 성능이 저하될 수 있음

> Immutable 객체의 상태를 변경하고 싶은 때는 어떻게 해야하나요?
- Immutable 객체의 상태를 변경할 때는 기존객체를 수정하지 않고, 변경된 값을 반영한 새로운 객체를 생성
  
> Immutable 객체를 설계할 때 주의해야 할 점은 무엇인가요?
- Immutable 객체를 설계할 때 모든 필드는 final이어야 하고, 클래스 자체도 final로 선언하여 상속을 방지해야함. 컬렉션필드가 있을 경우 방어적 복사를 통해 외부에서 수정되지 않도록 해야함.
- 방어적 복사 : 객체의 내부 상태를 보호하기 위해 원본 객체의 복사본을 만들어 반환하거나 저장하는 기법

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
- null 체크를 통한 방어적 코드 작성, Optional 사용, Objects.requireNonNUll()을 통한 입 값 검증, 기본값 설정, Null Object 패턴 등을 사용할 수 있음

> Objects.requireNonNull 과 Optional의 차이점은?
- Objects.requireNonNull은 입력값이 null일 때 예외를 발생시켜 문제를 즉시 감지. Optional은 반환값이 null일 수 있는 경우 안전하게 처리하기 위해 다양한 API 제공

## JDK와 JRE의 차이점을 설명하세요.
> JDK ( Java Development Kit )
- 자바 애플리케이션을 개발하기 위한 도구 및 환경 제공
- JRE, javac, 디버거, 인터프리터 등 개발 도구

> JRE ( Java Runtime Environment )  
- 자바 애플리케이션을 실행하기 위한 런타임 환경
- jvm, 클래스 라이브러리 등 프로그램 실행에 필요한 요소 제공

> 차이점
- JDK는 자바 애플리케이션을 개발하기 위한 도구이며, JRE는 자바 애플리케이션을 실행하기 위한 런타임 환경. JDK는 JRE를 포함하고 있으며, 추가적으로 컴파일러, 디버거 등 개발 도구들이 포함
  
> JVM, JRE, JDK의 관계를 설명해보세요
- JVM은 자바 바이트 코드를 실행하는 가상 머신
- JRE는 JVM과 자바 애플리케이션을 실행하기 위한 라이브러리를 포함한 환경
- JDK는 JRE에 추가적으로 컴파일러와 개발 도구들을 포함한 개발 키트
  
> JDK와 JRE의 사용 시점을 구분해주세요
- 자바 애플리케이션을 개발할 때는 JDK가 필요, 단순히 자바 애플리케이션을 실행만 하고자 할때는 JRE만 설치

















