# 데이터베이스

## 데이터베이스란 무엇인가요?
> 데이터베이스 정의
- 체계적으로 정리된 데이터의 집합으로, 애플리케이션에서 데이터를 효율적으로 저장, 검색, 수정할 수 있도록 설계된 시스템. 데이터 베이스는 데이터베이스 관리시스템(DBMS)에 의해 제어됨.
- 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터(Operational Data) : 업무를 수행하는데 반드시 필요한 자료
- 공용 데이터(Shared Data) : 여러 시스템들이 공동으로 소유하고 유지하는 자료

> 데이터베이스 특징
- 실시간 접근성(Real-Time Accessibility) : 실시간 처리에 의한 응답이 가능해야한다
- 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적. 새로운 데이터의 Insert, Delete, Update로 최신 데이터를 유지한다
- 동시공용(Concurrent Sharing) : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야한다
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는데이터를 참조할 때 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터 내용으로 찾는다

> 데이터베이스와 파일 시스템의 차이점은?
- 데이터베이스는 구조화된 방식으로 데이터를 저장하고 관계를 정의할 수 있지만, 파일 시스템은 단순히 데이터를 파일 형태로 저장.

> 데이터와 정보의 차이점은?
- 데이터(Data) : 현실 세계에서 측정하고 수집한 사실이나 값
- 정보(Information) : 어떤 목적이나 의도에 맞게 데이터를 가공 처리한 것

## RDBMS와 NoSQL의 차이점은 무엇인가요?
> RDBMS
- 관계형 데이터베이스 관리 시스템 (관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어)
- 정해진 스키마를 기반으로 데이터를 테이블 형식으로 저장
- 테이블 간의 관계는 외래키를 통해 정의, 데이터의 무결성과 참조 무결성 유지
- ACID 트랜잭션을 지원하여 데이터 무결성 보장
- 성능 향상은 Scale up 
- MySQL, Oracle, SQLite, PostgreSQL..

> NoSQL
- Document Database, Graph Database, Key-Value Database, Wide Column Database 등 다양한 데이터 모델 지원
- 스키마가 없어서 데이터 구조가 자주 변경되거나 다양한 형태의 데이터 저장 가능
- BASE 속성을 통해 일관성을 약하지만 가용성을 높임
- 성능 향상은 Scale out

> 차이점
- RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터가 고정된 스키마를 가진 테이블 형태로 저장. 데이터 간의 관계를 명확하게 정의하고, SQL을 통해 데이터를 관리. 주로 ACID 속성을 준수하여 트랜잭션의 일관성과 무결성을 보장
- NoSQL은 비관계형 데이터베이스로, 다양한 모델을 지원하며, 스키마가 유연. 수평 확장을 통해 대규모 데이터를 효율적으로 처리하며, 일관성보다는 가용성을 우선시하는 경우가 많아서 BASE 속성을 따르는 경우가 많음

> 적합한 사용 사례
- RDBMS는 은행, 금융 시스템과 같이 데이터 무결성과 일관성이 중요한 애플리케이션에 적합
- NoSQL은 대규모 데이터를 빠르게 처리해야 하거나 스키마가 자주 변경되는 애플리케이션에 적합

> 수직확장과 수평확장 비교
- RDBMS의 수직확장은 서버의 하드웨어 성능을 향상시켜 처리 능력을 높이는 방법. 데이터의 일관성을 유지하면서 성능을 개선할 수 있지만, 하드웨어 업그레이드 비용이 높고 확장성이 제한적
- NoSQL의 수평 확장은 여러 서버를 추가하여 데이터와 트래픽을 분산 처리하는 방식. 확장성이 뛰어나 대규모 데이터를 처리하는데 적합하지만, 데이터 일관성을 유지하기 어려울 수 있고, 복잡한 분산 처리 로직을 구현해야함

> BASE 속성 ( 기본적으로 가용성을 유지하며 데이터가 결국 일관적이게 되는 상태 ) 
- Basically Available: 시스템에 장애가 발생하더라도 항상 작동해야한다. 
- Soft state: 데이터가 반드시 항상 일관성을 유지할 필요는 없다 
- Eventually consistent: 결국 데이터는 결국 일관성을 유지하게 된다.
  

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
> 정의
- SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위해 사용하는 표준 프로그래밍 언어입니다. SQL의 주요 기능은 데이터 조회(SELECT), 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE) 등이 있으며, DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 

> DDL
- DDL(Data Definition Language)은 데이터베이스 구조를 정의하는 SQL 명령어 집합으로, CREATE, ALTER, DROP 등이 있습니다.
> DML
- DML(Data Manipulation Language)은 데이터베이스에 저장된 데이터를 조작하는 SQL 명령어로, SELECT, INSERT, UPDATE, DELETE 등이 있습니다.
> DCL
- DCL(Data Control Language)은 데이터베이스 사용 권한을 제어하는 SQL 명령어로, GRANT와 REVOKE가 있습니다.


## 데이터베이스 스키마란 무엇인가요?
> 정의
- 데이터베이스의 구조(개체, 속성, 관계)와 제약 조건에 대한 정의

> 종류
1. 외부 스키마(External Schema, 서브 스키마, 사용자 뷰)
  - 사용자들이 사용할 데이터들을 보여주는 것이므로 추상화가 되어있고, 여러 사용자가 바라보는 관점에 따라 여러 스키마가 존재할 수 있음 
  - 사용자는 데이터베이스에서 데이터를 사용하는 사람이므로 응용 프로그래머로 볼수있음
  - 사용자는 어떤 데이터가 필요한지 결정하므로 쿼리를 이용해서 데이터 조작 가능
  - 응용 프로그래머는 외부 스키마를 통해 구조를 확인하고, DML을 사용해서 데이터를 이용 

2. 개념 스키마(Conceptual Schema, 전체적인 뷰)
  - 데이터베이스의 전체적인 논리적 구조
  - 데이터베이스의 구조, 구체적으로 어떤 데이터가 있고, 각 테이블간의 관계 정의
  - 데이터베이스 관리자(DBA)에 의해서 구성
  - DDL, DCL를 사용하여 구조를 설계
    
3. 내부 스키마(Internal SCheam, 저장 스키마)
  - 물리적 저장장치의 입장에서 본 데이터베이스 구조
  - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  - 데이터의 필드 이름, 해당 필드는 몇 바이트이며 인덱스가 있는지 등을 정의
  - 시스템 프로그래머나 설계자가 보는 관점의 스키마

> 내부 스키마에서 인덱스를 설계할 때 고려해야할 사항은?
- 쿼리 성능을 최적화하기 위해 자주 조회되는 열에 대해서 인덱스를 생성하는것이 중요합니다. 또한 너무 많은 인덱스는 쓰기 성능에 영향을 줄 수 있으므로, 필요한 인덱스만 생성하는것이 중요합니다.

> 스키마 변경이 필요한 상황에서 어떻게 처리하나요?
- 변경의 필요성을 분석하고, 데이터 무결성 및 기존 데이터와의 호환성을 고려해야합니다. 또한 변경사항에 따른 영향도 파악과 테스트를 진행해야하며, 백업, 변경 계힉, 스키마 변경 진행, 데이터 마이그레이션, 테스트, 롤백 계획을 진행해야합니다. 


## 테이블과 뷰(View)의 차이점은 무엇인가요?
> 테이블
- 데이터베이스에서 데이터를 실제로 저장하는 구조
- 테이블에 데이터를 삽입, 수정, 삭제 가능
- 제약 조건 정의 가능

> 뷰(View)
- 하나 이상의 테이블을 기반으로 하는 가상의 테이블
- 실제 데이터를 저장하지 않고, 쿼리 결과를 동적으로 생성하여 제공하는 논리적 구조
- 보안 목적으로 특정 사용자에게만 필요한 데이터를 제공하는데 유용
- 데이터를 삽입, 수정, 삭제할 수 없으나, 특정 조건 만족시에는 가능한 경우도 존재
- CREATE VIEW 뷰이름 AS SELECT 구문;

> 차이점
- 테이블은 데이터를 물리적으로 저장하는 구조이고 뷰는 데이터를 저장하지 않고 데이터를 조회하는 가상의 테이블. 테이블에서는 데이터를 삽입, 삭제, 수정 할수 있지만, 뷰에서는 기본적으로는 불가능. 또한 뷰는 특정 데이터를 쉽게 조회하거나 보안 목적으로 사용

> VIEW와 Materialized View 차이점에 대해서 설명해주세요
- VIEW는 실시간 데이터를 조회하며, 물리적으로 데이터를 저장하지 않는 가상 테이블이고, 데이터가 실시간으로 반영되지만, 복잡한 쿼리에서는 성능이 저하될수 있습니다. Materialized View는 쿼리 결과를 사전에 계산하여 저장하는 테이블로, 빠른 조회 성능을 제공하지만, 갱신이 필요하며 데이터가 항상 최신이 아닐수 있습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
> 기본키
- 테이블 내에서 각 행을 고유하게 식별하는 키
- 중복과 NULL을 가질수 없음
- 기본키는 자동으로 인덱싱되어 검색 성능 향상

> 외래키
- 두 테이블 간의 관계를 설정
- 참조 무결성 유지
- 외래키는 중복될 수 있으며, NULL 값도 가질수있음
  
> 차이점
- 기본키는 테이블 내에서 각 행을 고유하게 식별하기 위한 키이며, 중복될 수 없고 NULL 값을 가질 수 없습니다. 반면, 외래키는 한 테이블이 다른 테이블의 기본키를 참조하여 관계를 설정하는 키로, 중복될 수 있으며 NULL 값을 가질 수 있습니다. 기본키는 테이블의 고유성을 보장하고, 외래키는 테이블 간의 참조 무결성을 유지합니다.

> 외래키가 참조하는 테이블에서 행이 삭제되면 어떻게 되나요?
- 외래키 제약 조건에 따라 달라짐.
- CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블에서도 삭제와 수정이 같이 이루어짐
- SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 NULL로 변경
- NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 변경되지않음
- RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
> ACID 란
- ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 속성 

- Atomicity(원자성): 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 한다. 
- Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스가 일관된 상태를 유지해야한다.
- Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 보장합니다.
- Durability(영속성): 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야한다.

> ACID 속성 중 어느 하나가 실패하면 어떤 일이 발생하나요?
- 데이터베이스가 일관된 상태를 유지하지 못하며, 트랜잭션이 중단되거나 롤백될 수 있습니다.
> 트랜잭션 격리 수준이란 무엇인가요?
- 트랜잭션이 서로 얼마나 격리되어 있는지를 정의하는 설정으로 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등의 수준이 있습니다.

## 트랜잭션이란 무엇인가요?
> 트랜잭션이란
- 데이터베이스에서 일련의 연산을 수행하는 논리적 작업 단위로, 하나의 트랜잭션 내에서 모든 작업이 성공하거나 모두 실패해야 합니다. 트랜잭션은 데이터의 일관성을 유지하고, 데이터베이스에 대한 여러 연산을 하나의 단위로 묶어 처리합니다.

> 트랜잭션의 네 가지 특성은 무엇인가요?
- ACID 속성(원자성, 일관성, 격리성, 영속성)입니다.
> 트랜잭션이 롤백되는 상황은 언제인가요?
- 오류가 발생하거나, 조건이 만족되지 않을 때 롤백이 발생할 수 있습니다.
> 트랜잭션에서 SAVEPOINT란 무엇인가요?
- 트랜잭션 내에서 설정할 수 있는 임시 저장점으로, 롤백 시 특정 SAVEPOINT까지 되돌릴 수 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
> 정의
- 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 최적화하는 과정입니다. 정규화를 통해 데이터의 무결성을 유지하고, 업데이트, 삭제 시 발생할 수 있는 이상 현상을 방지합니다.
- 제 1정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는것
- 제 2정규화 : 제 1정규화를 진행한 테이블에 대해 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안되는것을 의미)을 만족하도록 테이블을 분해하는것
- 제 3정규화 : 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것
- BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는것

> 정규화의 단점은 무엇인가요?
- 과도한 정규화는 성능 저하를 초래할 수 있으며, 복잡한 쿼리를 생성할 수 있습니다.
> 정규화와 반정규화의 차이점은 무엇인가요?
- 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 것이 목적이며, 반정규화는 성능 최적화를 위해 의도적으로 데이터 중복을 허용하는 과정입니다.

- https://datarian.io/blog/database-normalization

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
> 정의
- 역정규화(Denormalization)는 성능 최적화를 위해 의도적으로 정규화된 데이터베이스를 일부 비정규화하는 과정입니다. 이를 통해 데이터 조회 성능을 향상시키고, 복잡한 JOIN 연산을 줄일 수 있습니다. 주로 읽기 성능을 중시하는 시스템에서 사용됩니다.

> 역정규화의 단점은 무엇인가요?
- 데이터 중복이 증가하여 데이터 무결성이 저하될 수 있으며, 저장 공간이 더 많이 필요할 수 있습니다.
> 역정규화의 구체적인 예를 들어보세요.
- 고객 정보와 주문 정보를 하나의 테이블로 합쳐, 각 주문 조회 시 고객 정보를 함께 조회할 수 있도록 하는 것이 예입니다.
> 정규화와 역정규화의 균형을 어떻게 맞추나요?
- 시스템의 요구사항에 따라, 읽기 및 쓰기 성능, 데이터 무결성, 유지보수 용이성 등을 고려해 결정합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
- INNER JOIN: 두 테이블에서 공통적으로 존재하는 데이터 반환 ( 교집합 ) 
- LEFT JOIN: 왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환. 오른쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- RIGHT JOIN: 오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환. 왼쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- FULL JOIN: 양쪽 테이블에서 일치하는 모든 행을 반환하며, 일치하지 않는 행은 NULL

> SELF JOIN이란 무엇인가요?
- 자기 자신과의 JOIN을 의미하며, 같은 테이블의 다른 행을 연결하여 조회할 때 사용됩니다.
> CROSS JOIN이란 무엇인가요?
- 두 테이블의 모든 행 조합을 반환하는 JOIN입니다. 결과는 테이블의 곱(Cartesian Product)입니다.
> JOIN에서 ON과 USING의 차이점은 무엇인가요?
- ON은 모든 조건을 사용해 조인을 설정할 수 있으며, USING은 동일한 이름의 열에 대해 자동으로 조인을 설정합니다.


## GROUP BY와 HAVING의 차이점은 무엇인가요?
- GROUP BY는 결과 집합을 그룹화하는 데 사용되며, HAVING은 그룹화된 결과에 조건을 적용하는 데 사용됩니다.

> GROUP BY에서 COUNT와 함께 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;
> HAVING에서 COUNT를 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name HAVING COUNT(*) > 1;

## WHERE와 HAVING의 차이점은 무엇인가요?
- WHERE는 SQL 쿼리에서 개별 행에 대해 조건을 적용하여 필터링하고, HAVING은 GROUP BY 절로 그룹화된 결과에 조건을 적용하여 필터링합니다. WHERE는 그룹화 전에 필터링을 수행하고, HAVING은 그룹화 후에 필터링을 수행합니다.

> WHERE 절에서 사용할 수 없는 SQL 함수를 예로 들어보세요.
- 집계 함수(예: COUNT, SUM, AVG 등)는 WHERE 절에서 사용할 수 없고, HAVING 절에서 사용해야 합니다.
> HAVING을 WHERE 대신 사용하는 경우는 언제인가요?
- 집계된 데이터에 조건을 적용할 때 HAVING을 사용합니다.

## DISTINCT 키워드는 무엇을 하는가요?
- DISTINCT 키워드는 SELECT 문에서 사용하여 중복된 값을 제거하고 고유한 값을 반환합니다. 이를 통해 쿼리 결과에서 중복된 행을 제외하고 고유한 결과를 얻을 수 있습니다.

> DISTINCT와 GROUP BY의 차이점은 무엇인가요?
- DISTINCT는 중복된 값을 제거하여 고유한 결과를 반환하고, GROUP BY는 데이터를 그룹화하여 집계함수를 사용하는 데 주로 사용됩니다.
> DISTINCT를 사용하는 예를 들어보세요.
- SELECT DISTINCT column_name FROM table_name;


## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
- 서브쿼리(Subquery)는 하나의 SQL 문 안에 포함된 또 다른 쿼리입니다. 
- 복잡한 계산이나 연산을 괄호로 묶어서 수행할 수 있음
- 서브 쿼리는 메인 쿼리의 속성을 그대로 받지만, 메인 쿼리에서는 서브 쿼리의 내용을 참조할 수 없음. 반대로 서브쿼리에서 메인 쿼리의 내용을 참조는 가능

> 종류
1. 스칼라 서브쿼리
   - SELECT 절에 위치하며 한 레코드당 하나의 값을 반환하는 서브쿼리(단일행, 단일컬럼을 반환)
   - 다중행 값 조회되면 "ORA-01427: single-row subquery returns more than one row" 오류 발생
2. 인라인 뷰
   - FROM 절에 위치하는 서브쿼리로 결과는 반드시 하나의 테이블로 리턴
   - 인라인 뷰는 SQL 문이 실행될때 임시적으로 생성되는 동적인 뷰
   - 단점 : SQL을 좀 더 빠른 속도로 사용하기 위한 것이지만, 잘못 사용하게 되면 액세스 속도를 저하 시키는 경우도 많음 
3. 중첩 서브쿼리
   - WHERE 절에 위치하며 메인쿼리 테이블의 특정 컬럼 값과 비교한 값을 반환하는 용도로 주로 사용
   - 단일행, 다중행 반환 가능 

> 서브쿼리와 JOIN 중 어느 것이 더 효율적인가요?
- 상황에 따라 다르지만, JOIN이 일반적으로 더 효율적일 수 있습니다.

## UNION과 UNION ALL의 차이점은 무엇인가요?
- UNION은 두 개의 SELECT 결과를 결합하여 중복된 행을 제거한 후 반환합니다. 반면, UNION ALL은 두 SELECT 결과를 결합하여 중복된 행을 포함한 모든 결과를 반환합니다.

> UNION을 사용한 쿼리의 예를 들어보세요.
- SELECT column_name FROM table1 UNION SELECT column_name FROM table2;
> UNION ALL을 사용하는 이유는 무엇인가요?
- 중복된 데이터를 포함한 전체 결과를 반환하려는 경우 사용합니다.
> UNION과 JOIN의 차이점은 무엇인가요?
- UNION은 두 개의 쿼리 결과를 수직으로 결합하는 반면, JOIN은 두 개의 테이블을 수평으로 결합합니다.

## EXISTS와 IN의 차이점은 무엇인가요?
> EXISTS
- 서브쿼리가 결과를 반환하는지 여부를 확인
- 서브쿼리가 하나 이상의 행을 반환하면 TRUE, 그렇지 않으면 FALSE 반환
- 메인 쿼리의 각 행에 대해 서브쿼리를 싱행하고, 조건을 만족하는 첫 번째 행을 찾으면 실행을 중단
- 서브쿼리가 결과를 반환할 수 있는지 여부만을 확인하므로, 서브쿼리 결과가 크더라도 비교적 효율적으로 작동
- 처리 순서 : 메인쿼리 -> 서브쿼리 
``` SQL
SELECT department_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.department_id);
```
> IN
- 서브쿼리가 반환한 결과 중 하나라도 메인 쿼리의 조건과 일치하는지 확인
- 서브쿼리에서 반환된 모든 값을 메모리에 로드한 후, 메인 쿼리의 각 행에 대해 서브쿼리 목록과 비교
- 반환하는 결과가 작은 경우에 효율적으로 작동
-  처리 순서 : 서브쿼리 -> 메인쿼리 
``` SQL
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1700);
```

> 어떤 상황에서 EXISTS를 사용하는 것이 IN보다 더 효율적인가요?
- 서브쿼리가 매우 큰 결과 집합을 반환하거나, 메인 쿼리와 서브쿼리의 테이블 간에 상관 관계가 있을 때 EXISTS를 사용하는 것이 더 효율적일 수 있습니다. EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 실행을 중지하기 때문에, 서브쿼리의 결과가 클 때 성능이 더 좋습니다. 또한, 서브쿼리가 인덱스된 열에 대해 실행될 때 EXISTS가 더 효율적으로 동작할 수 있습니다.
>  IN 연산자를 사용할 때 주의해야 할 점은 무엇인가요?
- IN 연산자를 사용할 때 주의해야 할 점은 서브쿼리가 반환하는 결과 목록이 너무 크지 않도록 하는 것입니다. 서브쿼리의 결과가 큰 경우 성능이 저하될 수 있습니다. 또한, IN 연산자 사용 시 NULL 값을 포함한 비교가 이루어질 때 결과가 예상과 다를 수 있으므로, NULL 처리에 유의해야 합니다. NULL 값이 포함된 경우, 비교 연산에서 불확실성을 초래할 수 있습니다.
  
## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
- 여러 행으로부터 하나의결과값을 반환하는 함수. 
> 종류 
- COUNT: 행의 개수를 반환
- SUM: 열의 합계를 반환
- AVG: 열의 평균값을 반환
- MIN: 열의 최소값을 반환
- MAX: 열의 최대값을 반환

> COUNT와 DISTINCT를 함께 사용하는 방법은 무엇인가요?
- SELECT COUNT(DISTINCT column_name) FROM table_name;
> 집계 함수에서 NULL 값은 어떻게 처리되나요?
- 대부분의 집계 함수는 NULL 값을 무시합니다. 그러나 COUNT(*)는 NULL 값을 포함합니다.
> 집계 함수를 GROUP BY와 함께 사용하는 예를 보여주세요.
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;


## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
- 하나 이상의 테이블을 기반으로 생성된 가상의 테이블
- 실제 데이터를 저장하지 않고 기본 테이블의 데이터를 조회할 수 있는 SQL 쿼리의 결과를 저장한 논리적 구조
- 복잡한 쿼리를 단순화하고, 특정 데이터를 쉽게 조회하거나 보안을 강화하기 위해 사용

> 장점
- 사용자가 접근할 수 있는 데이터를 제한하여 보안 강화
- 자주 사용하는 복잡한 쿼리를 뷰로 정의해 두면 간단한 SELECT 문으로 동일한 결과 반환 가능
- 특정 데이터를 표준화된 방식으로 제공함으로써 여러 사용자에게 일관된 데이터를 사용할 수 있게 함
- 동일한 뷰를 여러 쿼리에서 사용하므로 코드의 중복을 줄이고, 유지보수 쉽게 가능

> 단점
- 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 복잡한 뷰나 조인이 많은 뷰는 성능 저하를 초래할 수 있음
- 데이터의 삽입, 수정, 삭제하는것이 제한
- 기본 테이블의 구조가 변경되면 오류가 발생할 수 있어 유지보수 필요

> VIEW가 기본 테이블에서 데이터를 가져올 때 실시간으로 쿼리를 실행하는데, 이로 인해 어떤 문제점이 발생할 수 있나요?
- VIEW는 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 기본 테이블이 큰 경우 또는 VIEW가 복잡한 조인을 포함하는 경우 성능 문제가 발생할 수 있습니다. 특히, 여러 테이블을 조인하거나 중첩된 VIEW를 사용하는 경우 쿼리 실행 시간이 길어질 수 있으며, 전체 시스템 성능에 부정적인 영향을 미칠 수 있습니다.


## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- CASE문은 SQL에서 조건에 따라 다른 값을 반환할 수 있도록 하는 조건부 표현식
  
```` SQL
SELECT column_name,
       CASE
           WHEN 조건1 THEN 결과1
           WHEN 조건2 THEN 결과2
           ELSE 결과3
       END AS new_column_name
FROM table_name;
````

> CASE문을 사용하여 집계 데이터를 구분하는 예를 들어보세요.
- SELECT SUM(CASE WHEN column_name > 100 THEN 1 ELSE 0 END) FROM table_name;

> CASE 문을 사용해서 조건부로 데이터를 업데이트할 수 있나요?
```SQL
UPDATE employees
SET bonus = CASE
               WHEN salary > 100000 THEN salary * 0.1
               WHEN salary BETWEEN 50000 AND 100000 THEN salary * 0.05
               ELSE 0
           END;
```


# 데이터베이스

## 데이터베이스란 무엇인가요?
> 데이터베이스 정의
- 체계적으로 정리된 데이터의 집합으로, 애플리케이션에서 데이터를 효율적으로 저장, 검색, 수정할 수 있도록 설계된 시스템. 데이터 베이스는 데이터베이스 관리시스템(DBMS)에 의해 제어됨.
- 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터(Operational Data) : 업무를 수행하는데 반드시 필요한 자료
- 공용 데이터(Shared Data) : 여러 시스템들이 공동으로 소유하고 유지하는 자료

> 데이터베이스 특징
- 실시간 접근성(Real-Time Accessibility) : 실시간 처리에 의한 응답이 가능해야한다
- 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적. 새로운 데이터의 Insert, Delete, Update로 최신 데이터를 유지한다
- 동시공용(Concurrent Sharing) : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야한다
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는데이터를 참조할 때 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터 내용으로 찾는다

> 데이터베이스와 파일 시스템의 차이점은?
- 데이터베이스는 구조화된 방식으로 데이터를 저장하고 관계를 정의할 수 있지만, 파일 시스템은 단순히 데이터를 파일 형태로 저장.

> 데이터와 정보의 차이점은?
- 데이터(Data) : 현실 세계에서 측정하고 수집한 사실이나 값
- 정보(Information) : 어떤 목적이나 의도에 맞게 데이터를 가공 처리한 것

## RDBMS와 NoSQL의 차이점은 무엇인가요?
> RDBMS
- 관계형 데이터베이스 관리 시스템 (관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어)
- 정해진 스키마를 기반으로 데이터를 테이블 형식으로 저장
- 테이블 간의 관계는 외래키를 통해 정의, 데이터의 무결성과 참조 무결성 유지
- ACID 트랜잭션을 지원하여 데이터 무결성 보장
- 성능 향상은 Scale up 
- MySQL, Oracle, SQLite, PostgreSQL..

> NoSQL
- Document Database, Graph Database, Key-Value Database, Wide Column Database 등 다양한 데이터 모델 지원
- 스키마가 없어서 데이터 구조가 자주 변경되거나 다양한 형태의 데이터 저장 가능
- BASE 속성을 통해 일관성을 약하지만 가용성을 높임
- 성능 향상은 Scale out

> 차이점
- RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터가 고정된 스키마를 가진 테이블 형태로 저장. 데이터 간의 관계를 명확하게 정의하고, SQL을 통해 데이터를 관리. 주로 ACID 속성을 준수하여 트랜잭션의 일관성과 무결성을 보장
- NoSQL은 비관계형 데이터베이스로, 다양한 모델을 지원하며, 스키마가 유연. 수평 확장을 통해 대규모 데이터를 효율적으로 처리하며, 일관성보다는 가용성을 우선시하는 경우가 많아서 BASE 속성을 따르는 경우가 많음

> 적합한 사용 사례
- RDBMS는 은행, 금융 시스템과 같이 데이터 무결성과 일관성이 중요한 애플리케이션에 적합
- NoSQL은 대규모 데이터를 빠르게 처리해야 하거나 스키마가 자주 변경되는 애플리케이션에 적합

> 수직확장과 수평확장 비교
- RDBMS의 수직확장은 서버의 하드웨어 성능을 향상시켜 처리 능력을 높이는 방법. 데이터의 일관성을 유지하면서 성능을 개선할 수 있지만, 하드웨어 업그레이드 비용이 높고 확장성이 제한적
- NoSQL의 수평 확장은 여러 서버를 추가하여 데이터와 트래픽을 분산 처리하는 방식. 확장성이 뛰어나 대규모 데이터를 처리하는데 적합하지만, 데이터 일관성을 유지하기 어려울 수 있고, 복잡한 분산 처리 로직을 구현해야함

> BASE 속성 ( 기본적으로 가용성을 유지하며 데이터가 결국 일관적이게 되는 상태 ) 
- Basically Available: 시스템에 장애가 발생하더라도 항상 작동해야한다. 
- Soft state: 데이터가 반드시 항상 일관성을 유지할 필요는 없다 
- Eventually consistent: 결국 데이터는 결국 일관성을 유지하게 된다.
  

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
> 정의
- SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위해 사용하는 표준 프로그래밍 언어입니다. SQL의 주요 기능은 데이터 조회(SELECT), 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE) 등이 있으며, DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 

> DDL
- DDL(Data Definition Language)은 데이터베이스 구조를 정의하는 SQL 명령어 집합으로, CREATE, ALTER, DROP 등이 있습니다.
> DML
- DML(Data Manipulation Language)은 데이터베이스에 저장된 데이터를 조작하는 SQL 명령어로, SELECT, INSERT, UPDATE, DELETE 등이 있습니다.
> DCL
- DCL(Data Control Language)은 데이터베이스 사용 권한을 제어하는 SQL 명령어로, GRANT와 REVOKE가 있습니다.


## 데이터베이스 스키마란 무엇인가요?
> 정의
- 데이터베이스의 구조(개체, 속성, 관계)와 제약 조건에 대한 정의

> 종류
1. 외부 스키마(External Schema, 서브 스키마, 사용자 뷰)
  - 사용자들이 사용할 데이터들을 보여주는 것이므로 추상화가 되어있고, 여러 사용자가 바라보는 관점에 따라 여러 스키마가 존재할 수 있음 
  - 사용자는 데이터베이스에서 데이터를 사용하는 사람이므로 응용 프로그래머로 볼수있음
  - 사용자는 어떤 데이터가 필요한지 결정하므로 쿼리를 이용해서 데이터 조작 가능
  - 응용 프로그래머는 외부 스키마를 통해 구조를 확인하고, DML을 사용해서 데이터를 이용 

2. 개념 스키마(Conceptual Schema, 전체적인 뷰)
  - 데이터베이스의 전체적인 논리적 구조
  - 데이터베이스의 구조, 구체적으로 어떤 데이터가 있고, 각 테이블간의 관계 정의
  - 데이터베이스 관리자(DBA)에 의해서 구성
  - DDL, DCL를 사용하여 구조를 설계
    
3. 내부 스키마(Internal SCheam, 저장 스키마)
  - 물리적 저장장치의 입장에서 본 데이터베이스 구조
  - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  - 데이터의 필드 이름, 해당 필드는 몇 바이트이며 인덱스가 있는지 등을 정의
  - 시스템 프로그래머나 설계자가 보는 관점의 스키마

> 내부 스키마에서 인덱스를 설계할 때 고려해야할 사항은?
- 쿼리 성능을 최적화하기 위해 자주 조회되는 열에 대해서 인덱스를 생성하는것이 중요합니다. 또한 너무 많은 인덱스는 쓰기 성능에 영향을 줄 수 있으므로, 필요한 인덱스만 생성하는것이 중요합니다.

> 스키마 변경이 필요한 상황에서 어떻게 처리하나요?
- 변경의 필요성을 분석하고, 데이터 무결성 및 기존 데이터와의 호환성을 고려해야합니다. 또한 변경사항에 따른 영향도 파악과 테스트를 진행해야하며, 백업, 변경 계힉, 스키마 변경 진행, 데이터 마이그레이션, 테스트, 롤백 계획을 진행해야합니다. 


## 테이블과 뷰(View)의 차이점은 무엇인가요?
> 테이블
- 데이터베이스에서 데이터를 실제로 저장하는 구조
- 테이블에 데이터를 삽입, 수정, 삭제 가능
- 제약 조건 정의 가능

> 뷰(View)
- 하나 이상의 테이블을 기반으로 하는 가상의 테이블
- 실제 데이터를 저장하지 않고, 쿼리 결과를 동적으로 생성하여 제공하는 논리적 구조
- 보안 목적으로 특정 사용자에게만 필요한 데이터를 제공하는데 유용
- 데이터를 삽입, 수정, 삭제할 수 없으나, 특정 조건 만족시에는 가능한 경우도 존재
- CREATE VIEW 뷰이름 AS SELECT 구문;

> 차이점
- 테이블은 데이터를 물리적으로 저장하는 구조이고 뷰는 데이터를 저장하지 않고 데이터를 조회하는 가상의 테이블. 테이블에서는 데이터를 삽입, 삭제, 수정 할수 있지만, 뷰에서는 기본적으로는 불가능. 또한 뷰는 특정 데이터를 쉽게 조회하거나 보안 목적으로 사용

> VIEW와 Materialized View 차이점에 대해서 설명해주세요
- VIEW는 실시간 데이터를 조회하며, 물리적으로 데이터를 저장하지 않는 가상 테이블이고, 데이터가 실시간으로 반영되지만, 복잡한 쿼리에서는 성능이 저하될수 있습니다. Materialized View는 쿼리 결과를 사전에 계산하여 저장하는 테이블로, 빠른 조회 성능을 제공하지만, 갱신이 필요하며 데이터가 항상 최신이 아닐수 있습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
> 기본키
- 테이블 내에서 각 행을 고유하게 식별하는 키
- 중복과 NULL을 가질수 없음
- 기본키는 자동으로 인덱싱되어 검색 성능 향상

> 외래키
- 두 테이블 간의 관계를 설정
- 참조 무결성 유지
- 외래키는 중복될 수 있으며, NULL 값도 가질수있음
  
> 차이점
- 기본키는 테이블 내에서 각 행을 고유하게 식별하기 위한 키이며, 중복될 수 없고 NULL 값을 가질 수 없습니다. 반면, 외래키는 한 테이블이 다른 테이블의 기본키를 참조하여 관계를 설정하는 키로, 중복될 수 있으며 NULL 값을 가질 수 있습니다. 기본키는 테이블의 고유성을 보장하고, 외래키는 테이블 간의 참조 무결성을 유지합니다.

> 외래키가 참조하는 테이블에서 행이 삭제되면 어떻게 되나요?
- 외래키 제약 조건에 따라 달라짐.
- CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블에서도 삭제와 수정이 같이 이루어짐
- SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 NULL로 변경
- NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 변경되지않음
- RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
> ACID 란
- ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 속성 

- Atomicity(원자성): 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 한다. 
- Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스가 일관된 상태를 유지해야한다.
- Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 보장합니다.
- Durability(영속성): 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야한다.

> ACID 속성 중 어느 하나가 실패하면 어떤 일이 발생하나요?
- 데이터베이스가 일관된 상태를 유지하지 못하며, 트랜잭션이 중단되거나 롤백될 수 있습니다.
> 트랜잭션 격리 수준이란 무엇인가요?
- 트랜잭션이 서로 얼마나 격리되어 있는지를 정의하는 설정으로 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등의 수준이 있습니다.

## 트랜잭션이란 무엇인가요?
> 트랜잭션이란
- 데이터베이스에서 일련의 연산을 수행하는 논리적 작업 단위로, 하나의 트랜잭션 내에서 모든 작업이 성공하거나 모두 실패해야 합니다. 트랜잭션은 데이터의 일관성을 유지하고, 데이터베이스에 대한 여러 연산을 하나의 단위로 묶어 처리합니다.

> 트랜잭션의 네 가지 특성은 무엇인가요?
- ACID 속성(원자성, 일관성, 격리성, 영속성)입니다.
> 트랜잭션이 롤백되는 상황은 언제인가요?
- 오류가 발생하거나, 조건이 만족되지 않을 때 롤백이 발생할 수 있습니다.
> 트랜잭션에서 SAVEPOINT란 무엇인가요?
- 트랜잭션 내에서 설정할 수 있는 임시 저장점으로, 롤백 시 특정 SAVEPOINT까지 되돌릴 수 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
> 정의
- 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 최적화하는 과정입니다. 정규화를 통해 데이터의 무결성을 유지하고, 업데이트, 삭제 시 발생할 수 있는 이상 현상을 방지합니다.
- 제 1정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는것
- 제 2정규화 : 제 1정규화를 진행한 테이블에 대해 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안되는것을 의미)을 만족하도록 테이블을 분해하는것
- 제 3정규화 : 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것
- BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는것

> 정규화의 단점은 무엇인가요?
- 과도한 정규화는 성능 저하를 초래할 수 있으며, 복잡한 쿼리를 생성할 수 있습니다.
> 정규화와 반정규화의 차이점은 무엇인가요?
- 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 것이 목적이며, 반정규화는 성능 최적화를 위해 의도적으로 데이터 중복을 허용하는 과정입니다.

- https://datarian.io/blog/database-normalization

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
> 정의
- 역정규화(Denormalization)는 성능 최적화를 위해 의도적으로 정규화된 데이터베이스를 일부 비정규화하는 과정입니다. 이를 통해 데이터 조회 성능을 향상시키고, 복잡한 JOIN 연산을 줄일 수 있습니다. 주로 읽기 성능을 중시하는 시스템에서 사용됩니다.

> 역정규화의 단점은 무엇인가요?
- 데이터 중복이 증가하여 데이터 무결성이 저하될 수 있으며, 저장 공간이 더 많이 필요할 수 있습니다.
> 역정규화의 구체적인 예를 들어보세요.
- 고객 정보와 주문 정보를 하나의 테이블로 합쳐, 각 주문 조회 시 고객 정보를 함께 조회할 수 있도록 하는 것이 예입니다.
> 정규화와 역정규화의 균형을 어떻게 맞추나요?
- 시스템의 요구사항에 따라, 읽기 및 쓰기 성능, 데이터 무결성, 유지보수 용이성 등을 고려해 결정합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
- INNER JOIN: 두 테이블에서 공통적으로 존재하는 데이터 반환 ( 교집합 ) 
- LEFT JOIN: 왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환. 오른쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- RIGHT JOIN: 오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환. 왼쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- FULL JOIN: 양쪽 테이블에서 일치하는 모든 행을 반환하며, 일치하지 않는 행은 NULL

> SELF JOIN이란 무엇인가요?
- 자기 자신과의 JOIN을 의미하며, 같은 테이블의 다른 행을 연결하여 조회할 때 사용됩니다.
> CROSS JOIN이란 무엇인가요?
- 두 테이블의 모든 행 조합을 반환하는 JOIN입니다. 결과는 테이블의 곱(Cartesian Product)입니다.
> JOIN에서 ON과 USING의 차이점은 무엇인가요?
- ON은 모든 조건을 사용해 조인을 설정할 수 있으며, USING은 동일한 이름의 열에 대해 자동으로 조인을 설정합니다.


## GROUP BY와 HAVING의 차이점은 무엇인가요?
- GROUP BY는 결과 집합을 그룹화하는 데 사용되며, HAVING은 그룹화된 결과에 조건을 적용하는 데 사용됩니다.

> GROUP BY에서 COUNT와 함께 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;
> HAVING에서 COUNT를 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name HAVING COUNT(*) > 1;

## WHERE와 HAVING의 차이점은 무엇인가요?
- WHERE는 SQL 쿼리에서 개별 행에 대해 조건을 적용하여 필터링하고, HAVING은 GROUP BY 절로 그룹화된 결과에 조건을 적용하여 필터링합니다. WHERE는 그룹화 전에 필터링을 수행하고, HAVING은 그룹화 후에 필터링을 수행합니다.

> WHERE 절에서 사용할 수 없는 SQL 함수를 예로 들어보세요.
- 집계 함수(예: COUNT, SUM, AVG 등)는 WHERE 절에서 사용할 수 없고, HAVING 절에서 사용해야 합니다.
> HAVING을 WHERE 대신 사용하는 경우는 언제인가요?
- 집계된 데이터에 조건을 적용할 때 HAVING을 사용합니다.

## DISTINCT 키워드는 무엇을 하는가요?
- DISTINCT 키워드는 SELECT 문에서 사용하여 중복된 값을 제거하고 고유한 값을 반환합니다. 이를 통해 쿼리 결과에서 중복된 행을 제외하고 고유한 결과를 얻을 수 있습니다.

> DISTINCT와 GROUP BY의 차이점은 무엇인가요?
- DISTINCT는 중복된 값을 제거하여 고유한 결과를 반환하고, GROUP BY는 데이터를 그룹화하여 집계함수를 사용하는 데 주로 사용됩니다.
> DISTINCT를 사용하는 예를 들어보세요.
- SELECT DISTINCT column_name FROM table_name;

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
- 서브쿼리(Subquery)는 하나의 SQL 문 안에 포함된 또 다른 쿼리입니다. 
- 복잡한 계산이나 연산을 괄호로 묶어서 수행할 수 있음
- 서브 쿼리는 메인 쿼리의 속성을 그대로 받지만, 메인 쿼리에서는 서브 쿼리의 내용을 참조할 수 없음. 반대로 서브쿼리에서 메인 쿼리의 내용을 참조는 가능

> 종류
1. 스칼라 서브쿼리
   - SELECT 절에 위치하며 한 레코드당 하나의 값을 반환하는 서브쿼리(단일행, 단일컬럼을 반환)
   - 다중행 값 조회되면 "ORA-01427: single-row subquery returns more than one row" 오류 발생
2. 인라인 뷰
   - FROM 절에 위치하는 서브쿼리로 결과는 반드시 하나의 테이블로 리턴
   - 인라인 뷰는 SQL 문이 실행될때 임시적으로 생성되는 동적인 뷰
   - 단점 : SQL을 좀 더 빠른 속도로 사용하기 위한 것이지만, 잘못 사용하게 되면 액세스 속도를 저하 시키는 경우도 많음 
3. 중첩 서브쿼리
   - WHERE 절에 위치하며 메인쿼리 테이블의 특정 컬럼 값과 비교한 값을 반환하는 용도로 주로 사용
   - 단일행, 다중행 반환 가능 

> 서브쿼리와 JOIN 중 어느 것이 더 효율적인가요?
- 상황에 따라 다르지만, JOIN이 일반적으로 더 효율적일 수 있습니다.

## UNION과 UNION ALL의 차이점은 무엇인가요?
- UNION은 두 개의 SELECT 결과를 결합하여 중복된 행을 제거한 후 반환합니다. 반면, UNION ALL은 두 SELECT 결과를 결합하여 중복된 행을 포함한 모든 결과를 반환합니다.

> UNION을 사용한 쿼리의 예를 들어보세요.
- SELECT column_name FROM table1 UNION SELECT column_name FROM table2;
> UNION ALL을 사용하는 이유는 무엇인가요?
- 중복된 데이터를 포함한 전체 결과를 반환하려는 경우 사용합니다.
> UNION과 JOIN의 차이점은 무엇인가요?
- UNION은 두 개의 쿼리 결과를 수직으로 결합하는 반면, JOIN은 두 개의 테이블을 수평으로 결합합니다.

## EXISTS와 IN의 차이점은 무엇인가요?
> EXISTS
- 서브쿼리가 결과를 반환하는지 여부를 확인
- 서브쿼리가 하나 이상의 행을 반환하면 TRUE, 그렇지 않으면 FALSE 반환
- 메인 쿼리의 각 행에 대해 서브쿼리를 싱행하고, 조건을 만족하는 첫 번째 행을 찾으면 실행을 중단
- 서브쿼리가 결과를 반환할 수 있는지 여부만을 확인하므로, 서브쿼리 결과가 크더라도 비교적 효율적으로 작동
- 처리 순서 : 메인쿼리 -> 서브쿼리 
``` SQL
SELECT department_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.department_id);
```
> IN
- 서브쿼리가 반환한 결과 중 하나라도 메인 쿼리의 조건과 일치하는지 확인
- 서브쿼리에서 반환된 모든 값을 메모리에 로드한 후, 메인 쿼리의 각 행에 대해 서브쿼리 목록과 비교
- 반환하는 결과가 작은 경우에 효율적으로 작동
-  처리 순서 : 서브쿼리 -> 메인쿼리 
``` SQL
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1700);
```

> 어떤 상황에서 EXISTS를 사용하는 것이 IN보다 더 효율적인가요?
- 서브쿼리가 매우 큰 결과 집합을 반환하거나, 메인 쿼리와 서브쿼리의 테이블 간에 상관 관계가 있을 때 EXISTS를 사용하는 것이 더 효율적일 수 있습니다. EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 실행을 중지하기 때문에, 서브쿼리의 결과가 클 때 성능이 더 좋습니다. 또한, 서브쿼리가 인덱스된 열에 대해 실행될 때 EXISTS가 더 효율적으로 동작할 수 있습니다.
>  IN 연산자를 사용할 때 주의해야 할 점은 무엇인가요?
- IN 연산자를 사용할 때 주의해야 할 점은 서브쿼리가 반환하는 결과 목록이 너무 크지 않도록 하는 것입니다. 서브쿼리의 결과가 큰 경우 성능이 저하될 수 있습니다. 또한, IN 연산자 사용 시 NULL 값을 포함한 비교가 이루어질 때 결과가 예상과 다를 수 있으므로, NULL 처리에 유의해야 합니다. NULL 값이 포함된 경우, 비교 연산에서 불확실성을 초래할 수 있습니다.
  
## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
- 여러 행으로부터 하나의결과값을 반환하는 함수. 
> 종류 
- COUNT: 행의 개수를 반환
- SUM: 열의 합계를 반환
- AVG: 열의 평균값을 반환
- MIN: 열의 최소값을 반환
- MAX: 열의 최대값을 반환

> COUNT와 DISTINCT를 함께 사용하는 방법은 무엇인가요?
- SELECT COUNT(DISTINCT column_name) FROM table_name;
> 집계 함수에서 NULL 값은 어떻게 처리되나요?
- 대부분의 집계 함수는 NULL 값을 무시합니다. 그러나 COUNT(*)는 NULL 값을 포함합니다.
> 집계 함수를 GROUP BY와 함께 사용하는 예를 보여주세요.
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;


## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
- 하나 이상의 테이블을 기반으로 생성된 가상의 테이블
- 실제 데이터를 저장하지 않고 기본 테이블의 데이터를 조회할 수 있는 SQL 쿼리의 결과를 저장한 논리적 구조
- 복잡한 쿼리를 단순화하고, 특정 데이터를 쉽게 조회하거나 보안을 강화하기 위해 사용

> 장점
- 사용자가 접근할 수 있는 데이터를 제한하여 보안 강화
- 자주 사용하는 복잡한 쿼리를 뷰로 정의해 두면 간단한 SELECT 문으로 동일한 결과 반환 가능
- 특정 데이터를 표준화된 방식으로 제공함으로써 여러 사용자에게 일관된 데이터를 사용할 수 있게 함
- 동일한 뷰를 여러 쿼리에서 사용하므로 코드의 중복을 줄이고, 유지보수 쉽게 가능

> 단점
- 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 복잡한 뷰나 조인이 많은 뷰는 성능 저하를 초래할 수 있음
- 데이터의 삽입, 수정, 삭제하는것이 제한
- 기본 테이블의 구조가 변경되면 오류가 발생할 수 있어 유지보수 필요

> VIEW가 기본 테이블에서 데이터를 가져올 때 실시간으로 쿼리를 실행하는데, 이로 인해 어떤 문제점이 발생할 수 있나요?
- VIEW는 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 기본 테이블이 큰 경우 또는 VIEW가 복잡한 조인을 포함하는 경우 성능 문제가 발생할 수 있습니다. 특히, 여러 테이블을 조인하거나 중첩된 VIEW를 사용하는 경우 쿼리 실행 시간이 길어질 수 있으며, 전체 시스템 성능에 부정적인 영향을 미칠 수 있습니다.


## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- CASE문은 SQL에서 조건에 따라 다른 값을 반환할 수 있도록 하는 조건부 표현식
  
```` SQL
SELECT column_name,
       CASE
           WHEN 조건1 THEN 결과1
           WHEN 조건2 THEN 결과2
           ELSE 결과3
       END AS new_column_name
FROM table_name;
````

> CASE문을 사용하여 집계 데이터를 구분하는 예를 들어보세요.
- SELECT SUM(CASE WHEN column_name > 100 THEN 1 ELSE 0 END) FROM table_name;

> CASE 문을 사용해서 조건부로 데이터를 업데이트할 수 있나요?
```SQL
UPDATE employees
SET bonus = CASE
               WHEN salary > 100000 THEN salary * 0.1
               WHEN salary BETWEEN 50000 AND 100000 THEN salary * 0.05
               ELSE 0
           END;
```

# 인덱스
## 인덱스란 무엇인가요?
> 인덱스란?
- 데이터베이스에서 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조

> 인덱스 생성 컬럼을 where 조건으로 걸었을 경우의 동작 과정
1. 쿼리 작성 후 실행
2. 쿼리 옵티마이저(query optimizer)가 쿼리 처리 시작.
- 옵티마이저 : 가장 효율적인 방법으로 SQL을 수행할 최적의 쿼리실행 계획을 생성해주는 DBMS의 핵심 엔진 ( DBMS의 두뇌는 옵티마이저 )
- 옵티마이저는 쿼리에서 사용된 where 조건의 컬럼에 인덱스가 존재하는지 확인
- 테이블과 인덱스에 대한 통계를 참조하여, 인덱스를 사용하는것이 효율적인지 판단
- 옵티마이저는 여러 실행 계획에 대한 비용(리소스) 계산
3. 다양한 실행 계획을 평가한 옵티마이저는 인덱스를 사용하는것이 효율적이라고 판단되면, 인덱스를 사용하는 계획 선택
4. 인덱스를 사용한 데이터 검색
5. 데이터베이스는 조건을 만족하는 행을 찾은 후, 메모리에 로드하고, 데이터를 추출하여 사용자에게 반환

> 인덱스가 없는 경우에 데이터베이스는 데이터를 어떻게 검색하나요?
- 인덱스가 없는 경우에는 테이블의 모든 행을 순차적으로 스캔하여 조건에 맞는 데이터를 찾습니다. (FUll Scan) 대규모 데이터에서는 매우 비효율적일수 있음


## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?
> 클러스터드 인덱스
- 클러스터드 인덱스는 테이블의 실제 데이터가 인덱스 키 값에 따라 정렬된 상태로 저장
- 테이블의 행들이 인덱스 순서대로 물리적으로 정렬
- 1개 테이블에는 1개의 클러스터드 인덱스만 생성 가능
  - 장점
     + 데이터가 물리적으로 정렬되어 있어 범위 검색에 효율 좋음
  - 단점
     +  데이터 삽입, 삭제, 업데이트 경우 데이터의 물리적 위치를 변경해야 하므로 오버헤드 발생

> 넌클러스터드 인덱스 
- 넌클러스터드 인덱스는 테이블과는 별도로 저장
- 인덱스에는 인덱스 키와 해당 키에 대응하는 데이터의 위치가 저장
- 1개의 테이블에는 여러개의 넌클러스터드 인덱스 생성 가능
  - 장점
      + 특정 열, 열의 조합에 대한 검색 성능 향상
      + 여러개의 인덱스 생성 가능
  - 단점
      + 테이블의 데이터와 별도로 저장되므로 추가적인 저장 공간 필요
      + 데이터의 실제 위치를 가리키는 포인터를 사용하므로 클러스터드 인덱스에 비해 검색 성능이 떨어질수 있음 

> 클러스터드 인덱스와 넌클러스터드 인덱스 선택 기준은?
- 예 ) ORDERS 테이블 : orderId, customerId, orderDate, totalAmount
- orderDate 컬럼에 각 인덱스를 생성해주었을 경우, 둘다 특정 상황에서 빠를수 있다.
- 즉, 쿼리 패턴과 요구사항 패턴에 따라서 클러스터디 인덱스와 넌클러스터드 인덱스를 선택해야함
- 클러스터드 인덱스가 좋은 경우 : 클러스터드 인덱스는 범위 내의 모든 데이터를 물리적으로 연속된 블록에서 읽으므로 맑은 양의 데이터를 조회할때 유리. 그러므로 orderDate에 대한 검색이 빈번하고, 다른 컬럼의 검색의 패턴이 적을때 사용 
- 넌클러스터드 인덱스가 좋은 경우 : 여러 컬럼과의 검색 패턴이 많다면 넌클러스터드 인덱스 생성이 좋을 수 있다. 

## 인덱스를 언제 사용하는 것이 적합한가요?
- 데이터가 많아지면서 데이터 검색에 시간이 오래 걸리는 경우
- where, join, order by, group by 절에서 자주 사용되는 컬럼에 대해 인덱스 설정시 성능 향상

> 인덱스가 불필요한 경우는 ?
- 테이블에 데이터가 적거나, select가 빈번하게 발생하지 않는 경우
  
## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?
- 테이블 조회, 정렬 성능은 향상 시킬수 있지만, 데이터 삽입, 수정, 삭제 시에는 인덱스를 갱신해야하므로 성능이 저하될수 있음

## 인덱스의 구조는 무엇인가요? (예: B-Tree)
> B-Tree
- 균형 트리 구조
- 데이터가 정렬된 상태로 저장
- 검색, 삽입, 삭제 작업이 모두 효율적이고, 범위 검색이나 순차적 접근이 필요한 경우 적합
> B+Tree
- B-Tree 변형으로 리프 노드만이 실제 데이터를 포함
- 리프 노드들이 연결리스트로 연결되어 있어 범위 검색이 더 효율적
- 대부분 관계형 데이터베이스에서 기본 인덱스 구조로 사용
> Hash 인덱스
- 해시 함수를 사용하여 키 값을 계산하고, 해당 위치에 데이터를 저장하거나 검색
- 특정 값 검색에는 유리하지만, 범위 검색에는 적합하지 않음
> Bitmap 인덱스
- 각 열의 값을 비트맵으로 표현하여 저장
- 특정 컬럼에 다양한 값이 많지 않고 데이터 중복이 많은 경우에 적합
- OLAP (Online Analytical Processing) 시스템에서 대량의 데이터에 대한 복합 조건 처리시에 자주 사용
> GiST (Generalized Search Tree) 인덱스
-  다양한 데이터 유형( 공간 데이터, 텍스트 데이터 )을 검색하기 위해 설계된 범용 트리 구조
-  복잡한 검색 조건에 적합
-  PostgreSQL 에서 많이 사용 
> GIN (Generalized Inverted Index)
- 주로 텍스트 검색과 같이 각 값이 여러 요소로 구성된 데이터에 대한 검색을 최적화하는 인덱스 구조
- 문서 검색에서 특정 단어를 빠르게 찾기 위해 사용
- 비정형 데이터, 배열 데이터에 대한 검색시 사용
> R-Tree
- 공간 데이터(GIS)에서 사용하는 구조
- 2차원 이상의 데이터에 최적화
- 데이터의 공간적 관계를 트리 구조로 표현, 범위 질의나 like 검색에 효율적 
> Full-Text 인덱스
- 텍스트 데이터에서 단어나 구문을 검색하기 위해 설계된 인덱스
- 대량의 텍스트 데이터를 다루는 애플리케이션에서 많이 사용 
> Suffix Tree/Array
- 문자열 검색에 특화된 인덱스 구조
- 특정 패턴이 문자열에서 어디에 있는지에 대한 검색에 효율적
- DNA서열 분석, 텍스트 편집기에 사용
> Trie 인덱스
- 문자열의 공통 접두사를 이용해 데이터를 정리하는 트리 구조
- 사전식 문자열 검색, 자동 완성 기능을 구현하는데 적합
> Inverted 인덱스
- 문서에서 단어와 같은 요소들이 어느 위치에 나타나는지 매핑하여 저장하는 구조
- 덱스트 검색 엔진에서 주로 사용

> B-Tree vs B+Tree
1. 검색 방법 : 데이터를 검색할 때 항상 리프 노드까지 이동하므로 검색 경로가 단순
- B-Tree : 모든 노드(internal node + leaf node)에 키와 값이 함께 저장
- B+Tree : internal 노드에는 키만 저장, leaf 노드에는 키와 값 저장

2. 포인터 사용 
- B-Tree : internal노드의 포인터를 통해서만 리프 노드로 이동 가능
- B+Tree : leaf 노드끼리 서로 연결 리스트로 연결되어있음

3. 범위 쿼리와 범위 검색
- B-Tree : 범위 쿼리를 수행하려면 트리의 루트에서부터 리프 노드 까지 이동하면서 전체 데이터 함께 조회
- B+Tree : 데이터는 리프 노드에만 존재하므로, 범위 쿼리는 리프 노드를 시작으로 연결된 리스트를 따라가면 모든 데이터 조회 가능
4. 순차 탐색 및 정렬
- B-Tree: 순차적인 탐색이나 정렬을 위한 추가적인 알고리즘이 필요해서 (예. inorder traversal) B+Tree보다 더 복잡
- B+Tree: 연결된 리스트를 따라가면서 순차 탐색이 용이하며, 키들은 항상 정렬된 상태를 유지하면서 저장
5. 메모리 사용
- B-Tree: 리프 노드와 내부 노드가 각각 데이터와 포인터까지 가지고 있기 때문에 B+Tree보다 더 많은 메모리 공간을 차지
- B+Tree: 데이터는 리프 노드에만 저장되고, internal 노드는 키만 갖고 있으면 되므로, 메모리 효율이 좋음

https://engineerinsight.tistory.com/336#%E2%9C%94%EF%B8%8F%C2%A0B-Tree%20vs%20B%2BTree-1

## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?
- 테이블에 로우를 추가했을때, 해당 테이블에 설정되어 있는 인덱스의 기준에 맞춰 정렬 작업이 필요한데, 여러개의 인덱스가 존재할 경우 생성된 인덱스 만큼의 B-Tree 구조에 데이터가 추가되며, 트리 구조의 재배치 작업이 발생하게 되므로 성능적으로 영향을 줄 수 있음
- 인덱스도 생성시에 인덱스 테이블을 생성하므로 너무 많은 인덱스 생성시 그만큼의 메모리를 차지하게됨
- 데이터 수정 작업시 오버헤드가 증가하고, 옵티마이저가 잘못된 실행계획을 선택할 수 있음
  
## Composite Index(복합 인덱스)란 무엇인가요?
- 2개 이상의 컬럼을 결합하여 만든 인덱스

> 복합 인덱스를 사용하는 이유는?
- 특정 쿼리에서 2개 이상의 컬럼이 결합되어 자주 사용될때 복합 인덱스로 사용하면 유리
  
## 인덱스 설계 시 주의해야 할 점은 무엇인가요?
- 프로세스나 요구사항에 따른 패턴을 분석하여 자주 사용되는 컬럼을 파악
- 중복되지 않은 값이 많은 컬럼
- 조건절에서 자주 사용되는 컬럼 순
- 데이터의 변경 빈도가 낮은 컬럼
  
## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?
> index rebuild
- 기존 인덱스를 삭제하고 새로운 인덱스를 만들어 데이터를 정렬
- 리소스를 많이 사용하며, 작업 도중에 테이블에 대한 lock이 발생할 수 있음
- 인덱스 단편화가 심한 경우에 사용하는 것이 좋음 
> index reorganize
- 기존 인덱스를 유지하면서 페이지를 정렬하고 공간을 재활용
- 리소스 사용이 상대적으로 적으며, 데이터베이스 성능에 큰 영향을 주진 않음
- 인덱스 단편화가 비교적 적은 경우에 사용하는 것이 좋음

> rebuild, reorganize를 사용하는 이유
- 데이터베이스 인덱스는 데이터의 삽입, 삭제, 수정으로 인해 단편화(Fragmentation)이 발생할 수 있음. 단편화가 발생하면 인덱스의 성능이 저하될수 있으므로 rebuild, reorganize 작업을 수행
- 단편화 : 데이터 페이지가 비효율적으로 사용되며, 인덱스 검색 시 추가적인 I/O가 발생하는 상황


## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?
> 정의 
- 힌트는 쿼리에서 특정 인덱스를 강제로 사용하도록 지정하는 방법
> 사용하는 경우
- 옵티마이저가 쿼리의 실행계획을 생성할 때 잘못된 인덱스를 선택할때
- 대규모 데이터를 가진 테이블에서 full scan이 발생하는 것을 방지할때

# 트랜잭션 및 동시성 제어

## 트랜잭션의 고립 수준(Isolation Level)에 대해 설명해주세요.
https://tlatmsrud.tistory.com/118
> 정의
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 격리되어 있는가에 대한 수준
- DBMS 마다 격리 수준에 대한 내용은 다를 수 있음
  
> 4가지 Isolation level ( 격리 수준이 낮은순 -> 격리 수준이 높은순 ) 
1. Read UnCommitted
- 트랜잭션에서의 변경 내용이 commit, rollback 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있음
- 정합성에 문제가 많은 격리 수준이므로 일반적으로 사용하지 않음
- Dirty Read 발생 : 커밋되지 않은 트랜잭션에 접근하여 부정합을 일으킬 수 있는 데이터를 읽는 것
  
2. Read Committed
- 다른 트랜잭션에서 commit 된 데이터만 접근 할 수 있게 하는 격리 수준
- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
- Dirty Read 같은 현상은 발생하지 않지만, Non-Repeatable read 발생
- Non-Repeatable read : 하나의 트랜잭션 내에서 동일한 select 쿼리 실행했을때, 항상 같은 결과를 보장해야하는 Repeatable read 정합성에 어긋나는것
- 예) 1번 트랜잭션과 2번트랜잭션이 있을 경우, 1번 트랜잭션에서 '바나나' 데이터를 '바나'로 update 이후에 커밋을 하기 전 시점에서 2번 트랜잭션이 '바나나'라는 데이터를 조회시에는 1번 트랜잭션이 update 하기 전 데이터인 '바나나'가 조회된다. Dirty read는 발생하지않는다. 원리는 무엇인가?
  + 2번 트랜잭션이 트랜잭션에 대한 로그 중 하나인 Undo영역에 있는 데이터를 읽어오기 때문.
  + Undo 영역 : 변경 전 데이터가 저장된 영역
  
3. Repeatable read
- Non Repeatable Read 문제를 해결하는 격리 수준으로 커밋된 데이터만 읽을 수 있되 자신보다 낮은 트랜잭션 번호를 갖는 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준
- MySQL, MariaDB 에서 기본으로 사용하는 격리 수준

4. Serializable
- 가장 고수준의 격리 수준으로 트랜잭션을 무조건 순차적으로 진행
- 트랜잭션이 중간에 끼어들수 없어서 데이터의 부정합은 발생하지 않지만, 동시 처리가 불가능하여 처리 속도가 느려짐

> 드랜잭션 격리 수준이 성능에 미치는 영향은?
- 격리 수준이 높아질수록 데이터 무결성은 높아지지만, 처리 서능은 저하 될 수 있음

## Dirty Read, Non-repeatable Read, Phantom Read에 대해 설명해주세요.
>  Dirty Read
- commit 되지 않은 데이터를 다른 트랜잭션에서 select 했을때 발생하는 현상
- 2번 트랜잭션에서 아직 실행이 끝나지 않은 1번 트랜잭션에 의한 변경사항을 보게 되는 경우
- Read Uncommitted 수준일때 발생
>  Non-repeatable Read
- 1번 트랜잭션에서 같은 쿼리를 2번 실행할 때 그 사이에 2번 트랜잭션이 값을 update, delete 하면서 1번이 실행한 2개의 쿼리의 결과의 일관성이 깨진 현상
- Read Committed, Read Uncommitted 수준일 때 발생
>  Phantom Read
- 한 트랜잭션 안에서 일정 범위의 레코드를 2번 이상 select 했을때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에 나타나는 현상
- 트랜잭션 도중 새로운 레코드 insert를 허용하기 때문에 나타나는 현상
- Read Committed, Read Uncommitted, Repeatable read 수준일 때 발생

> 트랜잭션 격리 수준에서 insert 쿼리를 막지 않는 이유는?
- 트랜잭션의 격리 수준은 주로 트랜잭션 간의 select 에서 발생하는 데이터의 일관성을 보장하는데 중점을 가짐 
- insert를 아예 막는다면, 시스템의 유연성이 저하되고, 트랜잭션이 차단되어 성능 문제가 발생 할 수 있음
- 데이터베이스의 동시성을 최대한 유지하기 위해, 격리 수준을 조절하여, Phantom read 와 같은 문제를 해결하거나 완화하는 방법을 사용

## 트랜잭션의 전파(Propagation)에 대해 설명해주세요.
> 정의
- 하나의 트랜잭션이 다른 트랜잭션과 어떤 기준을 가지고 실행할지를 정의하는 방식
> 옵션
1. REQUIRED
- 현재 트랜잭션이 있으면 이를 사용하고, 없으면 새로운 트랜잭션 실행
2. REQUIRES_NEW
- 트랜잭션의 존재 여부와 관계없이 무조건 새로운 트랜잭션을 생성
- 기존 트랜잭션이 존재한다면, 기존 트랜잭션을 보류하고, 새로운 트랜잭션 생성
- 서로 각각의 디비 커넥션을 가짐. 롤백시 서로의 트랜잭션에 영향을 주지 않음
- 서로 독립적이지만, 동시에 실행되지않는 이유는 데이터의 일관성과 관리의 복잡성을 줄이기 위함
- 사용 사례 : 로그 기록을 위해 REQUIRES_NEW 사용하는 경우
3. NESTED
- 기존 트랜잭션이 없으면 새로운 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 중첩 트랜잭션을 생성
- 중첩 트랜잭션으로, 부모와 자식의 개념이 있으며 커밋시점은 부모 트랜잭션이 완료될때이고, 부모 트랜잭션에서 롤백이 발생하면 자식 트랜잭션에서도 롤백이 발생
4. MANDATORY
- 반드시 기존 트랜잭션 내에서 실행되어야 하며, 트랜잭션이 없으면 IllegalTransactionStateException 예외 발생
5. SUPPORTS
- 트랜잭션이 있으면, 트랜잭션 내에서 실행되고, 없으면 트랜잭션 없이 실행
6. NOT_SUPPORTED
- 트랜잭션이 존재하면 이를 일시 중단하고, 트랜잭션 없이 실행
7. NEVER
- 어떤 경우에도 트랜잭션을 생성하지 않음


## 낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?
> 낙관적 잠금(Optimistic Locking)
- 자원에 lock을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리하자는 방법론
- 여러 트랜잭션이 동일한 데이터에 업데이트를 시도할 수 있고, 커밋할 때 유효성 검사
- 데이터베이스 단에서 동시성 처리하는 것이 아닌, Application 레벨에서 개발자가 롤백 처리
- 동시 레코드 업데이트 빈도가 적거나, lock 오버헤드가 높은 것으로 예상될때 사용 

> 비관적 잠금(Pessimistic Locking)
- 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법
- 데이터에 대한 동시 업데이트 방지
- 데이터베이스 레벨에서 동작, SQL 쿼리에서 SELECT FOR UPDATE 구문 또는 LOCK 구문을 통해 구현
- 강력한 동시성 제어를 제공하지만, LOCK이 길어질 경우 성능 저하와 교착 상태 발생 가능성 있음


## 트랜잭션에서 발생할 수 있는 동시성 문제에는 어떤 것들이 있나요?
> Dirty read
- 하나의 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 상황
> Non-repeatable read
- 동일한 트랜잭션 내에서 같은 데이터를 2번 읽었을때, 다른 트랜잭션이 중간에 데이터를 수정, 삭제하여 select 결과가 다르게 나타나는 상황
> Phantom read
- 트랜잭션이 동일한 쿼리를 여러번 실행할때, 다른 트랙잭션이 중간에 새로운 로우를 삽입, 삭제했을 경우 결과 로우 수가 달라지는 현상 
> Lost update
- 2개의 트랜잭션이 동일한 데이터를 동시에 수정할때, 한 트랙잭션의 수정 내용이 다른 트랜잭션에 의해 수정 내용이 사라지는 현상
> Write Skew (쓰기 편향)
- 두개의 트랜잭션이 서로 다른 데이터를 읽고, 그 데이터를 기반으로 조건에 맞게 데이터를 수정할때 발생하는 문제. 


## Deadlock이란 무엇이며, 이를 방지하는 방법은 무엇인가요?
> 정의
- 두개 이상의 트랜잭션이 서로가 필요로 하는 자원을 점유하고 있어, 각각의 트랜잭션이 자원의 해제를 기다리며 무한 대기 상태로 빠지는 상황

> 방지 방법
1. 예방 기법
- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 lock 한다 -> 병행성이 떨어짐
- lock_timeout을 통해 일정 시간이 지나면 lock을 해제 -> 근복적인 해결책은 아님
2. 회피 기법
- 자원을 할달할 때 time stamp를 활용해서 교착상태가 일어나지 않도록 회피하는 방법
- wait-die 방식
  + 트랜잭션 A가 트랜잭션 B에 의해 lock된 자원을 요청할 때 트랜잭션 A가 먼저 들어온 트랜잭션이라면 A는 대기(wait)
  + 트랜잭션 A가 나중에 들어온 트랜잭션이라면 중단(die)하고 나중에 다시 요청
- wound-wait 방식
  + 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 자원을 선점(wound)
  + 트랜잭션 A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(wait)
- 시나리오 예시
``` 
트랜잭션 A는 10초에 시작되었습니다. (타임스탬프 = 10)
트랜잭션 B는 20초에 시작되었습니다. (타임스탬프 = 20)
트랜잭션 A와 트랜잭션 B는 각각 자원 X와 자원 Y에 접근하려고 합니다. 초기에는 자원 X와 자원 Y는 모두 사용 중이지 않다고 가정합니다.

상황: 트랜잭션 A가 자원 X를 점유하고, 트랜잭션 B가 자원 Y를 점유한 상태에서 서로 상대방의 자원을 요청할 때 발생하는 상황

1. Wait-Die 방식
10초: 트랜잭션 A가 시작되어 자원 X를 점유합니다. (타임스탬프 A = 10)
20초: 트랜잭션 B가 시작되어 자원 Y를 점유합니다. (타임스탬프 B = 20)

이제 트랜잭션 A는 자원 Y를, 트랜잭션 B는 자원 X를 필요로 하게 됩니다.

트랜잭션 A가 자원 Y를 요청:

트랜잭션 A는 타임스탬프가 10이고, 자원 Y를 이미 점유한 트랜잭션 B의 타임스탬프는 20입니다.
트랜잭션 A의 타임스탬프가 더 작으므로, 트랜잭션 A는 **대기(wait)**하게 됩니다.
트랜잭션 B가 자원 X를 요청:

트랜잭션 B의 타임스탬프는 20이고, 자원 X를 이미 점유한 트랜잭션 A의 타임스탬프는 10입니다.
트랜잭션 B의 타임스탬프가 더 크므로, 트랜잭션 B는 **중단(die)**됩니다. 트랜잭션 B는 롤백되고 나중에 다시 시도할 수 있습니다.
결과: 트랜잭션 A는 대기 상태로 유지되며, 트랜잭션 B는 중단됩니다. 나중에 트랜잭션 A가 완료되면 트랜잭션 B가 다시 실행됩니다.

2. Wound-Wait 방식
10초: 트랜잭션 A가 시작되어 자원 X를 점유합니다. (타임스탬프 A = 10)
20초: 트랜잭션 B가 시작되어 자원 Y를 점유합니다. (타임스탬프 B = 20)

트랜잭션 A는 자원 Y를, 트랜잭션 B는 자원 X를 필요로 하게 됩니다.

트랜잭션 A가 자원 Y를 요청:

트랜잭션 A는 타임스탬프가 10이고, 자원 Y를 점유한 트랜잭션 B의 타임스탬프는 20입니다.
트랜잭션 A의 타임스탬프가 더 작으므로, 트랜잭션 A는 트랜잭션 B를 **중단(wound)**시키고 자원 Y를 획득합니다.
트랜잭션 B는 롤백되고, 나중에 다시 시도할 수 있습니다.
트랜잭션 B가 자원 X를 요청:

트랜잭션 B의 타임스탬프는 20이고, 자원 X를 점유한 트랜잭션 A의 타임스탬프는 10입니다.
트랜잭션 B의 타임스탬프가 더 크므로, 트랜잭션 B는 **대기(wait)**합니다.
결과: 트랜잭션 A는 트랜잭션 B를 중단시키고 자원 Y를 획득합니다. 트랜잭션 B는 나중에 다시 시도할 수 있습니다.

```
3. 낙관적 병행 제어 기법
- 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백하는 방법

4. 교착상태 빈도 줄이기
-  자원 할당 순서 지정
-  자원 요청과 해제의 순서를 일관되게 유지
-  트랜잭션이 처리하는 작업의 범위를 작게 유지

## 트랜잭션 로그(Transaction Log)란 무엇인가요?
- 데이터 베이스 시스템에서 트랜잭션의 모든 변경 사항을 기록하는 파일
- 데이터베이스의 복구 및 일관성을 유지하는데 중요
- 데이터베이스에 대한 변경 사항이 커밋되기 전에 로그 파일에 먼저 기록되며, 시스템 장애시 로그를 이용해 복구 가능
- 저장되는 정보 : 트랜잭션 id, 타임스탬프, 변경된 데이터의 위치

## 데이터베이스 커밋과 롤백의 차이`점은 무엇인가요?
> Commit
- 트랜잭션에서 수행된 모든 변경 사항을 영구적으로 데이터베이스에 반영하는 작업
> Rollback
- 트랜잭션에서 수행된 모든 변경사항을 취소하고, 트랜잭션이 실행되기 전 상태로 되돌리는 작업

## 트랜잭션 타임아웃이란 무엇인가요?
- 트랜잭션이 일정 시간내에 완료되지 않으면, 자동으로 롤백되도록 설정된 시간 제한
- 교착상태나 무한 대기 상태를 방지하기 위해 사용

## 분산 트랜잭션이란 무엇이며, 이를 관리하는 방법은 무엇인가요?
> 분산 트랜잭션
- 하나의 트랜잭션이 여러 시스템(데이터베이스)에 걸쳐서 수행되는 경우
- 트랙잭션의 일관성과 원자성을 유지하기 위해 트랜잭션 코디네이터가 모든 자원 관리자를 조율

> 관리하는 방법 
1. Two-Phase Commit (2PC) 프로토콜
- 트랜잭션 코디네이터가 모든 자원 관리자와 협력하여 트랜잭션의 원자성 보장
- 2가지 주요 단계(Prepare 단계, 커밋/롤백 단계)를 통해 분산 트랜잭션 조율
- 네트워크 지연 또는 자원 관리자의 응답 지연으로 인해 트랜잭션이 오랜시간 대기할 수 있음
2. XA 트랜잭션
- 여러 자원 관리자가 하나의 트랜잭션에서 원자성을 유지할 수 있도록 지원
- XA 트랜잭션은 대부분 상용 데이터 베이스 시스템에서 지원되며, 2PC프로토콜 기반으로 동작
- 트랜잭션 관리자와 자원 관리자의 상호작용이 복잡해지고, 네트워크 오버헤드가 발생할 수 있음
3. Saga 패턴
- Choreography 방식
  + 각 서비스가 독립적으로 이벤트를 처리하며, 중앙 관리자가 없으므로 유연하지만 관리가 어려움
- Orchestration 방식
  + 중앙 관리자가 트랜잭션의 흐름을 제어하며, 복잡한 트랜잭션을 쉽게 관리할 수 있지만, 시스템 복잡도가 높음
  
> Two-Phase Commit (2PC) 프로토콜, XA 트랜잭션 의 차이점
- 둘다 분산 트랜잭션에서 여러 자원 관리자를 조욜하여 트랜잭션의 원자성을 보장하는데 사용되지만, 적용하는 범위와 구체적인 구현에 차이점 존재
- 2PC 프로토콜은 모든 자원이 준비되면 커밋하고, 하나라도 안되면 롤백하라는 규치이고, XA 트랜잭션은 2PC 프로토콜을 포함하여 여러 자원 관리자들이 서로 협력하여 트랜잭션을 처리할 수 있게 만드는 시스템
--> 이거 다시 이해하기!

## 커버링 인덱스(Covering Index)란? 
- 인덱스가 쿼리에서 필요한 모든 컬럼을 포함하고 있어서 데이터 페이지로 추가적인 접근 없이 인덱스만으로 쿼리 결과를 처리할 수 있는 경우.
- I/O 작업을 줄이고 쿼리 성능을 향상 시킬수 있음

## 카디널리티가 높은것과 낮은것의 차이는? 
> 카디널리티(Cardinality)
- 데이터베이스에서 특정 컬럼에 저장된 데이터의 고유 값의 수를 나타내는 용어 
> 카디널리티가 높은 경우
- 특정 컬럼에 저징된 데이터의 값이 다양하고, 고유값이 많은 경우
- 예) 테이블의 ID값, 주민번호 등
- 카디널리티가 높은 컬럼은 인덱스 효율이 높을 수 있고, 검색 시에 특정 값을 빠르게 찾을 수 있음
> 카디널리티가 낮은 경우
- 특정 컬럼에 저장된 값이 제한적이고, 중복된 값들이 많은 경우
- 예) 성별, 부서
- 카디널리티가 낮은 컬럼을 인덱스로 사용하면 오히려 성능 저하를 일으킬 수 있음 

## 복합인덱스와 단일 인덱스로 인덱스가 생성되어 있는 컬럼을 where 절에 동시에 실행시 어떤게 성능이 더 빠른가? 
- 

## join이 걸린 컬럼에는 왜 인덱스를 걸어줘야하는가? 
## 인덱스에서 페이지와 노드란? 

## 인덱스 구조는 db 종류마다 다른가? 그리고 인덱스 구조는 인덱스 종류에 따라서 어떻게 지정되는건가요? 


# 성능 최적화 및 쿼리 튜닝 ( 9월 14일) 

## 쿼리 튜닝(Query Tuning)이란 무엇인가요?
> 쿼리 튜닝이란?
- 데이터베이스 성능을 최적화하기 위해 SQL 쿼리를 분석하고 최적화 하는 과정으로 쿼리의 실행시간을 줄이고, 리소스 사용을 최소화하며, 시스템의 전반적인 응답 속도를 개선하는 과정.

> 쿼리 튜닝의 방법
- 인덱스 최적화, 쿼리 구조 개선, 조인 최적화, 쿼리 캐싱, 파티셔닝, 실행 계획 분석 등이 존재 

## 쿼리 실행 계획(Execution Plan)이란 무엇이며, 이를 분석하는 방법을 설명해주세요.
https://harris91.vercel.app/query-plan

> 쿼리 실행 계획
- 쿼리가 실행될 때 데이터베이스가 어떤 방식으로 데이터를 검색하고 처리할지에 대한 정보와 함께, 데이터베이스 옵티마이저가 선택한 가장 효율적인 실행 경로를 제공
- 조인의 순서, 사용된 인덱스, 테이블 스캔 여부 등의 정보를 포함
- 데이터베이스 종류 마다 실행계획 항목이 다를 수 있음

``` SQL
-- 실행계획 수집
EXPLAIN PLAN FOR 
SELECT first_name, last_name 
FROM employees 
WHERE department_id = 10 
AND salary > 5000;
-- 실행계획 조회 
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

------------------------------------------------------------------------------------
| Id  | Operation                    | Name                  | Rows  | Bytes | Cost |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                       |   10  |   260 |   5  |
|   1 |  TABLE ACCESS BY INDEX ROWID | EMPLOYEES             |   10  |   260 |   5  |
|*  2 |   INDEX RANGE SCAN           | IDX_EMP_DEPT_SALARY   |   10  |       |   3  |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
2 - access("DEPARTMENT_ID"=10 AND "SALARY">5000)

```

> 실행 계획 항목
1. id
- 쿼리의 각 단계를 식별하는 고유한 번호
- 쿼리의 실행 순서 파악할 수 있음
- 같은 값이면, 순서가 상관없이 병렬로 실행될수 있는 작업을 의미
2. Operation
- 데이터베이스가 쿼리를 처리하기 위해 수행하는 작업 유형
- 작업 유형이 효율적인지, 인덱스가 제대로 사용되고 있는지 확인
- 항목 예시 
  + TABLE ACCESS FULL: 테이블 전체를 스캔.
  + INDEX RANGE SCAN: 인덱스 범위를 지정하여 데이터에 접근.
  + INDEX FULL SCAN: 인덱스의 모든 항목을 스캔.
  + INDEX UNIQUE SCAN: 유니크 인덱스를 사용하여 단일 행을 반환.
  + SORT ORDER BY: ORDER BY 절에 따라 데이터를 정렬
  + NESTED LOOPS: 하나의 테이블에서 데이터를 읽고, 그 데이터를 다른 테이블과 비교하는 반복 작업 (Nested Loops Join)
  + HASH JOIN : 대규모 데이터셋에서 두 테이블을 해시 테이블로 변환하여 효율적으로 조인. 정렬이나 인덱스 필요하지않음
  + MERGE JOIN : 두 테이블이 정렬된 상태에서 병합하여 조인.
3. Name
- 테이블 , 인덱스 이름
4. Rows
- 각 단계에서 처리될 것으로 예상되는 행의 수
- 행의 수가 많은 경우 성능 병목 지점이 될수 있으므로 최적화 필요
5. Cost
- 각 작업의 상대적인 비용 , DBMS가 계산한 결
- 비용이 높은 작업을 식별해서 최적화 해야함
6. Predicate Information
- WHERE 절과 같은 필터 조건이 어떻게 적용되는지 나타내는 항목
- 항목 예시
    + FILTER: 인덱스를 사용하지 않고, 테이블의 모든 행을 스캔한 후 조건에 맞는 데이터를 필터링할 때 사용
    + ACCESS : 인덱스를 사용해 조건을 만족하는 데이터를 검색할 때 사용
- ex) 2 - access("DEPARTMENT_ID"=10 AND "SALARY">5000)
    + 2 : 실행계획의 id에 해당하는 작업 ( INDEX RANGE SCAN )
    + access : 이 작업이 인덱스에 접근할 때 사용하는 조건

> 분석 방법 ( oracle )
1. 전체 구조 이해
- 실행 계획읜 순서 파악 (id 값)
2. 비효율적인 작업 식별
- Operation 항목을 통해 TABLE ACCESS FULL과 같은 비효율적인 작업이 발생하는지 확인
3. 인덱스 사용 여부 확인
- OPERATION 항목에서 INDEX RANGE SCAN, INDEX UNIQUE SCAN과 같은 작업이 발생하는지 확인
4. 비용 분석
- COST 항목을 분석하여, 비용이 높은 작업을 우선으로 최적화 진행
5. 카디널리티 및 필터링 정보 확인
- Rows 항목에서 예상 처리 행 수 확인
- Predicate Information에서 필터링 조건이 제대로 작동하는지 확인
6. 필요한 부분 최적화 진행

> 실행계획에서 볼 수 있는 JOIN 방식 3가지는 무엇인가요?
https://memories95.tistory.com/178

1. Nested Loop Join
- 한 테이블의 Row를 읽고 다른 테이블에서 조인 조건에 해당되는 행들을 찾아가는 방식
- Nested Loop Join은 두 개의 테이블을 조인할 때, 먼저 하나의 테이블의 각 행을 반복하면서 다른 테이블의 모든 행과 비교하여 일치하는 행을 찾습니다. 작은 테이블이나 인덱스를 사용할 때 효율적
2. Sort Merge Join
- 각각의 테이블을 검색 조건에 의하여 정렬한 후 조인 조건에 의하여 값을 조인하는 방식
- Sort-Merge Join은 조인할 두 테이블이 미리 정렬되어 있을 때 매우 효율적입니다. 두 테이블을 각각 정렬하고, 병합하면서 일치하는 행을 찾습니다.
3. Hash Join
- 각각의 테이블을 Full 검색하여 해시 테이블에 저장한 후 값을 비교하여 조인
- Hash Join은 해시 테이블을 사용하여 두 테이블을 조인합니다. 주로 큰 테이블을 조인할 때 유용하며, 메모리를 많이 사용하지만 효율적인 방법입니다.

> 옵티마이저는 저런 JOIN 방식을 어떤 기준으로 정하는건가요?
1. 데이터 규모, 상태
- 적은 데이터 : NESTED LOOPS 선호. 인덱스를 사용해서 한 로우씩 처리하는 방식이 효율적일때 사용
- 큰 데이터 : HASH JOIN 선호. 해시 테이블로 변환해 대량의 데이터를 처리(해시 테이블로 변환시에 리소스가 소모되긴하지만, 전체 테이블을 순차적으로 비교하는 대신 해시 함수를 사용해서 데이터 찾는게 더 효율적) 
- 정렬된 데이터 : MERGE JOIN 선호. 두 테이블이 정렬된 상태일때, 두 테이블을 병합하여 조인
2. 인덱스 사용 가능성
- 인덱스가 유용한 경우 : NESTED LOOPS
- 인덱스가 필요없는 경우 : HASH JOIN

> 옵티마이저는 어떻게 인덱스 사용이 효율적인지 판단하는건가요?
- 통계 정보 : 카디널리티, 데이터 분포 등을 판단
- WHERE, JOIN 조건이 인덱스를 통해 효율적으로 처리될 수 있는지 분석
- 인덱스 사용 여부에 따른 예상 비용을 비교
- 현재 사용되는 옵티마이저는 비용 기반 옵티마이저로 위와 같은 절차를 빠르게 결정함

## 인덱스 스캔(Index Scan)과 테이블 스캔(Table Scan)의 차이점은 무엇인가요?
> 인덱스 스캔
- 인덱스를 구성하는 컬럼의 값을 기반으로 데이터를 추출
> 테이블 스캔 
- 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞는 결과 추출

## 데이터베이스에서 Partitioning이란 무엇인가요?
> 파디셔닝 이란?
- 큰 테이블이나 인덱스를 작은 Partition 단위로 나누어 관리하는 기법
- 데이터베이스의 튜닝 기법으로 대규모 데이터의 관리 용이성, 성능 향상을 위해 진행함
- 분할 키(partition key) : 데이터를 파티션으로 나누기 위해 사용하는 기준이 되는 컬럼
> 장점 , 단점
- 장점
  + 쿼리 실행시 전체 테이블이 아닌 관련 파티션에 대해서만 작업을 수행하므로 쿼리 성능 향상
  + 특정 파티션에 대한 백업, 복구, 유지보수 가능
  + 파티션 간의 독립성으로 장애 발생 시 특정 파티션만 영향 받을 수 있음
- 단점
  + 데이터 모델이 복잡해지고, 파티셔닝 설계를 잘 짜야함
  + 잘못된 파티셔닝은 특정 쿼리에서 모든 파티션을 검색하게 되는 경우 성능 저하 발생
  + 테이블과 인텍스를 같이 파티셔닝 해야하므로 더 많은 디스크 공간이 필요
> 종류
- 수평 파티셔닝 (Horizontal Partitioning)
  + 하나의 테이블의 각 행을 다른 테이블에 분산시키는 방식
  + 데이터, 인덱스의 개수가 줄어들어 성능 향상
  + 데이터를 찾는 과정이 복잡해짐(Latency 증가)
- 수직 파티셔닝 (Vertical Partitioning)
  + 테이블의 일부 열을 빼내는 형태로 분할 . 컬럼을 기준으로 나눔
  + 자주 사용되는 컬럼을 분리하여 성능 향상 가능
  + 같은 타입의 데이터가 저장되어 데이터 압축률 높일 수 있음
  + 조회시 필요없는 컬럼을 조회하지 않아도 됨
  + 데이터를 찾는 과정이 복잡해짐(Latency 증가)
> 분할 키 기준 분할 기법 (범위, 목록, 해시, 합성)
- 범위 분할 (range partitioning)
  + 연속적인 숫자나 날짜를 기준으로 파티셔닝
  + 분할 키 값이 범위 내에 있는지 여부로 구분 
- 목록 분할 (list partitioning)
  + 특정 값의 목록을 기준으로 데이터 분할
- 해시 분할 (hash partitioning)
  + 해시 함수를 사용해 데이터를 고르게 분산
  + 데이터 관리 보다는 성능 향상 목적
- 합성 분할 (composite partitioning)
  + 두 개 이상의 파티셔닝 기법을 결합하여 사용 

## Sharding이란 무엇이며, 언제 사용하나요?
> 샤딩이란?
- 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 기법

> 사용 이유
- 하나의 데이터베이스로 처리할 수 없는 대규모 데이터인 경우
- 대규모 데이터로 인해 성능이 저하됐을 경우

## 데이터베이스의 캐싱 전략에는 어떤 것들이 있나요?
https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC

> 캐싱 전략은 웹 서비스 환경에서 시스템 성능 향상을 기대할 수 있는 중요한 기술이다. 
일반적으로 캐시(cache)는 메모리(RAM)를 사용하기 때문에 데이터베이스 보다 훨씬 빠르게 데이터를 응답할 수 있어 이용자에게 빠르게 서비스를 제공할 수 있다.
하지만 기본적으로 RAM의 용량은 커봐야 16 ~ 32G 정도라, 데이터를 모두 캐시에 저장해버리면 용량 부족 현상이 일어나 시스템이 다운 될 수 있다.
따라서 어느 종류의 데이터를 캐시에 저장할지, 얼만큼 데이터를 캐시에 저장할지, 얼마동안 오래된 데이터를 캐시에서 제거하는지에 대한 '지침 전략' 을 숙지할 필요가 있다.

- cache hit : 캐시 스토어(redis)에 데이터가 있을 경우 바로 가져옴 (빠름)
- cache miss : 캐시 스토어(redis)에 데이터가 없을 경우 어쩔수없이 DB에서 가져옴 (느림)


> 캐시 읽기 전략 (Read Cache Strategy)
1. Look Aside 패턴 (Cache Aside 패턴) 
- 데이터를 찾을때 우선 캐시에 저장된 데이터가 있는지 우선으로 확인하는 전략, 만약 캐시에 데이터가 없으면 데이터베이스에서 조회
- 반복적인 동일 읽기가 많은 호출에 적합
- 캐시와 데이터베이스가 분리되어 있어 원하는 데이터만 별도로 구성하여 캐시에 저장
- 애플리케이션 캐싱에서 일반적으로 사용되는 전략
- 캐시에 장애가 발생하더라도 DB에 요청을 전달함으로써 대비할 수 있지만, 캐시와 DB간 정합성 유지 문제 발생 가능
- 초기 조회 시에는 무조건 데이터베이스를 호출
2. Read Through 패턴
- 캐시에서만 데이터를 읽어오는 전략. 캐시에 데이터가 없는 경우 캐시에서 데이터베이스를 조회하여 자체 업데이트
- 데이터를 조회하는데 전체적으로 속도가 느림
- 데이터 조회를 전적으로 캐시에만 의존하므로, 캐시에 장애 발생시 서비스 이용에 차질 발생
- 캐시와 DB간의 데이터 동기화가 항상 이루어지므로 데이터 정합성 문제는 벗어날 수 있음
> 캐시 쓰기 전략 (Write Cache Strategy)
1. Write Back 패턴 (Write Behind 패턴)
- 캐시와 데이터베이스 동기화를 비동기하기 때문에 동기화 과정 생략
- 데이터 저장시에 캐시에 모아서 일정 주기 배치 작업을 통해 데이터베이스에 반영
- 쓰기 쿼리 비용과 부하를 줄일 수 있음
- 캐시에서 오류 발생시 데이터 영구 소실
2. Write Through 패턴
- 데이터베이스와 캐시에 동시에 저장하는 전략
- 데이터를 캐시에 저장한 다음 바로 데이터베이스에 저장
- 캐시와 데이터베이스가 항상 동기화 되어있어 데이터 일관성을 유지할 수 있음
- 데이터 유실이 발생하면 안되는 상황에 적합
- 매 요청마다 두번의 write가 발생하므로, 빈번한 쓰기 작업이 발생하는 서비스에서는 성능 이슈 발생
3. Write Around 패턴
- write through 보다 빠름
- 모든 데이터는 데이터베이스에 저장 ( 캐시 갱신하지 않음 )
- cache miss가 발생하는 경우에만 데이터베이스와 캐시에 데이터 저장
- 캐시와 데이터베이스간의 데이터 불일치
> 자주 사용되는 조합
1. Look Aside + Write Around
- wirete around 패턴은 바로 데이터 베이스에 데이터를 저장함으로 캐시에 불필요한 데이터를 저장하지 않고, 자주 변경되는 데이터가 캐시에서 갱신될 필요가 없게됨. 대신 Look aside 패턴을 사용하여 조회시 캐시에 데이터가 없을 경우 캐시를 갱신함으로써, 자주 접근되는 데이터만 캐시에 저장할 수 있음
- 불필요한 데이터 캐싱 방지: Write-Around 전략은 데이터를 캐시에 직접 쓰지 않고, 오직 읽기 요청이 있을 때만 캐시에 데이터를 로드합니다. 이로 인해 자주 쓰이지만 읽히지 않는 데이터는 캐시에 저장되지 않으며, 캐시 메모리가 더 효율적으로 사용됩니다. 이는 캐시 메모리의 낭비를 줄이고, 자주 조회되는 중요한 데이터에 캐시 공간을 더 많이 할당할 수 있게 합니다.
2. Read Through + write Around
- 항상 데이터베이스에 저장하고, 캐시에서 읽을때 항상 데이터베이스에서 먼저 읽어오므로 데이터 정합성 이슈에 대한 완벽한 안전장치 구성 가능
3. Read Through + Write Through
- 데이터를 쓸때 항상 캐시에 먼저 쓰므로, 읽어올때 최신 캐시 데이터 보장, 데이터 정합성 보장


## 풀 테이블 스캔(Full Table Scan)이 발생하는 원인은 무엇인가요?
- 적용 가능한 인덱스가 없는 경우
- 넓은 범위의 데이터 액세스
- 부적합한 인덱스 사용한 경우
- 데이터가 많지 않은 테이블

## SQL 쿼리 최적화 방법에는 어떤 것이 있나요?
1. 인덱스 최적화 
- WHERE, JOIN, ORDER BY절에서 자주 사용되는 컬럼에 인덱스 생성
2. 불필요한 컬럼 제거
- SELECT * 대신에 필요한 컬럼만 명시적으로 지정
3. 서브쿼리 대신 조인 사용
- 서브쿼리의 경우 메인 쿼리의 각 행에 대해서 서비쿼리가 반복적으로 실행되므로 성능 저하 발생
4. 파티셔닝
5. 실행 계획 분석

## 조회 성능을 높이기 위한 방법에는 무엇이 있나요?
1. 인덱스 최적화
- 조회 컬럼에 적절한 인덱스 사용
2. 불필요한 컬럼 제거
- SELECT * 대신에 필요한 컬럼만 명시적으로 지정
3. 커버링 인덱스 사용

## 데이터베이스 성능 모니터링 도구나 기법에 대해 설명해주세요.
> 성능 모니터링 도구
1. Oracle 
- Oracle Enterprise Manager (OEM): AWR 보고서 생성, SQL 성능 분석, 데이터베이스 상태 모니터링 등을 지원
2. SQL Server
- SQL Server Management Studio (SSMS): 성능 모니터링과 튜닝에 사용. 실행 계획 분석, 성능 카운터 모니터링, 데이터베이스 엔진 튜닝 어드바이저 등을 제공
- SQL Server Profiler: SQL Server의 트랜잭션을 추적하여 성능 문제를 분석하는 데 사용
3. MySQL
- MySQL Enterprise Monitor: 쿼리 성능, 리소스 사용량 등을 실시간으로 모니터링 가능
- Percona Monitoring and Management (PMM): 오픈 소스 기반의 MySQL 및 MongoDB 모니터링 도구로, 성능 데이터 시각화와 분석 기능을 제공

> 기법
1. 실행 계획 분석
- 쿼리가 어떻게 실행되는지 분석하는 방법
- MySQL : EXPLAIN, Oracle : EXPLAIN PLAN
2. 성능 메트릭 모니터링
- CPU, 메모리, 디스크 I/O 등 리소스 사용량을 모니터링 하여 데이터베이스 성능을 평가하는 방법
3. 쿼리 응답 시간 모니터링
- 각 쿼리가 실행되는데 걸리는 시간을 모니터링
4. 로그 및 트랜잭션 모니터링
- 데이터베이스 로그와 트랜잭션 활동을 모니터링


# 데이터 모델링
## 엔터티(Entity)와 애트리뷰트(Attribute)란 무엇인가요?
> 엔터티(Entity)
- 데이터베이스에서 관리해야 할 정보의 주체. 실세계에서 존재하는 객체나 개념 

> 애트리뷰트(Attribute) 
- 엔티티가 가지는 특성 또는 정보를 나타내는 요소. 테이블에서 각 컬럼

> Entity간의 관계는 어떻게 정의하나요?
- 외래키를 통해 정의. 외래키가 다른 엔티티의 기본키를 참조하여 관계를 형성

> Attribute에서 Domain이란?
- 애트리뷰트의 도메인이란, 해당 애트리뷰트가 가질 수 있는 값의 범위

> 하나의 엔티티에 너무 많은 속성이 있는 경우 어떻게 처리하시나요?
- 하나의 엔티티에 너무많은 속성이 있게되면, 테이블 구조가 복잡해져서 구조파악에 시간이 걸리고, 데이터 변경시에 의존 관계에서 문제가 생길 수도 있고, 쿼리 작성시에도 성능이 떨어질수가 있습니다. 이런 경우에는 정규화 과정을 진행해야합니다. 주로 부분 함수 종속을 제거하는 제2정규형, 이행적 종속성을 제거하는 제3정규형이 사용됩니다. 
  
## ERD(Entity-Relationship Diagram)란 무엇인가요?
- 엔티티와 속성간의 관계를 시각적으로 표현한 다이어그램

## 1:1, 1:N, N:M 관계를 설명해주세요.
> 1:1 관계
- 하나의 엔티티에서 다른 엔티티와 단 하나의 관계를 가지는 것
- 데이터의 무결성을 높이지만, 필요하지 않은 경우에 2개의 테이블을 사용하는것이 비효율적일 수 있음 
> 1:N 관계
- 한쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것
- 서로 관계를 맺고있는 테이블중에 부모 레코드 삭제시 자식 레코드에 미치는 영향도 관리가 필요
> N:M 관계
- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계 있는 경우
- 데이터 모델링에서는 N:M 관계를 완성되지 않은 모델로 간주하며, 조정 작업이 필요
- 두 엔티티의 관련성을 표현하기 위해 중간에 매핑 엔티티를 추가

## 테이블 간의 관계를 모델링할 때 주의해야 할 점은 무엇인가요?
- 테이블간의 관계유형을 정확히 정의하는 것이 중요. 예를 들어서 학생과 강의 처럼 다대다 관계일 경우에는 중간에 매핑 테이블을 추가하여 관계를 명확히 설정해야함
- 관계를 명확히 설정하기 위해서는 외래 키를 설정하고, 이를 통해 참조 무결성을 유지. 외래키 설정을 위해서는 부모테이블의 기본키를 참조.  

## 데이터베이스의 차수(Degree)와 카디널리티(Cardinality)에 대해 설명해주세요.
- 차수(Degree) : 테이블 열의 갯수. 테이블 속성(필드, 컬럼)의 갯수
- 카디널리티(Cardinality) : 테이블 행의 갯수. 테이블 레코드(튜플, 행)의 갯수
  
## 데이터 무결성이란 무엇이며, 무결성을 유지하는 방법은 무엇인가요?
> 무결성이란
- 데이터베이스 내의 데이터가 정확하고, 일관성이 유지되며, 신뢰할 수 있는 상태.

> 무결성을 유지하는 방법
- 데이터베이스에서는 갱신 연산의 수행 결과에 따라서 무결성 제약조건이 위배될 수 있음
- DBMS는 외래키가 갱신되거나, 참조된 기본키가 갱신되었을때 참조 무결성 제약 조건이 위배되지않도록 해야함
  + 제약 조건 설정 : PRIMARY KEY, UNIQUE, NOT NULL과 같은 제약조건을 설정함으로써 데이터 갱신시에 검증
  + 외래키 제약 조건을 사용하여 참조 무결성을 유지. ON DELETE CASCADE, ON UPDATE CASCADE 같은 옵션사용
  + 갱신 연산이 수행될때 트리거를 사용해 실시간으로 데이터 무결성 유지

> 트리거 (Trigger) 
- 특정 테이블에 insert, delete, update 와 같은 DML 이벤트가 발생할때 자동으로 실행되는 SQL 구문

> 무결성 제약조건
- 개체 무결성 : 각 릴레이션의 기본키를 구성하는 속성은 null값이나 중복된 값을 가질 수 없음
- 참조 무결성 : 외래키 값은 null이거나 참조하는 릴레이션의 기본키 값과 동일해야함
- 도메인 무결성 : 각 속성들의 값은 정의된 도메인에 속한 값이어야함
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값은 고유한 값을 가져야 함 (ex. 기본키) 
- null 무결성 : 릴레이션의 특정 속성 값은 null이 될 수 없음 
- 키 무결성 : 각 릴레이션은 최소한 한개 이상의 키를 가져야 하며, 키는 튜플을 식별할 수 있는 값이어야함
   
## ORM(Object-Relational Mapping)이란 무엇인가요?
> ORM(Object-Relational Mapping)
- 객체와 데이터베이스의 테이블을 매핑시켜 RDB 테이블을 객체 지향적으로 사용하게 해주는 기술
- 객체 모델과 관계형 모델간에 불일치가 존재하는데, ORM을 통해 객체간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치 해결

> 장점
- 개발자가 직접 SQL 쿼리를 작성하지 않아도 되며, 객체에 대한 코드를 별도로 작성하여 코드의 가독성 증가
- 특정 DB에 종속적이지 않기 때문에 DBMS를 교체하는 큰 작업에 대해서도 리스크가 적을 수 있음
> 단점
- 복잡한 쿼리를 처리할때 성능 저하가 발생할 수 있음
- 프로젝트의 복잡성이 커질 경우 ORM 구현 난이도가 증가할 수 있음

## 데이터베이스의 외래키 제약조건(Cascade Delete, Cascade Update)이란 무엇인가요?
> ON UPDATE CASCADE
- 부모 테이블의 기본키 값이 수정될때, 부모의 기본키를 참조하는 외래 키 값도 자동으로 갱신되도록 설정하는 제약조건
> ON DELETE CASCADE
- 부모 테이블의 레코드가 삭제될때, 해당 레코드를 참조하는 자식 테이블의 레코드도 자동으로 삭제되도록 설정하는 제약조건 

## NoSQL의 데이터 모델링 전략은 RDBMS와 어떻게 다른가요?
- Schema-less 구조 : 각 레코드에 서로 다른 구조를 가질 수 있고, 데이터를 삽입하기 전에 스키마를 정의할 필요 없음
- 다양한 데이터 저장 방식 : Document-based, Key-Value, Graph, wide column 방식으로 다름
- join 연산 대신에 애플리케이션 로직에서 처리하는 경우가 많고, 관련 데이터를 한번에 읽을 수 있도록 비정규화하여 저장
- 성능 최적화의 경우 데이터 중복 저장을 허용(데이터의 무결성을 엄격하지 유지하지 않는 경우가 많음)하고, 일관성보다는 가용성과 성능을 우선시 함

- RDMS는 정규화, 고정스키마, 데이터 무결성을 중시하고, 조인 연산을 통해 데이터 간의 관계를 관리
- NoSQL은 스키마리스, 비정규화된 데이터 모델을 사용하여 수평 확장에 유리하며, 성능 최적화를 위해 데이터 중복을 허용하고, 가용성과 성능을 우선시 함

- https://www.mongodb.com/developer/products/mongodb/mongodb-schema-design-best-practices/

## 스키마리스(Schema-less) 데이터베이스란 무엇인가요?
- 고정된 스키마 없이 데이터를 저장할 수 있는 데이터베이스
- 각 레코드가 서로 다른 구조를 가질수 있음
- 데이터 모델링이 유연하고 확장성이 뛰어나지만, 데이터 무결성 관리가 어려움

# 데이터베이스 아키텍처 및 설계

## 데이터베이스의 물리적 설계와 논리적 설계의 차이점은 무엇인가요?
> 논리적 설계
- 데이터베이스의 구조와 관계를 설계하는 단계
- 데이터 모델링 구체화 과정 ( 엔티티와 관계를 기반으로 테이블 구조, 컬럼 정의, 기본키, 외래키 설정 )
- 정규화 작업 진행 
> 물리적 설계
- 논리적 설계를 기반으로 데이터를 효율적으로 저장하고, 성능을 최적화하는 단계
- 구체적인 타입을 DBMS에 맞게 정의하고, 테이블, 인덱스 등의 요소 최적화 

## 데이터베이스의 복제(Replication)란 무엇이며, 어떤 종류가 있나요?
> Replication
- 데이터베이스의 데이터를 여러 서버에 복사하여 데이터의 가용성과 안정성을 높이는 것 
>  종류
- 동기 복제 : Primary 서버에서 데이터 변경 작업이 발생할 때 Replica 서버에도 동시에 데이터를 반영하는 방식
- 비동기 복제 : Primary 서버에서 데이터 변경 발생시 실시간으로 복제되지 않고, 일정 시간 간격으로 Replica 서버에 복제되는 방식
  + 네트워크 부담이 적음
  + Replica 서버에서 최신 데이터를 제공하지 못할 수 있음

## 데이터베이스 페일오버(Failover)란 무엇인가요?
> FailOver
- 시스템에 장애가 발생했을때, 백업 서버로 전환하여 서비스를 지속적으로 제공하는 과정 (고가용성 보장)

## 데이터 웨어하우스와 데이터 마트의 차이점은 무엇인가요?
> 데이터 웨어하우스
- 많은 양의 데이터를 오랫동안 보관하는것에 최적화
- 업무적으로 중요한 데이터가 저장되고, 전사적인 관점에서 통합하여 관리 
> 데이터 마트
- 데이터 웨어하우스의 데이터를 이용하여 분석 및 개발이 필요한 경우, 필요한 데이터를 추출하여 구축
- 특정 목적에 따라 추출하여 사용
  
## OLTP와 OLAP의 차이점은 무엇인가요?
> OLTP(Online Transaction Processing)
- 실시간 데이터 처리에 중점을 둔 시스템으로, 빠른 데이터 입력, 수정, 삭제와 같은 트랜잭션 처리를 목표
- 데이터 일관성과 무결성이 중요
- ex. 은행 거래 시스템, 온라인 쇼핑몰 ..
> OLAP(Online Analytical Processing)
- 데이터 분석을 위한 시스템으로, 복잡한 쿼리와 데이터 집계, 분석에 중점
- ex. 경영 분석 시스템..

> 차이점
- OLTP는 현재의 데이터 처리가 얼마나 정확하고, 무결한지 중요합니다. 그러므로 주로 데이터의 저장, 삭제 등의 데이터를 수정하는 작업의 처리를 목표로 하고, OLAP은 이미 저장된 데이터를 바탕으로 어떤 정보를 제공하는지가 중요합니다. OLAP은 데이터가 무결하고 정확하다는 전제를 바탕으로 사용자가 원하는 정보를 어떤식으로 표현하고 제공하는지에 목표를 가집니다. 

## 데이터베이스에서 백업과 복구 전략에는 어떤 것들이 있나요?
> 백업
- 시스템 장애, 데이터 손실, 물리적 손상 등의 상황에 대비하여 데이터베이스 데이터와 구조를 복사해 저장하는 과정
> 백업 전략
- 전체 백업(Full Backup) : 모든 데이터와 스키마를 한번에 복사
  + 정기적으로 전체 백업을 수행하여 데이터베이스의 완전한 복구 보장
- 차등 백업(Differential Backup) : 마지막 전체 백업 이후 변경된 데이터만 백업
  + 전체 백업 후에 데이터가 자주 변경되는 경우에는 차등 백업을 주기적으로 수행하여 백업 효율성 높힐수 있음
- 증분 백업(Incremental Backup) : 마지막 백업 이후 변경된 데이터만 백업하는 방식
  + 일상적인 백업 작업에 적합, 빈벅하게 백업할 때 효울적
> 백업 전략시 고려사항
- 정기적인 백업 주기 설정, RPO가 짧을 수록 백업을 자주 수행해야 함 ( 전체백업, 차등백업, 증분 백업 )
- RPO (Recovery Point Objective) : 데이터 손실을 허용할 수 있는 최대 범위
- 데이터의 보안 및 암호화
- 백업 파일의 저장소 관리 (디스크 공간, 백업 파일의 유지기간)
> 복구
- 백업된 데이터를 이용하여 손상된 데이터베이스를 원래 상태로 복원하는 과정
> 복구 전략
- 전체 복구(Full Recovery) : 전체 백업본을 이용해 데이터베이스 전체를 복구
  + 전체 데이터 손실이 발생한 경우 사용
- 차등 복구(Differential Recovery) : 전체 백업본을 복구한 다음에, 그 이후에 생성된 차등 백업본을 적용하여 복구
  + 전체 백업 이후 일부 데이터 손실이 발생했을 때 사용 
- 증분 복구(Incremental Recovery) : 전체 백업본을 복구한 다음, 그 이후에 생성된 여러 증분 백업본을 순차적으로 적용하여 복구
  + 마지막 전체 백업 이후 데이터가 자주 변경되었을 경우 사용 
- 시점 복구(Point-in-Time Recovery) : 트랜잭션 로그를 사용해 특정 시점까지 복구하는 방식
  + 실시간 트랜잭션 데이터를 기록하고, 특정 시점으로 복구해야할 때 사용. 잘못된 데이터 수정 또는 삭제 후 복구해야할때 유용
> 복구 전략시 고려사항
- 복구 시점 설정 (어떤 백업본을 사용할지, 어느 시점으로 복구할지)
- 복구 과정 및 순서 결정 (전체 백업 -> 전체복구 등)
- 복구 시간(RTO)과  데이터 손실 허용 범위(RPO) 최소화
- 복구 절차 테스트 및 검증

## 스냅샷(Snapshot)이란 무엇인가요?
> 스냅샷이란?
- 시스템이나 데이터베이스의 특정 시점을 캡쳐하여 그 시점의 상태를 복사하여 저장하는 기술
- 데이터 손실이나 시스템 장애가 발생했을때 빠르게 복구할 수 있는 기능
- 스냅샷은 전체 데이터를 복사하는 것과 달리 데이터가 변경된 부분만 기록
> 종류
- Copy-on-Write(COW) 스냅샷
  + 스냅샷이 생성될때 데이터 전체를 복사하지않고, 데이터가 변경된 시점에만 변경된 데이터 블록 저장
  + 빠르고 처음 생성시에는 추가적인 저장 공간을 거의 사용하지 않음
  + 시간이 지나면서 데이터가 많이 변경될시 데이터가 축적되어 저장공간이 증가
- Redirect-on-Write(ROW) 스냅샷
  + 스냅샷이 생성될때 데이터가 변경되면 변경된 데이터가 다른 저장소 위치에 기록되고, 기존 데이터는 그대로 남겨둠
  + 데이터 일관성을 유지하면서 변경된 데이터를 별도의 공간에 저장하므로 복구가 용이
  + 시간이 지나면서 데이터가 많이 변경될시 데이터가 축적되어 저장공간이 증가

> 스냅샷과 백업은 다른건가요?
- 스탭샷은 특정 시점의 데이터를 캡쳐하여 복사한것으로 주로 짧은 시간 동안의 데이터 복구를 위해 사용. 백업은 데이터를 완전한 복사본으로 만들어서 장기적으로 보관하고 데이터 손실시 완전한 데이터 복구가 필요할때 사용하는것이 목적.

## 데이터베이스의 고가용성(High Availability)을 유지하기 위한 전략은 무엇인가요?
> 고가용성이란?
- 서비스가 중단 없이 안정적으로 제공될수 있도록 여러 장애 상황에 대비하는 시스템적 전략
> 전략 
- 복제(Replication) : 데이터 복제를 통해 하나의 노드에 장애 발생시 다른 노드에서 서비스 제공 가능
- 페일오버(Failover) : 시스템에 장애가 발생했을때, 백업 서버로 전환하여 서비스를 지속적으로 제공
- 클러스터링(Clustering) : 여러 서버를 하나의 논리적 단위로 묶어 운영하는 기법
- 백업과 복구(Backup and Restore) : 주기적인 백업을 통해 데이터 유실 방지, 장애 발생시 빠른 복구가 가능한 체계 수립
- 데이터 샤딩(Sharding) : 데이터베이스를 여러 서버에 저장함으로써 시스템 장애시 나머지 샤드에서 동작 지속
  
## 분산 데이터베이스의 개념과 장점은 무엇인가요?
> 분산 데이터베이스란?
- 여러 곳으로 분산된 데이터베이스를 하나의 가상 시스템처럼 사용할 수 있게 하는 데이터베이스
- 논리적으로 동일한 시스템이지만, 물리적으로는 분산되어있는 데이터베이스
> 장점 
- 확장성 : 대용량 데이터와 트래픽 처리시에, 쉽게 확장이 가능
- 고가용성 : 데이터가 분산되어 있어 장애가 발생하더라도 다른 서버에서 운영 지속 가능
- 성능 향상 : 데이터베이스가 분산되어 있어 네트워크 지연시간이 감소
  
## 데이터베이스 클러스터링이란 무엇인가요?
- 여러 데이터베이스 서버를 하나의 시스템처럼 동작하도록 묶는 기술

> 클러스터링 종류
- Active-Active 클러스터링 : 클러스터 내부의 데이터베이스 서버가 모두 동작하는 상태로 운영하는 클러스터링
  + 하나의 서버가 동작 불능이 되어도 나머지 서버가 존재하므로 downtime이 없음 
- Active-Standby 클러스터링 : 일부 데이터베이스 서버를 대기 상태로 운영하는 클러스터링
  + active 서버가 동작하지 않을때 standby 서버가 active로 변경 ( failover )
  + standby -> active 전환시 downtime 발생 ( 가용성이 떨어질수 있음 ) 

- https://hudi.blog/database-clustering/

> 클러스터링과 리플리케이션의 차이점은?
- https://hahahoho5915.tistory.com/66
- 클러스터링은 여러 서버가 하나의 스토리지를 사용하여 데이터 일관성과 가용성을 유지하고, 레플리케이션은 각 서버가 각각의 스토리지에 복제된 데이터를 저장하여 데이터 손실 방지 및 읽기 성능을 중요시함


# 기타 데이터베이스 주제
## 데이터 마이그레이션(Migration)이란 무엇인가요?
> 데이터 마이그레이션
- 한 시스템에서 다른 시스템으로 데이터를 이동하는 과정 

## 데이터베이스 연결 풀(Connection Pool)이란 무엇인가요?
> Connection pool
- 데이터베이스 연결을 미리 생성하고 재사용하며, 애플리케이션에서의 데이터베이스 연결 성능을 최적화하고 리소스를 관리하는 기술. 연결을 매번 생성하지 않고, 미리 준비된  connection pool을 할당하고 사용후 반환하므로써 성능을 향상
  
> 목적
- 데이터베이스와 애플리케이션 사이에 연결 생성과 해제는 리소스가 많이 드는 작업이므로, connection pool을 사용하여 재사용성과 성능을 향상 시킬 수 있음 
  
> 장단점
- 장점 : 미리 연결을 생성함으로써 응답 시간을 단축, 데이터베이스 서버의 연결 수를 제한하여 과부하를 방지
- 단점 : 미리 생성된 연결들이 메모리를 점유해서 메모리 사용량이 늘어날 수 있음, 최적의 성능을 위해 세부 설정이 필요

> connection pool에서 최소 연결 수와 최대 연결 수를 설정하는 이유는?
- 최소 연결 수는 항상 이용 가능한 연결을 유지하도록 하고, 최대 연결 수는 데이터베이스 서버에 부하가 걸리지 않도록 제한하는 역할을 하는데, 이 값들을 적절하게 설정하지 않으면 오히려 성능 저하와 리소스 낭비가 발생할 수 있음

> HikariCP에서 maximumPoolSize는 어떻게 결정하셨나요?
- 데이터베이스의 성능, cpu 코어수 등을 고려하여 설정. 일반적으로 cpu 코어 수의 1.5~2배로 설정 
> minimumIdle을 설정할 때 고려한 사항은 무엇인가요?
- minimumidle 값은 유휴 연결을 얼마나 유지할지 결정하는 값으로, 트래픽의 변동성에 따라 설정. 빠른 응답이 필요한 시스템에서는 더 높은 값을 설정해 즉시 연결이 가능하도록 했고, 자원 절약이 필요한 경우 낮게 설정 
> HikariCP에서 idleTimeout의 역할은 무엇인가요?
- idletimeout은 유휴 연결이 일정 시간 동안 사용되지 않을 경우 풀에서 제거되는 시간을 설정하는 옵션. 
> HikariCP에서 connectionTimeout은 어떻게 설정했나요?
- 애플리케이션이 데이터베이스 연결을 얻기 위해 기다릴 수 있는 최대시간을 의미. 
> HikariCP를 사용할 때 데이터베이스 서버에 부하를 줄이기 위해 어떤 설정을 했나요?
- maximumPoolSize를 데이터베이스 서버의 최대 연결 수보다 적게 설정해 데이터베이스가 과부하에 걸리지 않도록 했습니다. 또한 idleTimeout을 설정해 유휴 연결을 줄이고, 불필요한 자원 사용을 최소화했습니다.
  
## 데이터베이스에서 동시성 제어를 위해 사용되는 기법은 무엇인가요?
> 동시성 제어 ( Concurrency Control )
- 데이터베이스 시스템에서 여러 트랜잭션이 동시에 수행될 경우, 데이터의 일관성을 유지하기 위한 기술
- 각 트랜잭션들이 서로 간섭하지 않고 독립적으로 처리됨을 보장해야하고, ACID(원자성, 일관성, 고립성, 지속성)을 유지하는데 중요한 역할
  
> 락 ( Locking )
- 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 하는 기법
- 락이 해제되기 전까지 다른 트랜잭션은 해당 데이터에 접근 할 수 없음
- 락 기법은 데이터의 무결성은 보장할 수 있으나, 동시에 처리할수 있는 처리량이 제한되므로 쓰기 작업이 많을때 적합
> 낙관적 동시성 제어 ( Optimistic Concurrency Control )
- 락을 사용하지 않고, 여러 트랜잭션이 동시에 동일한 데이터에 접근할 수 있고, 최종적으로 커밋 단계에서 충돌이 발생하면 트랜잭션을 롤백하는 기법
- 충돌이 적고, 읽기 작업이 많은 시스템에 적합 
> 비관적 동시성 제어 ( Pessimistic Concurrency COntrol )
- 충돌이 발생할 것이라는 전제를 하고, 트랜잭션이 시작할때부터 미리 락을 걸어 충돌을 방지하는 기법
- 은행 시스템같은 다중 트랜잭션 처리 시스템에 적합
> 타입스탬프 기법
- 트랜잭션을 식별하기 위해 티임 스탬프를 지정하여 트랜잭션간의 순서를 미리 선택하는 기법
- 교착상태를 방지 할 수 있으나 롤백 발생률이 높음
> MVCC ( Multiversion Concurrency Control)
- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용되는 기법
- 원본의 데이터와 변경중인 데이터를 동시에 유지하는 방식으로, 원본 데이터에 대한 스냅샷을 백업하여 보관
- 두가지 버전의 데이터가 존재하는 상황에서 새로운 사용자가 데이터에 접근하면, 데이터베이스의 스냅샷을 읽고, 변경이 취소되면 원본 스냅샷을 기준으로 데이터를 복구하고, 변경이 완료되면 최종적으로 커밋하는 방식으로 동작
- 락을 걸지 않으므로 읽기 작업이 수정 작업에 방해받지 않고 동시에 처리 가능
- 트랜잭션이 시작될때 데이터의 스냅샷을 유지하므로, 일관성 있는 데이터를 읽을 수 있음
- 데이터의 여러 버전을 유지하므로, 메모리 공간과 관리 비용이 증가할 수 있음

## 테이블 조인과 서브쿼리 중 어느 것을 사용해야 하나요?
- join : 테이블 간의 관계가 명확하고, 여러 테이블에서 데이터를 결합해야 하는 경우에 적합
- subQuery : 단순한 조건에서 특정 데이터를 필터링하는 경우에 적합

- 참고 : https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-JOIN%EA%B3%BC-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-%EC%B0%A8%EC%9D%B4-%EB%B0%8F-%EB%B3%80%ED%99%98-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC

## 데이터베이스에서 컨테이너(DB 컨테이너)란 무엇인가요?
- 컨테이너화 기술을 통해 DB를 가상환경에서 실행하는 방식
-> 사용해본적이 없어서 어떤 질문이 나올지는 잘 모르겠음. 사이드플젝으로 사용해 보고 추가하기

## 데이터베이스에서 커서(Cursor)란 무엇이며, 언제 사용하나요?
> Cursor
- 데이터베이스의 쿼리 결과를 순차적으로 처리하기 위해 사용되는 기법
- 데이터를 순차적으로 처리하거나, 각 행에 대해 업데이트 작업을 수행하거나 개별적인 연산이 필요할때 사용 ( 행단위 제어 )

``` sql
DECLARE emp_cursor CURSOR FOR
SELECT employee_id, salary
FROM employees;

DECLARE @emp_id INT;
DECLARE @emp_salary DECIMAL(10, 2);

-- 커서 열기
OPEN emp_cursor;

-- 첫 번째 행 가져오기
FETCH NEXT FROM emp_cursor INTO @emp_id, @emp_salary;

WHILE @@FETCH_STATUS = 0
BEGIN
    -- 급여를 10% 인상
    UPDATE employees
    SET salary = @emp_salary * 1.10
    WHERE employee_id = @emp_id;
    
    -- 다음 행 가져오기
    FETCH NEXT FROM emp_cursor INTO @emp_id, @emp_salary;
END;

-- 커서 닫기
CLOSE emp_cursor;

-- 커서 해제
DEALLOCATE emp_cursor;
```

## 데이터베이스의 잠금(Locking) 기법에는 어떤 것들이 있나요?
- Shared Lock : 주로 읽기 작업에서 사용되며, 여러 사용자가 동시에 데이터를 읽는 상황에서 수정은 불가능하며, 데이터 무결성을 보호하고, 읽기 작업을 병행 할 수 있음.
- Exclusive Lock : 읽기와 쓰기 모두 차단하는 기법. 한 트랜잭션이 exclusive lock을 설정하면 다른 트랙잭션은 해당 데이터에 대해 읽기 또는 쓰기를 할 수 없음
- Update Lock : 데이터를 먼저 읽고 나중에 데이터를 수정할 가능성이 있는 경우 사용하며, 교착 상태를 방지하기 위해 사용되는 기법. 데이터를 읽기 위해 공유 락을 사용하는 대신 update lock을 설정하면, 다른 트랜잭션이 동일한 데이터에 대해 Exclusive lock을 설정하지 못하게 하고, 데이터 무결성을 유지하면서 교착상태 방지 가능

## 페이징 쿼리(Pagination)를 효율적으로 작성하는 방법은 무엇인가요?
> 페이징 쿼리
- 대량의 데이터를 처리할때 한번에 모든 데이터를 가져오는것이 아닌, 필요한 범위만큼 데이터를 나눠서 가져오는 방식

> 효율적으로 작성하는 방법
- offsete, limit을 사용하는 일반적인 방식이 있으나, 대규모 데이터에서는 효율성이 떨어질수 있음.
- 인덱스를 활용해서 offset을 최소화하고, 커버링 인덱스를 사용하여 테이블에 추가 접근 없이 데이터를 처리하는 것이 성능 최적화여 적합

> offset
- 지정된 행 수만큼 데이터를 건너뛰기 위해 앞의 행을 스캔 ( 페이징 번호가 커질수록 성능 저하 )  
## 데이터베이스에서 NULL 값을 처리하는 방법을 설명해주세요.
- Null은 값이 없거나, 정의되지 않은 상태를 의미.
- 일반적인 비교 연산자 사용할 수 없으므로, NVL, ISNULL과 같은 함수를 적절하게 사용해야함
  
## 데이터베이스에서 로그(Log) 파일이란 무엇인가요?
- 데이터베이스에서 데이터의 변경 내역을 기록하는 파일
- 데이터베이스의 무결성과 복구시에 중요함
  
# 고급 데이터베이스 주제
## 데이터베이스 인스턴스와 스키마의 차이점은 무엇인가요?
> 인스턴스
- DBMS의 인스턴스 : 데이터베이스가 실행되고 있는 환경. ( 메모리, 프로세스, 캐시, 버퍼처럼 물리적인 리소스를 포함하여 실행중인 DBMS의 상태 ) 
- 테이블 내의 인스턴스 : 데이버테이스의 물리적으로 저장된 데이터
> 스키마
- 데이터베이스의 논리적인 구조를 정의하는 개념
- 테이블, 뷰, 인덱스, 제약 조건 등 설계도 역할
## RDBMS에서 제약조건(Constraint)의 종류에는 무엇이 있나요?
- primary key : 테이블의 각 행을 식별할 수 있는 컬럼에 설정. not null과 unique 제약조건을 동시에 가짐 
- foreign key : 한 테이블의 컬럼이 다른 테이블의 기본키 또는 unique 컬럼과 연결되도록 하는 제약조건
- chkeck 제약 조건 : 특정 컬럼에 조건을 설정. 해당 조건을 만족하는 데이터만 저장할 수 있도록 하는 제약조건
- default 제약조건 : 특정 컬럼에 값이 입력되지 않았을 경우 기본값을 자동으로 설정해주는 제약조건
- not null 제약조건 : 특정 컬럼에 null이 저장되지 않도록 하는 제약조건 
- unique 제약조건 : 특정 컬럼에 중복된 값이 저장되지 않도록 하는 제약조건 

## 데이터베이스의 테이블 파티셔닝과 인덱스 파티셔닝의 차이점은 무엇인가요?
> 테이블 파티셔닝
- 하나의 테이블을 여러개의 작은 Partition 단위로 나누어 관리하는 기법
- 데이터베이스의 튜닝 기법으로 대규모 데이터의 관리 용이성, 성능 향상을 위해 진행함
> 인덱스 파티셔닝
- 인덱스를 parition으로 분할하여 데이터를 효율적으로 검색할 수 있도록 하는 방법
> 차이점
- 테이블 파티셔닝 : 테이블 자체의 데이터를 분할하여 데이터 관리와 특정 범위 조회 성능을 높이기 위한 것
- 인덱스 파티셔닝 : 데이터 검색을 위한 인덱스를 분할하여 검색 성능 최적화와 인덱스 관리 효율성을 위한 것

## 테이블의 조인 순서가 성능에 미치는 영향은 무엇인가요?
- 데이터가 적은 테이블을 먼저 조인 : 불필요한 데이터 처리량을 줄여 성능 향상
- 조인 순서를 인덱스가 적용된 테이블을 먼저 처리 : 인덱스를 사용해 데이터 필터링을 더 빠르게 가능 (테이블 풀스캔 방지) 
- 카디널리티가 높을 컬럼을 먼저 조인 : 카디널리티의 경우 데이터의 양도 같이 고려해야함

- 참고자료 : https://schatz37.tistory.com/2
## OLAP에서 큐브(Cube)란 무엇인가요?
- 데이터를 다차원적으로 분석할 수 있도록 하는 데이터 구조
- 큐브는 데이터를 여러 차원(Dimensions)으로 나누어 다양한 관점에서 분석가능
    + 차원(Dimensions) : 데이터를 그룹화하는 기준
    + 측정값 : 해당 차원에 따른 집계된 값. 분석하고자 하는 데이터
> 큐브의 다차원 분석 기능
- Drill-Down : 데이터를 세부적인 수준으로 분해하여 분석하는 방법 ( 연도별 매출-> 월별, 일별로 )
- Roll-Up : 데이터를 상위수준으로 요약하여 분석하는 방법 ( 일별, 월별 매출 데이터 -> 연도별로 ) 
- Slice : 특정 차원을 고정하고 나머지 차원에 대한 데이터 분석하는 방법 ( 특정 연도에 특정 제품군에 대한 매출 데이터 ) 
- Dice : 여러 차원을 동시에 고정하여 데이터의 부분 집합을 분석하는 방법 ( 특정 연도에 특정 제품군에 대해 특정 지역에서 발생한 매출 데이터 ) 

## 데이터베이스 샤딩 시 데이터 일관성을 유지하는 방법은 무엇인가요?
- 대규모 데이터를 처리할 때 데이터를 여러 샤드로 분할하여 분산 처리하는 방식
> 분산 트랜잭션 관리
- 2단계 커밋 프로토콜 ( 2 Phase commit ) : 분산된 여러 샤드에서 트랜잭션 발생시 준비 단계에서 모든 샤드에 트랜잭션을 요청하고 모든 샤드가 준비되면 트랜잭션 커밋
- 원자성 보장, 데이터 일관성 유지
- 네트워크 지연과 성능 저하가 발생할 수 있음
> 데이터 복제 전략
- 동기 복제 : 데이터를 샤드 간에 동시에 복제. 즉각적인 일관성을 제공하나 성능 저하 발생할 수 있음
- 비동기 복제 : 트랜잭션이 완료된 후에 나중에 복제. 처리 속도는 빠를수 있지만, 데이터 일관성이 깨질수 있음
> 샤드 키 설계
- 데이터 분산 기준은 샤드키 설계시에 트랜잭션이 하나의 샤드 내에서만 발생하도록 설계 
> CAP 이론
- 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 2가지 특성 조합하는 이론
- CP 모델 ( 일관성 + 파티션 허용성 ) : 모든 샤드가 데이터 일관성은 유지하지만, 일부 샤드에 장애가 발생하면 가용성 저하
- AP 모델 ( 가용성 + 파티션 허융성 ) : 모든 샤드는 서비스 가능하지만, 일관성이 약해질수 있음

## 데이터베이스에서 이력 관리(History Tracking)를 위한 설계 방법은 무엇인가요?
- 이력 테이블 추가
- 타임 스탬프 필드 사용 : 타임스탬프 컬럼을 추가하여 데이터의 생성일과 삭제일 기록
- 소프트 삭제 : 데이터를 물리적으로 삭제하지 않고, 삭제 여부를 나타내는 플러그를 컬럼을 추가하는 방식
- Change Data Capture(CDC) : 데이터베이스에서 발생하는 변경 사항을 실시간으로 추적하고 기록하는 방식

## 시계열(Time-series) 데이터베이스란 무엇인가요?
- 시간에 따른 데이터 변화를 저장하고 관리하는데 최적화된 데이터베이스 시스템
- 타임스탬프를 기준으로 정렬된 데이터를 핸들링함
- 대용량 데이터를 빠르게 저장할 수 있도록 최적화되어있음
- 데이터가 반복적인 패턴을 가질 수 있으므로 이를 위해서 데이터 압축 기법을 적용하여 스토리지 비용 절감
- influxDB, TimescaleDB, Druid
## 데이터베이스에서 자동 증가(Autoincrement)와 시퀀스(Sequence)의 차이점은 무엇인가요?
> 자동 증가(Autoincrement)
- 테이블에 레코드가 추가될 때마다 특정 컬럼의 값이 자동으로 증가하는 기능. 주로 기본키로 사용
> 시퀀스(Sequence)
- 독립적인 객체, 데이터베이스에서 고유한 값을 생성할 때 사용.
- 테이블과 별도로 정의되며, 여러 테이블에서 공유 가능

## 데이터베이스에서 클러스터링 지수(Clustered Index)란 무엇인가요?
- 데이터베이스에서 데이터가 물리적으로 정렬되어 저장되어 있는 방식
- 클러스터디 인덱스가 적용된 컬럼의 값을 기준으로 테이블의 실제 데이터가 정렬되어 있어서, 클러스터드 인덱스를 사용하면 데이터 검색시 빠르게 접근 가능


