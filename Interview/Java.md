
### Java

## 1. JVM의 구조와 Java의 실행방식을 설명해주세요. 

> java의 실행방식 <br>
- java 코드는 javac 컴파일러에 의해 java 바이트 코드(.class)로 변환
- java 바이트 코드는 jvm에 의해 메모리로 로드되고, 검증된 후 실행
- jvm의 Execution Engine은 인터프리터와 JIT 컴파일러를 사용해 바이트코드를 해석하거나 기계어로 
변환해 실행
- jvm은 메모리를 자동으로 관리하며, 필요시 JNI를 통해 네이티브 메서드(c, c++ 등)도 호출
- 프로그램 실행이 완료되면 jvm은 cg과 리소스 해제를 통해 메모리를 정리하고 종료

> jvm 역할 <br>

자바 애플리케이션을 클래스 로더를 통해 읽어 자바 api와 함꼐 실행하는 것

- Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올림
- Runtine Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석 
- 이 과정에서 Execution Engine에 의해 cg의 작동과 스레드 동기화가 이루어짐.

> jvm 구조 <br>

클래스 로더 <br>
 - jvm 내로 .class 파일을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치 
 
실행엔진 ( Execution Engine ) 
 - 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행 <br>
   ( 인터프리터와 JIT 컴파일러 방식을 혼합하여 바이트 코드 실행) 
 * 인터프리터 <br>
   : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 ( 전체적인 속도는 느림 ) 
 * JIT 컴파일러 (Just in time) <br>
   : 인터프리터의 단점을 보완하기 위해 도입. 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 native code로 변경하고, 
   그 이후에는 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드(c, c++) 로 직접 실행하는 방식
 * 가비지 콜렉터 (Garbage Collector) <br>
 : heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수. 개발자가 따로 메모리 관리를 하지않아도 됨.


런타임 데이터 영역 (Runtime Data Areas)
 - jvm의 메모리 영역. 자바 애플리케이션이 실행할 때 사용되는 데이터들을 적재하는 영역

 * 메소드 영역 (Method Area) <br>
 : jvm이 시작될때 생성되는 공간. 바이트 코드를 처음 메모리 공간에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간 <br>
 : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름, 리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성 
 * 힙 영역 (Heap Area) <br>
 : 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역. <br>
 : new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 <br>
 : CG 대상
 
 * 스택 영역 (Stack Area) <br>
 : 메소드가 호출될때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장 <br>
 : 임시적으로 사용되는 변수, 정보들이 저장되는 영역
 * PC Register ( Program Counter register ) <br>
 : 스레드가 시작될때 생성. 현재 수행중인 jvm 명령어 주소를 저장하는 공간. <br>
 * 네이티브 메소드 스택 (Native Method Stack) <br>
 : 기계어로 작성된 프로그램을 실행시키는 영역
 
자바 네이티브 인터페이스
- 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공 <br>

네이티브 메소드 라이브러리 
- c, c++ 로 작성된 라이브러리를 칭함.

## 2. GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

> 정의 
 - 자바의 메모리 관리 방법중 하나로 jvm의 heap 영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

> 필요이유 
 - 메모리 누수 방지 : 사용하지 않는 객체를 해제하지않으면, 메모리 누수 발생 
 - 안전성 향상 : 수동으로 메모리 관리시의 오류를 방지하여 프로그램의 안정성 증진
동작방식 
 : Mark and Sweep 알고리즘 기반으로 동작
 - Marking : 루트 객체에서 그래프 순회를 통해 참조되고 있는 모든 객체 추적
 - Sweeping : 마킹 단계에서 unreachable 상태로 표시된 객체들을 heap에서 제거
 - Compacting : 메모리 단편화를 방지하기 위해 남아있는 객체들을 한쪽으로 모아서 연속적인 메모리 블록을 만듬
 
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

## 3. 컬렉션 프레임워크에 대해서 설명해주세요.
> 정의
-  객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스들의 집합.( 자료구조의 종류를 자바 클래스로 구현한 모음집 ) <br>
- Collection 인터페이스와 Map 인터페이스로 나뉨 
> 종류 
- List : 순서가 있는 요소의 집합. 중복 요소 허용 (arraylist, linkedlist, vector) 
( 배열과 리스트의 차이점은 리스트는 자료형 크기가 고정이 아닌데, 배열은 고정) 
- Set : 순서 보장 없음. 중복되지않는 요소의 집합 (hashset, linkedhashset..), 순서가 없으므로 get 메서드 없음
- Queue : 선입선출 구조. 
- Map : key-value 쌍으로 데이터 저장. 키 중복 불가. value 중복 가능 (hashmap, linkedhashmap..) 


## 4. 제네릭에 대해서 설명해주세요.
> 정의
- java에서 코드의 재사용성과 타입 안정성을 높이기 위해 도입된 기능.
> 특징
- 제네릭을 사용하면 클래스나 메서드에서 사용할 데이터 타입을 외부에서 지정할 수 있어, 다양한 타입에 대해 동일한 코드를 작성할 수 있다. 
- 제네릭을 사용하면 컴파일 시점에서 타입 검사가 이루어지기 때문에 런타임에서 발생할 수 있는 classCastException을 방지할 수 있다. 


## 5. 애노테이션에 대해서 설명해주세요.
> 정의
- java에서 메타데이터를 제공하는 일종의 마커로, 코드에 추가적인 정보 제공 및 특정 동작을 수행하도록 하는데 사용
> 특징
- 주석처럼 코드에 부가적인 정보를 제공, 컴파일러나 런타임시에도 정보 활용 가능
> 예시
- 컴파일러 지시 : @Override, @deprecated 처럼 컴파일러에게 특정 동작을 지시
- 런타임 지시 : @Autowired 처럼 스프링 프레임워크에서 빈 주입 등 런타임 시 특정 기능을 자동으로 처리하는 동작 지시
- 빌드 및 배포 도구 : @Entity, @Table 등 JPA 어노테이션으로 ORM을 정의하며, 엔티티 클래스가 디비 데이블과 어떻게 매핑되는지 지정.
- 커스텀 어노테이션을 정의도 가능. @interface 어노테이션을 지정.


## 6. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
> 오버라이딩 
- 부모 클래스에서 상속받은 메서드르 자식클래스에서 재정의. 부모 클래스와 자식 클래스 간의 관계에서 발생
			  상속받은 메서드를 자식 클래스에서 재정의하여 다르게 동작하도록 할때 사용 

> 오버로딩
- 같은 이름의 메서드를 여러개 정의 하지만, 매개변수의 타입이나 개수가 다르게 정의하는것을 의미. 같은 클래스에서 발생
		    같은 이름의 메서드를 다양한 방법으로 사용할 수 있도록 할 때 사용

## 7. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 추상 클래스는 단일 상속이지만, 인터페이스는 다중 구현이 가능 
- 추상 클래스는 필드와 메서드를 모두 가질 수 있지만, 인터페이스는 기본적인 메서드만 정의 가능
- 추상 클래스는 관계를 명확히 하고, 부모의 기능을 확장시키는데 목적이 있지만, 인터페이스는 클래스가 특정 기능을 구현하도록 강제하는 목적이 있습니다. 



## 8. 클래스는 무엇이고 객체는 무엇인가요?
> 클래스
- 객체를 만들기 위한 설계도, 정의, 템플릿. 객체의 속성과 메서드는 정의하지만, 클래스 자체가 메모리에 할당되지는 않음.
> 객체
- 클래스를 기반으로 만들어진 실제 인스턴스. 메모리에 할당.
> 정리
- 클래스는 객체 지향 프로그래밍의 기본 단위로 객체를 생성하지 위한 설계도이고, 객체는 이 클래스를 기반으로 생성된 실체. 
실제로 프로그램에서 사용되는 데이터와 기능을 포함한 인스턴스. 


