# 네트워크 보안
## HTTPS는 어떻게 데이터를 보호하나요?
## TLS/SSL 핸드셰이크 과정은 어떻게 이루어지나요?
## MITM(중간자 공격)이란 무엇이며, 이를 방어하는 방법은 무엇인가요?
## DDoS 공격이란 무엇이며, 서버에서 이를 방어하는 방법은 무엇인가요?
## CORS는 어떻게 웹 보안에 기여하나요?
## 네트워크 방화벽의 역할은 무엇인가요?
## SSH는 어떻게 데이터를 암호화하나요?
## API 호출 시 OAuth 인증 방식을 설명해주세요.
## SQL 인젝션 공격이란 무엇이며, 이를 방어하는 방법은 무엇인가요?
## XSS(Cross-Site Scripting)란 무엇이며, 이를 방어하기 위한 방법은 무엇인가요?

# 네트워크 성능 최적화
## CDN(Content Delivery Network)이란 무엇이며, 왜 사용되나요?
> CDN 이란?
- 분산된 여러 서버를 통해 사용자에게 콘텐츠를 더 빠르고 안정적으로 제공하는 네트워크 시스템
- 인터넷 사용자와 콘텐츠 서버 사이에 위치하며, 물리적으로 가까운 서버에서 콘텐츠를 제공함으로써 전송속도를 최적화 하고, 서버의 부하를 분산

> 작동 방식 및 구성 요소 
- 엣지 서버( Edge server ) : CDN의 분산된 서버 중 하나로 사용자의 가까운 위치에 있는 서버
  
1. 사용자가 웹사이트에 콘텐츠 요청
2. DNS 서버를 통해 해당 콘텐츠를 어디서 제공할 것인지 결정하고, CDN은 사용자의 지리적 위치에 가장 가까운 엣지 서버(Edge server)를 찾아 연결
3. 캐시 히트(Cache Hit) : 사용자와 가까운 CDN 엣지 서버에 사용자가 요청한 콘텐스가 캐시되어 있으면, 즉시 캐싱된 콘텐츠를 사용자에게 제공
4. 사용자가 요청한 콘텐츠가 엣지 서버에 없다면 캐시 미스가 발생
4-1. CDN 엣지 서버는 원본 서버에 요청을 보내 해당 콘텐츠를 가져옴
4.2. 엣지 서버는 원본 서버에서 받은 콘텐츠를 사용자에게 제공하는 동시에 엣지 서버에도 캐싱해줌

> CDN 장점
- 콘텐츠 전송 속도 향상 : 분산된 서버 네트워크를 통해 사용자와 가까운 위치에서 콘텐츠를 제공하므로 콘텐츠 전송 속도가 크게 향상
- 서버 부하 분산 : 트래픽이 특정 서버에 몰리지 않게 분산시킬 수 있음
- 가용성, 안정성 증가 : 트래픽 분산을 통해 DDoS 공격과 같은 트래픽 과부하 공격에도 강하며, 특정 서버에 장애가 발생하더라도 다른 서버가 이를 대신 처리 가능
- 온라인게임, 파일 배포, 비디오 스트리밍 등에 사용

> CDN이 없다면, 한국에 있는 사용자가 미국에 있는 서버에 접속이 불가능한가요?
- 서버에 접속 할수는 있으나, 접속 속도가 느리고, 네트워크 지연 및 서버 부하로 인해 성능 저하가 발생할 수 있음

## 로드 밸런싱이란 무엇이며, 어떤 방식으로 구현되나요?
> 로드 밸런싱 (Load Balancing )이란?
- 네트워크 트래픽을 서버로 분산시켜 서버의 과부하를 방지하고 서비스 성능과 가용성을 유지하는 기술
- 클라이언트와 서버풀 사이에 위치
- Scale-out 방식으로 서버를 증설했을 경우 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드 밸런싱 필요

> 동작 방식
- 라운드 로빈 방식 (Round Robin)
  + 클라이언트 요청을 순차적으로 서버에 분배.
  + 가장 기본적인 방식이고 간단하며 균등하게 트래픽을 분산할 수 있음
  + 각 서버의 부하 상태를 고려하지 않으므로, 서버의 처리 능력이 다를 경우 비효율적일수도 있음 
- 가중 라운드 로빈 방식 (Weighted Round Robin)
  + 각 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분
  + 서버의 트래픽 처리 능력이 상이한 경우 사용되는 방식
  + 동적으로 변하는 서버 상태를 실시간으로 반영하진 못함 ( 가중치는 서버가 처음 설정될때 미리 지정 ) 
- IP 해시 방식 (IP Hash)
  + 사용자의 ip 주소를 특정 서버로 매핑하여 요청을 처리하는 방식
  + 사용자의 ip를 해싱해 로드를 분배하므로 사용자가 항상 동일한 서버로 연결되는 것을 보장 
  + 트래픽이 불균형하게 분배될 수 있음
- 최소 연결 방식 (Least Connections)
  + 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 우선적으로 트래픽을 배분
  + 세션이 길어지는 빈도가 잦거나, 분배된 트래픽들이 일정하지 않은 경우에 적합
  + 서버의 자원을 효율적으로 활용 가능
  + 각 서버의 실제 처리 능력과는 무관하게 연결 수에만 기반하므로, 요청의 복잡도에 따라 한 서버에 과부하가 걸릴수 있음 
- 최소 응답 시간 방식 (Least Response Time)
  + 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 배분
  + 가장 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분하는 방
  + 각 서버의 응답 시간 측정과 모니터링이 필요하므로 시스템이 복잡해질수 있음 

> 유형
- L4 로드 밸런싱 ( 전송계층 기반 ) 
  + TCP, UDP 같은 전송 계층의 정보를 기반으로 트래픽을 분배
  + 데이터 내용은 보지않고, 패킷 레벨에서만 로드를 분산하므로 속도가 빠르고 효율이 높음
  + 데이터의 내용을 복호화할 필요가 없어서 안전함
  + L7보다 비용이 저렴
  + 사용자의 IP가 수시로 바뀌는 경우라면 연속적인 서비스 제공 어려움
- L7 로드 밸런싱 ( 응용 계층 기반 )
  + TCP, UDP, HTTP의 URI, FTP의 파일명, 쿠키 정보 등을 바탕으로 트래픽 분배
  + 상위 계층에서 로드를 분산하므로 섬세한 라우팅 가능
  + 캐싱 기능을 제공
  + 비정상적인 트래픽을 사전에 필터링 할 수 있어서 서비스 안정성이 높음
  + 패킷의 내용을 복호화해야 하므로 비용이 높음
  + 클라이언트가 로드밸런서와 인증서를 공유해야 하므로 공격자가 로드밸런스를 통해 클라이언트 데이터에 접근할 보안 상의 위험성이 존재 

## 캐싱이란 무엇이며, 서버 성능에 어떤 영향을 미치나요?
- 자주 사용되는 데이터를 캐시에 저장하여, 다시 요청될때 빠르게 제공하는 기술

> 캐싱 종류
- 클라이언트 캐싱 : 웹 브라우저에서 캐스를 사용하여, 서버에 재요청하지 않고 로컬 캐시에서 데이터 제공
- 서버 캐싱 : 자주 요청되는 데이터를 서버 메모리나 디스크 캐시에 저장하여 빠르게 처리
- 프록시 캐싱 : CDN, 프록시 서버가 콘텐츠를 캐싱하여, 서버가 아닌 프록시에서 데이터를 제공하는 방식
- 데이터베이스 캐싱 : DB에서 자주 실행되는 쿼리의 결과를 캐시하여 성능을 최적화 
> 서버 성능에 미치는 영향
- 서버가 데이터를 다시 처리하거나 계산할 필요가 없기 때문에, 응답 속도 향상
- 동일한 요청에 대해 중복된 계산을 반복하지 않으므로 서버의 CPU, 메모리 등 리소스 사용량 줄일 수 있음
- 서버가 처리할 수 있는 최대 트래픽 용량을 늘림 ( ex. CDN 캐시를 사용하면 분산된 서버에서 콘텐츠를 제공하여 서버에 대한 트래픽을 줄이고, 사용자가 더 빠르게 콘텐츠에 접근 가능 )
- 데이터가 사용자와 가까운 위치에 저장되므로 네트워크 지연을 줄일 수 있음
- 데이터베이스 쿼리 횟수를 줄일 수 있으므로 데이터베이스의 부하를 감소 시킬수 있음
- 캐시된 데이터가 원본 서버의 데이터와 동기화되지 않으면, 오래된 데이터가 제공될수 있으므로 TTL(time to live), 캐시 무효화 전략을 적절하게 사용해야함
- 캐시 전략을 잘못 설계할 경우 캐싱할 데이터가 많아지면서 서버의 메모리 사용량을 증가할수 있음

## 레이턴시(latency)란 무엇이며, 이를 줄이기 위한 방법은 무엇인가요?
> 레이턴시 (latency)
- 데이터 전송 요청과 응답 사이에 발생하는 지연 시간 ( 서버에서 처리되어 사용자에게 전달되는데 걸리는 시간 )
- 물리적 거리, 네트워크 혼잡도, 서버 처리 시간, 라우팅 등의 영향을 받을 수 있음

> 줄이기 위한 방법
- CDN 사용
  + 분산된 서버 네트워크를 통해 사용자와 가까운 서버에서 콘텐츠를 제공하여 물리적 거리를 줄요 레이턴시 최소화
  + 이미지, CSS 등과 같이 정적 콘텐츠를 제공하는 웹사이트, 비디오 스트리밍 등 
- 캐싱
  + 데이터를 캐시에 저장하여, 서버나 DB의 재처리 없이 즉시 제공함으로써 레이턴시 최소화
  + 정적 파일 캐싱, db 결과 캐싱, 브라우저 캐싱
- 로드 밸런싱
  + 여러 서버에 트래픽을 분산시켜 각 서버에 걸리는 부하를 줄이고, 레이턴시 최적화
  + 대규모 트래픽 처리하는 애플리케이션, api 서버
- 데이터 압축
  + 전송할 데이터를 압축하여 파일 크기를 줄이고, 네트워크 전송시간 단축
  + 웹 페이지, 이미지 등을 압축 알고리즘으로 압축

## 서버에서 패킷 손실이 발생했을 때 어떻게 해결하나요?
- 네트워크 장비 및 연결 상태 점검
  + 네트워크 장비( 라우터, 스위치, 방화벽 등 )의 물리적 문제나 잘못된 구성이 패킷 손실 원인이 될 수 있음
  + 장비 점검 : 네트워크 장비 동작 확인하고, 케이블, 포트 상태 등을 점검
  + 네트워크 장비 재부팅 : 일시적인 문제로 패킷 손실이 발생할 수 있으므로 장비 재부팅
  + 펌웨어 업데이트 
- 네트워크 트래픽 관리 및 로드 밸런싱
  + 네트워크 대역폭을 초과하는 과도한 트래픽은 패킷 손실을 유발
  + 로드 밸런싱 : 여러 서버에 트래픽 분산
  + QoS( Quality of Service ) 설정 : 중요한 패킷이 우선 처리되도록 네트워크 장비에서 QoS을 적용해 트래픽 관리
  + QoS( Quality of Service ) : 한정된 네트워크 용량으로 트래픽을 제어하는 기술을 활용하는 것 
  + 네트워크 대역폭 증가 : 트래픽이 네트워크 용량을 초과하는 경우는 더 높은 대역폭을 가진 네트워크 장비나 인터넷 회선으로 업그레이드 
- TCP/IP 설정 최적화
  + TCP 패킷 손실이 발생하면 재전송 메커니증을 통해 손실된 패킷을 다시 전송하는데, 설정이 잘못되면 성능 저하가 발생할 수 있음
  + TCP window size 조절 : 대역폭에 맞게 window size를 조정하여 패킷 손실을 줄일수 있음
  + RTO ( Retransmission Timeout ) 조정 : 재전송 시간 간격을 최적화하여 패킷 손실 시 빠르게 복구할 수 있도록 조정
- MTU ( Maximum Transmission Unit ) 데이터 조정
  + MTU 값이 너무 크게 설정되어 있으면, 패킷이 여러 조각으로 나뉘면서 패킷 손실이 발생
  + MTU 값 최적화 : 네트워크 경로 상에서 허용 가능한 최적의 MTU 값을 설정하여 패킷이 단편화되는 문제를 방지하고, 패킷 손실 줄임 

## 지연 발생의 원인은 무엇이며, 이를 해결하기 위한 방법은 무엇인가요?

## 대역폭(bandwidth)란 무엇인가요?
- 네트워크에서 일정 시간 동안 전송할 수 있는 데이터의 최대 용량. 네트워크 처리 용량
- bps, Mbps, Gbps 단위로 표현
  
## 네트워크 혼잡이 발생할 경우, TCP는 이를 어떻게 처리하나요?

## 클라이언트와 서버 간 데이터 전송 속도를 최적화하기 위한 방법은 무엇인가요?

## QoS(Quality of Service)란 무엇이며, 왜 중요하나요?


# 데이터 통신 및 프로토콜
## TCP 3-way 핸드셰이크 과정은 무엇인가요?
> 개념
- TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정
> 과정
1. 클라이언트 -> 서버 
- 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 전송
- 클라이언트는 SYN을 보내고 SYN-ACK 응답을 기다리는 SYN_SENT 상태가 됨
2. 서버 -> 클라이언트
- 서버는 syn 요청을 받고 클라이언트에게 요청을 수락하는 의미의 SYN-ACK가 설정된 패킷을 전송
- 클라이언트가 다시 ACK로 응답하기를 기다림
- 서버는 SYN_RECEIVED 상태가 됨
3. 클라이언트 -> 서버
- 클라이언트는 서버에서 ACK를 전송
- 이후로부터 연결이 이루어지고, 데이터 송수신 가능
- 서버는 ESTABLISHED 상태가 됨 
  
## 4-way 종료 과정(TCP 연결 종료)은 어떻게 이루어지나요?
- 세션을 종료하기 위해 수행되는 절차
> 과정
1. 클라이언트가 접속을 끊기 위해 CLOSE() 함수를 호출하면, FIN 플래스를 서버에 보내게 되고, 클라이언트는 FIN_WAIT1상태로 변경
2. 서버는 클라이언트가 CLOSE() 한다는 것을 알게되고 CLOSE_WAIT 상태로 바꾼 후 ACK 플래그를 전송.
3. ACK를 받은 클라이언트는 FIN_WAIT2로 변경하고, 이때 서버는 CLOSE()함수를 호출하고 FIN 플래그를 클라이언트에게 전송
4. 서버도 연결을 받았다는 신호를 클라이언트가 수신하면 ACK 플래그를 서버에 전송한후 TIME_WAIT 상태로 변경 후 모든것이 완료되면 CLOSED 상태로 변경

> 플래그, 패킷 차이점
- 플래그 : TCP 헤더에서 특정 상태나 동작을 나타내는 1비트 크기의 제어신호 (SYN, ACK, FIN 등의 플래그 존재)
- 패킷 : 네트워크를 통해 전송되는 데이터의 기본 단위. 헤더와 데이터로 구성되며 헤더에는 플래그, 시퀀스 번호 등이 있고, 데이터 부분에는 실제 전송하려는 내용이 포함

- https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90#%F0%9F%A4%9D_3-way_handshake_%EA%B3%BC%EC%A0%95

## 데이터 전송 중 손실이 발생할 때 TCP는 어떻게 처리하나요?
> TCP 제어기능
- 흐름제어 : 전송되는 데이터의 양을 조절
- 오류제어 : 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처하는 방법
- 혼잡제어 : 네트워크 혼잡에 대처

> 패킷 손실 감지 및 재전송
-  패킷이 네트워크에서 손실될 수 있는데, TCP는 이를 감지하고 재전송하는 방식으로 복구
1. 타이머 기반 재전송 ( RTO, Retransmission Timeout )
- 송신자는 데이터를 전송한 후 ACK를 기다리는데, 정해진 시간 내에 ACK가 도착하지 않으면 패킷이 손실된것으로 간주하고 해당 패킷을 재전송
2. 중복 ACK 기반 빠른 재전송 ( Fast Retransmit )
- 수신자는 패킷을 순서대로 받지 못하면 중복된 ACK를 송신자에게 보냄
- 3개의 중복 ACK를 받으면 송신자는 타이머 만료를 기다리지 않고 즉시 손실된 패킷 재전송
  
> 데이터 손상 감지 및 재전송 (checksum) 
- 데이터가 전송 중 손상되는 경우를 감지하고 이를 복구하기 위해 체크섬 사용
- 각 패킷의 헤더와 데이터를 대상으로 checksum을 계산하여 데이터가 전송 중 손상되었는지 확인
- 송신자가 패킷을 전송할때 checksum값을 계산해 패킷에 포함
- 수신자는 수신된 데이터를 기반으로 다시 checksum을 계산하여 송신자의 checksum과 비교
- 일치하지 않으면 데이터 손상으로 판단하고 해당 패킷을 버리고 송신자에게 재전송 요청
- checksum : 데이터 전송 중 오류를 감지하기 위해 전송되는 데이터에 대해 계산된 값. 데이터의 무결성 검증에 사용

> 중복 데이터 감지 및 제거
- TCP는 시퀀스 번호를 사용하여 패킷이 중복되었는지 확인
- 중복된 패킷이 수신되면 TCP는 이를 무시하고, 정상적인 시퀀스에 맞는 데이터만 처리
  
> 순서 보장 및 데이터 재조립
- TCP는 데이터를 순서대로 수신할 수 있도록 보장하는 시퀀스 번호 사용
- 패킷이 순서대로 도작하지 않는다면 TCP는 패킷 재조립 가능
- 수신자는 패킷이 순서대로 도착하지 않으면 재조립 버퍼에 일시적으로 저장하고, 필요한 패킷이 도착하면 이를 재조립 

> ARQ (Automatic Repeat reQuest)
- TCP에서 사용하는 오류제어 방식 중 하나로 오류 발생시 자동으로 재전송을 요구하는 기술
- STOP-WAIT ARQ : 송신자는 패킷을 하나 전송한 후, 수신자로부터 해당 패킷에 대한 ACK을 받을때까지 대기하고, 받으면 그 다음 패킷을 전송. 일정시간내에 ACK를 받지 못하면 패킷손실로 간주하고 재전송 수행
- GO-BACK-N ARQ : 송신자는 여러 패킷을 연속해서 전송할 수 있으며, 수신자는 이 패킷에 대해서 순차적으로 ACK 전송. 만약 특정 패킷에 오류 발생시 그 이후로 전송된 모든 패킷이 재전송됨
- Selective Repeat ARQ : 송신자는 여러 패킷을 전송할 수 있고, 수신자는 손실되거나 오류가 발생한 특정 패킷만 재전송 요청. 손실되지 않은 패킷은 ACK로 확인하고, 손실된 패킷만 재전송 

## TCP에서 슬라이딩 윈도우 프로토콜의 역할은 무엇인가요?
> 슬라이딩 윈도우란?
- 윈도우의 크기를 동적으로 조절하며 패킷 전송을 가능하게 하는 프로토콜
- 오류 제어와 흐름제어 기능을 지원
  
> 슬라이딩 윈도우 작동 방식
- 송신자는 윈도우의 크기만큼 패킷을 전송하고, 각 패킷에 순서 번호를 부여
- 수신자는 패킷을 받으면, 순서 번호에 따라 자신의 윈도우를 저장하고 가장 작은 번호를 가진 패킷부터 상위 계층으로 전달. 송신자에게 ACK 를 보냄
- 송신자는 ACK를 받으면 자신의 윈도우를 오른쪽으로 이동시키고, 새로운 패킷을 전송. ACK가 오지않은 패킷은 타이머를 설정하여 일정시간이 지나면 재전송
- 수신자는 자신의 윈도우를 왼쪽으로 이동시키면서 상위계층으로 전달할수있는 패킷을 찾음. 만약 순서대로 받지 못한 패킷이 있다면 NAK를 보내 재전송 요청
> 역할 
- 데이터 흐름 제어
  + 송신자가 수신자의 처리 능력에 맞춰 데이터를 전송할 수 있도록 제어하는 역할
  + 수신자가 처리할 수 있는 양만큼 데이터를 전송하여 과부하 방지
- 데이터 순서 보장
  + 패킷마다 시퀀스 번호가 부여되며, 수신자는 이 시퀀스 번호를 기준으로 데이터를 재조립하고, 누락된 패킷이 있는 경우 재전송을 요청
- 혼잡제어 
  + 네트워크의 혼잡 상태에 따라서 윈도우 크기를 동적으로 조절
- 오류 제어
  + 송신자가 전송한 패킷에 대한 ACK를 일정 시간 안에 받지 못하면 해당 패킷이 손실된 것으로 간주하고 재전송

> 수신자는 송신자에게 자신이 수신할 수 있는 윈도우의 크기를 어떻게 알릴수 있는가?
- 수신자는 TCP 헤더의 윈도우 크기 필드를 사용하여 자신이 수신할 수 있는 데이터의 양을 송신자에 알림
- 송신자는 이 값을 기준으로 데이터 전송량을 조절하여 흐름제어

## HTTP 상태 코드 200, 301, 404, 500의 차이점을 설명해주세요.
> 200
- 서버가 요청된 리소스를 성공적으로 처리하고 그 결과를 클라이언트에게 반환할때 사용
> 301
- 요청한 리소스가 영구적으로 다른 URL로 이동했음을 나타내는 코드
- 서버는 클라이언트에게 새로운 URL을 제시하며 클라이언트는 해당 URL로 자동으로 리다이렉션 
> 404
- 클라이언트가 요청한 리소스를 찾을 수 없는 경우 
> 500
- 서버에 오류가 발생하여 정상적으로 요청을 처리할 수 없을때 

## HTTP/1.1과 HTTP/2의 주요 차이점은 무엇인가요?
- 멀티 플렉싱 : HTTP/1.1은 한번에 하나의 요청만 처리가능하지만, HTTP/2는 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리 가능
- 헤더 압축 : HTTP/1.1은 각 요청마다 전체 헤더를 압축 없이 전송. HTTP/2는 HPACK을 사용해 헤더 정보를 압축하여 효율성 향상
- 서버 푸시 : HTTP/1.1는 클라이언트가 요청한 리소스만 전송. HTTP/2는 클라이언트가 요청하지 않은 리소스도 서버가 미리 전송 가능
- 데이터 전송 방식 : HTTP/1.1는 텍스트 기반 프로토콜. HTTP/2는 이진 프로토콜을 사용해 더 효율적인 데이터 전송
- 연결 유지와 성능 : HTTP/1.1는 KEEP-ALIVE로 연결 유지하며 요청이 순차적으로 처리 HTTP/2는 하나의 연결에서 여러 요청을 동시에 처리하며 성능 개선
- 우선순위 지정 : HTTP/1.1는 요청 간에 우선순위를 지정할 수 없음 HTTP/2는 요청 간에 우선순위를 지정할 수 있어 중요한 리소스가 먼저 로드
- 보안 : HTTP/1.1는 기본적으로 암호화를 요구하지않지만, HTTPS를 통해 암호화 가능. HTTP/2는 대부분 HTTPS 위에서만 동작하도록 설계됨

> HPACK이란?
- HTTP/2에서 헤더 필드를 압축하여 전송 선능을 향상시키기 위한 압축 알고리즘으로, 정적 및 동적 테이블을 사용해 중복된 헤더 필드를 참조하고, 해프만 코딩을 통해 데이터를 효율적으로 압축함으로써 대역폭 낭비를 줄이고 데이터 전송 속도 향상
- 헤더 필드의 중복 제거
    + 정적 테이블 : 자주 사용되는 HTTP 헤더 필드를 미리 정의한 테이블
    + 동적 테이블 : HTTP/2 연결에서 동적으로 생성되는 테이블. 클라이언트와 서버는 이전에 전송된 헤더 필드를 동적 테이블에 저장하고, 이후 요청에서는 동적 테이블에서 저장된 값을 참조하여 헤더 필드를 다시 전송할 필요 없음
- HUFFMAN CODING이라는 데이터 압축 기법을 사용하여 헤더 필드를 이진 압축 . 자주 나타나는 문자를 짧은 코드로, 자주 나타나지 않는 문자를 긴 코드로 인코딩하여 효율적으로 데이터를 압축하는 방식 
  
## REST API와 SOAP의 차이점은 무엇인가요?
> REST API (Representational State Transfer)
- 웹 서비스 설계를 위한 아키텍쳐. HTTP 를 사용해 데이터를 관리하고 전달하는 방식
- 클라이언트와 서버간에 통신에서 상태를 유지하지 않는 설계를 따름
- HTTP 메서드(GET, POST, PUT, DELETE)를 사용해 리소스에 접근하며, 데이터는 JSON, XML등 다양한 형식으로 전송 가능
- 간단한 설계로 쉽게 확장 가능하며, 모바일 및 웹 애플리케이션에서 주로 사용

> SOAP (Simple Object Access Protocol)
- 프로토콜 기반의 웹 서비스 통신 방식. XML 형식을 사용해 클라이언트와 서버간의 메시지 주고받음
- REST보다 더 많은 표준을 정의하며 더 복잡하지만, 보안, 트랜잭션 및 ACID 측면에서 포괄적인 기능이 필요한 경우 좋을수있음 
- HTTP, SMTP, TCP와 같은 다양한 프로토콜 지원
- 모든 통신은 XML 기반으로 하며, 요청 및 응답 형식이 까다로움
- 높은 보안성 제공

> 차이점
- REST API는 HTTP를 사용해 데이터 중심의 간단하고 효율적인 통신을 제공하고, SOAP는 프로토콜 기반으로 XML 기반의 제한된 메시지 구조를 가지고 있어서 보안과 트랜잭션관리가 중요한 환경에서 사용

## 웹소켓(WebSocket)이란 무엇이며, HTTP와의 차이점은 무엇인가요?
> WebSocket
- 클라이언트와 서버간에 양방향 통신을 가능하게 하는 프로토콜
- 연결이 유지된 상태에서 실시간으로 데이터 주고받을 수 있음
- 채팅, 게임, 금융 거래 등 실시간 애플리케이션에서 사용
- 연결이 설정되면 클라이언트와 서버는 계속해서 연결된 상태로 유지

> 차이점 
- 웹 소켓은 양방향 실시간 통신을 제공하며 지속적인 연결을 통해 클라이언트와 서버간의 데이터를 주고받을 수있으므로 실시간 데이터 전송이 중요한 서비스에서 주로 사용됨.
- HTTP는 요청-응답 기반으로 작동하는 단방향 통신 프로토콜로 정적 데이터 전송에 적합. 각 요청은 독립적이며 서버와 클라이언트 간의 상태를 유지하지 않음. 

## MQTT(Message Queuing Telemetry Transport) 프로토콜은 무엇이며, 어떤 상황에서 사용되나요?
- 사물통신(M2M, Machine to Machine), 사물 인터넷(IoT, Internet of Things)와 같이 대역폭이 제한된 통신 환경에서 최족화하여 개발된 푸시 기술기반의 경량 메시지 전송 프로토콜
- 푸시기술에서 일반적으로 사용하는 클라이언트/서버 방식 대신, 메시지 매개자를 통해 송신자가 특정 메시지를 발행(publish)하고, 수신자가 메시지를 구독(subscribe)하는 방식 사용
- 매개자(broker)를 통해 메시지 송수신
- IoT 환경에서 많이 사용 (네트워크 대역폭과 전력소모가 제한적인 환경) 
- 센서 네트워크, 스마트 홈, 위성 통신 등 

## FTP와 SFTP의 차이점을 설명해주세요.
> FTP (File Transfer Protocol)
- TCP/TP 네트워크에서 파일을 전송하기 위한 표준 프로토콜
- 파일 전송 속도가 빠르고, 대부분의 서버에서 지원
- 액티브 모드 ( 서버가 클라이언트의 특정 포트로 데이터 연결을 설정 ) , 패시브 모드 ( 클라이언트가 서버의 데이터 포트에 연결을 설정 ) 이 있음
- 21번 포트로 제어명령을 보내고, 20번 포트로 파일 전송을 위해 추가적인 데이터 포트 사용
- 데이터 및 인증 정보가 암호화되지 않으므로 도청이나 해킹의 위험이 있음
- 보안이 크게 필요하지않거나, 내부 네트워크에서만 파일을 전송하는 경우 사용
  
> SFTP (Secure File Transfer Protocol)
- SSH 프로토콜 위에서 동작하는 파일 전송 프로토콜
- 데이터를 암호화하여 전송하므로 도청과 데이터 변조의 위험을 최소화
- 단일 포트(22번)만 사용하여 제어와 데이터 전송 모두 처리
- 인터넷을 통한 파일 전송이나 보안이 중요한 데이터 전송에 주로 사용

# 네트워크 기본 개념
## 네트워크에서 서버와 클라이언트는 각각 어떤 역할을 하나요?
> 서버
- 클라이언트의 요청을 처리하고 응답하는 역할
- 데이터베이스, 파일서버, 웹 서버 등 형태로 존재 
> 클라이언트
- 서버에 데이터를 요청하거나 정보는 제공받는 역할
- HTTP, FTP 등 네트워크 프로토콜을 통해 서버에 요청을 전송 

## HTTP와 HTTPS의 차이점은 무엇인가요?
> HTTP ( Hyper Text Transfer Protocol )
- 웹 브라우저(클라이언트)와 웹 서버가 데이터를 주고받기 위한 프로토콜
- OSI 애플리케이션 레벨의 프로토콜
- 암호화 되지 않은 평문 데이터 전송
  
> HTTPS ( Hyper Text Transfer Protocol Secure )
- HTTP에 SSL/TLS 암호화 프로토콜이 추가된 프로토콜
- 클라이언트와 서버 간의 데이터가 암호화되어 전송되므로 중간에 데이터가 변경되는 것을 방지 
- SSL/TLS 인증서를 사용하여 서버를 보증. 해당 인증서는 CA(Certificate Authority)에서 발급 

## TCP와 UDP의 차이점은 무엇인가요?
> TCP (Transmission Control Protocol)
- 연결 지향적 프로토콜로 신뢰성 있는 데이터 전송 보장
- 데이터 전송 전에 클라이언트와 서버간에 3-way handshaking, 4-way handshaking를 통해 연결 설정 후 데이터 주고받고 연결을 해제함 
- 네트워크 상태에 따라 전송 속도를 조절하여 네트워크 혼잡 방지
- 데이터 전송 중 클라이언트와 서버간의 연결 유지. 전송 완료되면 연결 해제
- 데이터 전송 후 상대로부터 응답(ACK)를 받아 패킷이 정상적으로 도착했는지 확인
- HTTP/HTTPS , SMTP, FTP 등 신뢰성이 중요한 서비스에 사용
  
> UDP (User Datagram Protocol)
- 비연결형 프로토콜로 빠른 데이터 전송을 보잠 
- 연결을 설정하고 해제하는 과정이 없고, 데이터의 신뢰성을 보장하지않음
- 연결 설정 과정이 없으므로 전송속도가 빠름
- TCP에 비해 프로토콜 구조가 단순하며 오버헤드가 적음
- 실시간 스트리밍, 온라인 게임 등 실시간 서비스에서 많이 사용

- https://dev-coco.tistory.com/144

> 차이점
- TCP는 연결형 프로토콜로 데이터를 전송하기 전에 연결을 설정하며, 신뢰성 있는 데이터 전송을 보장함
- UDP는 비연결형 프로토콜로 데이터를 전송하기 전에 연결을 설정하지 않으며, 데이터 전송이 빠르지만 신뢰성이 보장되지 않음 
  
## IP 주소란 무엇이며, 어떻게 분류되나요?
> IP 주소(Internet Protocol Address)란?
- 네트워크 상에서 각 장치가 서로 통신할 수 있도록 고유하게 할당된 숫자 주소
> IP 분류
1. 공인 IP (Public IP) / 사설 IP (Private IP)
-  공인 IP (Public IP)
      + 인터넷 서비스 제공자(ISP)로부터 할당받은 전 세계적으로 고유한 IP주소
      + 인터넷에 직접 연결된 장치가 사용하는 주소.
      + 웹사이트, 서버, 네트워크 장비 등 외부 네트워크와의 통신에 사용
-  사설 IP (Private IP)
      + 내부 네트워크에서만 사용되는 IP주소
      + 회사 내부에서 사용되며, 외부 인터넷과는 NAT(Network address Translation)를 통해 공인 IP를 통해 연결
      + 사설 IP 범위
      + 10.0.0.0 - 10.255.255.255
      + 172.16.0.0 - 172.31.255.255
      + 192.168.0.0 - 192.168.255.255

2. IPv4 / IPv6
- IPv4 (Internet Protocol version 4)
  + 32비트 숫자, 4개의 8비트를 점으로 구분 (192.168.0.1)
  + 0 ~ 255 사이의 숫자를 가지며 최대 약 43억개의 고유 주소 제공가능
  + 5가지 클래스로 분류
      + A class : 대규모 네트워크 환경(대기업)에서 사용, 첫번째 옥텟값의 10진수 범위 (0~127), 0.0.0.0 ~ 127.255.255.255
      + B class : 중간규모 네트워크 환경(중소기업, 대학교 등)에서 사용, 첫번째 옥텟값의 10진수 범위 (128~191), 128.0.0.0 ~ 191.255.255.255
      + C class : 소규모 네트워크 환경(소규모 회사, 개인)에서 사용, 첫번째 옥텟값의 10진수 범위 (192~223), 192.0.0.0 ~ 223.255.255.255  
      + D class , E class : 멀티캐스팅용, 연구/개발용으로 일반적으로 잘 사용되지 않음
- IPv6 (Internet Protocol version 6)
    + IPv4 주소가 부족해서 나오게됨
    + 128비트 숫자, 16진수 형식으로 8그룹으로 ":" 으로 구분 (2001:0db8:85a3:0000:0000:8a2e:0370:7334)

3. 고정 IP (Static IP) / 동적 IP (Dynamic IP)
- 고정 IP (Static IP)
    + 변하지 않는 고유의 IP 주소
    + 서버, 프린터 등 같은 IP 주소를 유지해야하는 장치에 사용
    + 설정된 후에 변경되지 않으며, 장치가 인터넷에 접속할 때마다 동일한 IP 주소 할당 
- 동적 IP (Dynamic IP)
    + DHCP(Dynamic Host Configuration Protocol)를 통해 네트워크에 연결될때마다 동적으로 할당되는 IP 주소
    + 개인 사용자, 일반 네트워크 장치에 사용

> DHCP(Dynamic Host Configuration Protocol)
- 네트워크 상에서 IP 주소와 네트워크 설정( 서브넷 마스크, 기본 게이트웨이, DNS 서버 )을 자동으로 할당해주는 프로토콜

## OSI 7계층 모델을 설명해주세요.
- 네트워크 통신을 계층별로 분류해놓은 모델

1. 물리 계층 (Physical Layer)
- 데이터를 전기 신호로 변환하여 물리적 형태로 변환하여 전달
- 케이블, 전선, 전파 등을 통해 비트 스트림이 전송되는 통로 제공
- 데이터 단위 : 비트 
2. 데이터링크 계층 (Data Link Layer)
- 물리 계층에서 발생할 수 있는 오류를 감지하고 수정하며, MAC 주소를 사용해 같은 네트워크 내에서 장치 간 데이터 전송 관리
- 데이터 단위 : 프레임 
3. 네트워크 계층 (Network Layer)
- 데이터를 IP 주소를 사용하여 다른 네트워크 간의 라우팅을 관리.
- 라우터가 작동하며, 데이터를 목적지까지 전달할 경로 설정 
- 패킷을 목적지 네트워크로 라우팅하고, 각 패킷이 목적지에 도달할 수 있도록 경로 설정
- 데이터 단위 : 패킷 
4. 전송 계층 (Transport Layer)
- 종단 간 통신을 제공하고, 데이터의 신뢰성 있는 전송 보장 ( TCP, UDP ) 
- 데이터 단위 : 세그먼트
5. 세션 계층 (Session Layer)
- 응용 프로그램 간의 통신 세션을 설정, 유지, 종료하는 역할
- 데이터 단위 : 데이터
6. 표현 계층 (Presentation Layer)
- 데이터를 표현하고 변환하는 역할. 
- 전송하는 데이터의 인코딩, 디코딩, 암호화, 코드 변화
- 데이터 단위 : 데이터 
7. 애플리케이션 계층 (Application Layer)
- 사용자와 직접적으로 상호작용하는 프로그램 서비스 제공 담당
- HTTP, FTP, SMTP
- 데이터 단위 : 메시지, 데이터 


## TCP/IP 모델을 OSI 모델과 비교하여 설명해주세요.
> 네트워크 접근 계층 (Network Access Layer)
-  인터넷을 구성하는 각각 다른 물리적 네트워크의 연결과 관련된 기능 수행
-  OSI 7계층의 물리계층 + 데이터 링크 계층
> 인터넷 계층 (Internet Layer)
- 데이터를 패킷으로 분할하고 목적지까지 전송 경로 설정 ( IP )
- OSI 7계층의 네트워크 계층
> 전송 계층 (Transport Layer)
- 송신측과 수신측 사이에서 데이터를 전송하는 기능 수행
- OSI 7계층의 전송 계층
> 응용 계층 
- 사용자와 직접적으로 상호작용하는 프로그램 서비스 제공 담당
- OSI 7계층의 응용 계층 + 표현 계층 + 세션 계층

> 차이점
- OSI 7계층은 이론적인 참조 모델이며, TCP/IP는 실제로 구현된 프로토콜 스택

## DNS의 역할은 무엇이며, 작동 방식은 어떻게 되나요?
> DNS(Domain Name System) 란?
- 도메인 이름을 IP 주소로 변환해주는 시스템
- 사용자가 도메인 주소를 통해 웹사이트에 쉽게 접근할 수 있도록 함
> 작동 방식
1. 사용자가 브라우저에 도메인 입력 ( www.google.com )
2. 사용자의 캐시(운영체제 또는 브라우저에 저장된 임시 DNS 정보)에 도메인에 대한 IP 주소가 저장되어 있는지 확인 -> 캐시에 정보가 있으면 바로 IP 주소 반환하여 요청된 웹사이트에 연결
3. 캐시에 정보가 없으면, 사용자의 컴퓨터는 DNS Resolver에 도메인 이름에 대한 IP 주소 요청
4. DNS Resolver는 루트 DNS 서버에 최상위 도메인 (TLD, Top-level Domain) 정보를 요청
5. 루트 DNS 서버는 DNS Resolver에게 .com의 TLD 서버의 주소를 반환
6. DNS Resolver는 TLD 서버에게 정보를 요청하면, TLD 서버는 google.com에 대한 권한있는 네임서버의 주소를 반환
7. DNS Resolver는 최종적으로 권한있는네임서버에 정보를 요청하면, 해당 서버는 www.google.com 도메인에 대한 IP주소를 DNS Resolver에게 반환
8. DNS Resolver는 해당 IP 주소를 사용자에게 반환하며, 캐시에 일정시간동안 저장
9. 사용자의 브라우저는 해당 IP 주소를 사용해 웹 서버에 접속하고, 사용자가 요청한 웹 페이지 가져옴

> DNS 서버 종류
- DNS resolve (DNS Recursive Server): 요청 받은 도메인에 매칭되는 IP 주소를 찾기 위해 DNS 쿼리를 수행. DNS 캐시 저장하는 곳
- 루트 DNS 서버 (Root Name Server): 순환 DNS 서버에서 처음으로 DNS 쿼리 요청을 보내는 서버. 해당 도메인의 확장자(.com, .net, .org 등)에 따른 TLD 네임 서버의 주소를 DNS Resolver에 응답.
- 최상위 도메인 DNS 서버 (TLD Name Server): 최상위 도메인(.com, .net, .org 등)에 대한 DNS 정보를 관리. 루트 DNS 서버와 권한 네임 서버의 중간 단계.
- 권한 네임 서버 (Authoritative Name Server): 도메인의 IP 주소를 응답해주는 최종 단계 DNS 서버.

  
## ARP(주소 결정 프로토콜, Address Resolution Protocol)란 무엇이며, 어떻게 작동하나요?
> ARP(주소 결정 프로토콜, Address Resolution Protocol)란?
- 네트워크에서 IP 주소를 통해 통신할때 해당 IP 주소에 대응하는 MAC 주소를 찾아주는 프로토콜
- 요청과 응답으로 구성된 프로토콜로 라우팅 되지 않는 단일 네트워크에서만 동작 (L2-L3사이에 있는 프로토콜)
- 단일 네트워크 : 같은 IP 주소 범위 내에 있는 장치들이 속한 네트워크 
> 동작원리
1. 송신자는 목적지 IP 주소를 지정해 패킷을 송신
2. 네트워크 계층의 IP 프로토콜이 ARP 프로토콜에게 ARP Request 메시지를 생성하도록 요청
3. 메시지는 데이터링크 계층으로 전달되고, 이더넷 프레임으로 캡슐화됨
4. 같은 네트워크에 있는 모든 장치(모든 호스트와 라우터)는 프레임을 수신 후 자신의 ARP 프로토콜에게 전달
5. 목적지 IP 주소가 일치하는 시스템은 자신의 물리주소를 포함하고 있는 ARP Reply 메시지 보냄
6. 송신자는 요청한 목적지 IP 주소에 대응하는 물리주소 획득

- https://coding-factory.tistory.com/720

## NAT(Network Address Translation)란 무엇인가요?
> NAT(Network Address Translation)란
- 라우터 등의 장비를 사용하여 다수의 private IP를 하나의 public IP로 변환하는 기술
- 주소변환 정보에 대해 IP 주소와 port 번호로 구성된 NAT Forwarding Table을 보관하고 있음

## 네트워크에서 CORS(Cross-Origin Resource Sharing)는 무엇인가요?
> CORS(Cross-Origin Resource Sharing)란?
- 웹 브라우저가 다른 출처의 리소스에 대한 접근을 허용하는 정책
- SOP 정책을 위반해도 CORS 정책에 따르면 다른출처의 리소스를 허용
  
> SOP(Same Origin Policy)
- 동일한 origin에서만 리소스를 공유할 수 있다는 정책
- Origin : Protocol + Host + Port 를 합친 URL ( https://www.google.com:3000 )

> CORS 동작
- 클라이언트에서 HTTP 요청 헤더에 Origin 정보를 담아서 전달
- 서버는 응답헤더에 Access-Control-Allow-Origin를 담아서 클라이언트에 전달
- 클라이언트에서 Origin과 서버가 보내준 Access-Control-Allow-Origin 비교
- 이때 유효하지 않다면 CORS 에러 발생

- https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F

## 기타 정리 사항
> URI / URL 
- URI (Uniform Resource Identifier, 자원의 식별자)
  + 자원이 어디에 있는지 자원 자체를 식별하는 방법
  + URL 보다 더 포괄적인 개념
  + URN(urn:doi:10.1000/182) , 메일 주소(mailto:someone@example.com), FTP 등 
- URL (Uniform Resource Locator, 위치)
  + 네트워크 상에 자원이 어디 있는지 위치를 알려주기 위한 규약
  + ex) "https://www.google.com:443/search?q=test&hl=ko"
      + shceme : "https" 프로토콜 사용
      + host : "www.google.com" 도메인명, IP 주소
      + port : "443"  접속 포트, 일반적으로 생략 가능
      + path : "search" 리소스 경로
      + query : "q=test&hl=ko" 웹서버에 제공하는 파라미터

> URL 웹 브라우저 요청 흐름
1. URL 입력 / DNS 조회
   - 사용자가 브라우저에 URL 입력 -> 브라우저는 URL을 분석
   - URL에 포함된 도메인을 IP 주소로 변환하기 위해 DNS 서버에서 도메인의 IP 주소 조회
   - 로컬 캐시 조회 -> DNS Resolver에 요청 -> 루트 네임서버 조회 -> TLD 네임 서버 조회 -> 권한 있는 데임 서버 조회
2. TCP 연결 설정
    - IP 주소 확인 후 TCP 연결 설정
    - TCP 3-way handshake 과정을 통해 클라이언트-서버 연결 설정 ( 클라이언트가 서버에 연결 요청 -> 서버가 요청 수락 후 응답 보냄 -> 클라이언트가 서버의 응답 확인 후 연결 설정 )
3. HTTPS 요청 전송
    - tcp 연결이 완료되면 브라우저는 HTTP/HTTPS 프로토콜을 통해 서버에 요청 전송
4. 서버는 클라이언트 요청을 분석하고 필요한 데이터 반환
5. 클라이언트는 브라우저가 응답을 수신 후 받은 데이터들을 파싱하여 렌더링 

