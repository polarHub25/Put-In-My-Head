# 가상화(Virtualization)
## 가상화란 무엇이며, 왜 운영 체제에서 중요한가요?
> 가상화
- 물리적인 자원을 논리적으로 분리하거나 통합하여, 가상의 환경에서 효율적으로 사용할 수 있게 하는 기술.
  
> 운영체제에서 중요한 이유 
- 물리적 서버 하나에 여러 운영 체제를 실행할 수 있어서 하드웨어 자원의 사용률을 최적화 할 수 있음
- 가상화를 통해 물리적 하드웨어를 추가하지 않고도 새로운 애플리케이션을 배포하거나 테스트 등 서비스 확장에 유리
- 다양한 애플리케이션 실행 시, 가상화를 통해 각 애플리케이션을 독립된 상황에서 실행할 수 있어서 애플리케이션 간의 격리성 강화

> 가상화와 컨테이너 기술의 차이점은?
- 가상화는 물리적 하드웨어를 추상화하여 여러 개의 독립적인 가상 머신을 생성하는 기술. 각 가상머신은 별도의 운영체제를 실행 가능. 컨테이너처럼 커널을 공유하지않고, 하이퍼바이저 위에 구축된 완전한 가상의 컴퓨터.
- 컨테이너는 가상화와 비슷하게 격리된 환경을 제공하지만, 운영 체제의 커널을 공유. 

## 운영 체제가 CPU, 메모리, 디스크를 가상화한 것은 무엇인가요?
> CPU 가상화
- 물리적인 CPU 자원을 추상화하여, 여러 가상 머신이 물리적 CPU를 공유할 수 있게 만드는 기술
- 하이퍼바이저에 의해 관리되며, 가상 머신이 독립된 CPU를 사용하는 것처럼 동작하도록 함
  + 하이퍼바이저 : 가상 머신 간의 CPU 자원 사용을 관리하고 스케줄링하며 물리적 CPU에 대한 접근을 중재

> 메모리 가상화 ( 가상메모리 )
- 프로세스가 실제 물리적 메모리(RAM)보다 큰 메모리 공간을 사용하는 것처럼 보이게 하는 메모리 관리 기법
- 주요 키워드
  + 가상 주소 : 각 프로세스가 사용하는 메모리 주소 공간
  + 물리적 주소 : 실제 물리적 메모리에서의 데이터 저장 위치, 운영체제가 가상 주소를 물리적 주소로 변환하여 메모리에 접근
  + 페이징 : 가상 주소 공간과 물리적 메모리 공간을 고정된 크기의 블록으로 나누어 관리하는 방법
  + 페이지 : 가상 메모리의 블록 단위
  + 페이지 프레임 : 물리적 메모리의 블록 단위. 페이지와 동일한 크기로 나누어지며 운영체제는 각 페이지를 페이지 프레임에 매핑
  + 페이지 테이블 : 페이지와 페이지 프레임의 매핑 정보를 저장하는 데이터 구조. 프로세스마다 페이지 테이블은 따로 존재
  + 주소 변환 : OS는 MMU(Memory Management Unit)라는 하드웨어 장치를 통해 가상 주소를 물리적 주소로 변환
  + 프로세스가 특정 가상 주소에 접근하면 MMU는 페이지 테이블을 참조하여 해당 가상 주소에 매핑된 물리적 주소를 찾고, 접근함
  + 페이지 폴트(Page Fault) : 프로세스가 물리적 메모리에 존재하지 않는 페이지를 접근하려고 할때 발생하는 것
  + 운영체제는 페이지 폴트가 발생하면 해당 페이지를 디스크의 스왑(swap) 영역에서 물리적 메모리에 로드
  + 스왑(Swap) 영역 : OS는 물리적 메모리가 부족할때, 사용하지 않는 페이지를 디스크의 스왑영역에 임시로 저장하고 필요할때 다시 물리적 메모리로 호출
- 각 프로세스에게 독립된 메모리 공간을 제공하고 메모리 보호와 자원 관리를 최적화
- 페이지 폴트가 자주 발생하면 디스크I/O가 증가하게 되어 성능 저하 발생 (스래싱, Thrashing). 복잡한 메모리 관리

> 디스크 가상화 ( File system )
- 블록 단위로 물리적 디스크를 나누고, 블록들을 논리적으로 구성하여 파일과 디렉토리를 저장할 수 있는 구조 제공 

## 운영체제에서 커널이란 무엇이며 시스템 콜에 대해서 설명해주세요
> 커널이란? 
- 운영체제의 핵심으로 컴퓨터 자원(CPU, 메모리, 파일, 네트워크 입출력 장치 등)들을 관리하는 역할을 수행 

> 시스템 콜
- 응용 프로그램이 커널의 기능을 요청할 때 사용하는 인터페이스 (사용자가 작성한 프로그램은 커널에 직접 접근이 불가능) 
- 프로세스 제어(프로세스 생성, 종료, 메모리 할당 등 ), 파일 조작(파일 생성, 삭제, 읽기, 쓰기 등), 장치 관리(장치 요청 및 해제, 읽기, 쓰기 등), 정보 유지(시간 확인, 프로세스, 파일, 디바이스 속성 가져오기 등), 통신, 보안 

> 응용 프로그램 동작 예시
- 사용자가 "test.txt" 파일 클릭 -> 메모장 프로그램은 커널의 도움을 받기 위해 시스템 콜(open()) 호출 -> 커널은 받은 요청을 보고 파일 시스템을 통해 "test.txt" 파일이 실제 디스크에 있는지 확인하고, 해당 파일에 접근할 수 있는 파일 디스크립터 반환 -> 이후 메모장 프로그램은 파일의 내용을 읽기위해 시스템 콜(read()) 호출 -> 커널은 디스크에서 파일 내용 읽어서 메모장 프로그램에 반환 
- 즉, 커널은 하드웨어 자원 관리, 사용자와 응용 프로그램이 요청한느 다양한 작업 처리
- 시스템 콜은 응용 프로그램이 커널에 자원을 요청할때 사용하는 인터페이스 

https://goodmilktea.tistory.com/23

## 인터럽트란 무엇이며 인터럽트와 시스템 콜의 차이점에 대해서 설명해주세요.
> 인터럽트(Interrupt)
- CPU가 현재 수행 중인 작업을 일시 중단하고, 외부 하드웨어나 소프트웨어 예외에 대응할 수 있게 하는 메커니즘 

> 인터럽트와 시스템 콜의 차이점
- 인터럽트는 주로 비동기적 이벤트로 CPU가 즉각적으로 현재 작업을 중단하고 처리할 때 사용됨. 키보드 입력, 네트워크 수신 등 예기치 않은 상황에 대응할 수 있도록 시스템의 반응성 향상
- 시스템 콜은 사용자 프로그램이 커널의 기능을 사용하기 위해 명시적으로 요청하는 주로 동기적 이벤트. 프로그램이 파일을 열거나 메모리를 할당할 때 시스템 콜을 호출하여 커널에게 작업을 요청. 

## 멀티프로세싱 시스템에서 스케줄링이 중요한 이유는 무엇인가?
> 멀티 프로세싱이란?
- 다수의 CPU를 사용하여 동시에 여러 작업을 병렬로 처리할 수 있는 시스템
- 성능 향상, 확장성 <-> 복잡한 동기화, 비용 증가

> 스케줄링이 중요한 이유
- 스케줄링 : 여러 개의 CPU가 작업을 효율적으로 수행할 수 있도록 프로세스나 스레드에 CPU 시간을 할당하는 작업
- 여러 CPU에 작업을 효율적으로 분배하여 시스템 성능을 극대화 하기 위함. 스케줄링을 통해 CPU 자원을 최대한 활용하고, 응답 시간과 처리 시간을 최적화하며 자원을 공정하게 배분해야함. 이를 통해 시스템의 처리량을 높이고 프로세스간의 동시성을 관리. 

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-multi-programming-tasking-processing

## 컨텍스트 스위칭이란 무엇이며, 컨텍스트 스위칭에 따라 오버헤드가 발생하는 이유가 무엇인가요?
- CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다른 프로세스의 상태 및 정보를 읽어 실행을 전환하는 과정 

> context switching 과정
1. 현재 프로세스 상태 저장
   - 레지스터 저장 : CPU는 현재 실행중인 프로세스의 레지스터값(프로그램 카운터, 스택 포인터 등)을 해당 프로세스의 PCB에 저장
2. 스케줄러에 의해 새로운 프로세스 선택
   - 스케줄러가 실행되어 다음에 CPU에 사용할 프로세스를 선택. 스케줄러는 우선순위, 대기 시간 등을 기준으로 다음 프로세스 결정
3. 새로운 프로세스의 상태 복원
  - 레지스터 복원 : 스케줄러에 의해 선택된 프로세스의 PCB에 저장되어 있던 레지스터 정보들을 CPU 레지스터에 다시 로드
  - 프로그램 카운터 복원 : 이전에 해당 프로세스가 중단되었던 위치에서부터 명령어 실행을 재개
  - 메모리 매핑 : 프로세스가 사용하는 가상 메모리 주소를 실제 메모리에 매핑하는 페이지 테이블 등의 정보 복원
4. 복원된 상태 정보를 바탕으로 새로운 프로세스 실행 

> context switching에서 오버헤드가 발생하는 이유는?
- 위에 처럼 context switching 과정 중에 CPU가 프로세스간에 전환 수행시에 필요한 추가 작업들로 인해 오버헤드가 발생할 수 있음
1. 현재 프로세스 저장시에도 레지스터 값을 PCB로 저장하는 과정에서 CPU는 실제 작업을 수행하지않고, 저장하는 작업을 하고있으므로 오버헤드 발생
2. 스케줄러 알고리즘이 실행되어 선택하는 과정에도 오버헤드 발생 가능 
3. 캐시미스와 같은 메모리와 관련된 작업 전환시에 오버헤드 발생 가능
   - 캐시미스 : 프로세스 전환 시 이전 프로세스의 데이터가 캐시에 저장되어 있다가 새로운 프로세스가 로드되면 캐시의 기존 데이터는 무효화 되며 이때 캐시 미스가 발생. 이 경우 CPU는 메모리에서 새로운 데이터를 다시 로드해야하므로 추가적인 리소스 소비

## CPU 스케줄링 알고리즘의 종류와 특징은?(라운드 로빈, 우선순위 스케줄링, 멀티 레벨 큐)
> 라운드 로빈 (Round Robin)
- 선점형 스케줄링의 하나로, 프로세스들 사이에 우선순위를 두지않고, 순서대로 시간단위로 CPU를 할당하는 방식의 스케줄링 알고리즘
- 모든 프로세스는 동일한 시간 단위를 할당받으며, 할당 시간이 종료되면 대기열의 맨 뒤로 이동하고 다음 프로세스 실행
- 구현이 간단하지만, 타임 슬라이스 설정이 적절하지 못한 경우 성능이 저하될수 있고, 컨택스트 스위칭 비용이 증가할 수 있음(짧은 타임 슬라이스의 경우 프로세스간의 전환이 자주 발생시) 

> 우선순위 스케줄링 (Priority Scheduling)
- 각 프로세스의 우선순위 값을 할당하고, 우선순위가 높은 프로세스부터 CPU 할당하는 방식
- 우선순위 스케줄링 종류
  + 선점형 우선순위 스케줄링 : 현재 실행 중인 프로세스보다 우선순위가 높은 프로세스가 도착 시 CPU를 강제로 빼앗아 새로운 프로세스에 할당
  + 비선점형 우선순위 스케줄링 : 현재 실행 중인 프로세스가 CPU를 반환할 때까지 대기한 후, 우선순위가 높은 프로세스가 실행
- 응답시간이 중요한 시스템에 유리
- 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스 때문에 오랫동안 CPU를 할당받지 못하는 Starvation 상태가 발생할 수 있음

> 멀티 레벨 큐 스케줄링 (Multi-level Queue Scheduling)
- 프로세스들을 여러 개의 큐로 분류하여, 각각의 큐에 다른 스케줄링 알고리즘을 적용하는 방식
- 대화형 프로세스는 높은 우선순위 큐, 배치 작업은 낮은 우선순위 큐에 넣는 식으로 관리 가능
- 각 큐는 독립적으로 다른 스케줄링 알고리즘을 사용할 수 있어 시스템 요구에 맞게 스케줄링 방식 조정이 가능
- 설정이 복잡하고, 각 큐의 우선순위와 작업 분배를 잘못하면 Starvation 상태가 발생

https://jwprogramming.tistory.com/17

# 프로세스와 쓰레드
## 프로세스와 스레드의 차이점은 무엇인가?
> 프로세스
- 실행 중인 프로그램의 인스터스로, 운영체제로부터 독립적인 메모리 공간을 할당받아 실행(컴퓨터에서 작업중인 프로그램)
- 프로세스 구조 : 코드, 데이터, heap, stack으로 구성된 자체 메모리 공간이며, 다른 프로세스와 메모리를 공유하지않음
- 프로세스는 PCB라는 데이터 구조를 통해 관리 
> 스레드
- 프로세스 내에서 실행되는 작업의 흐름으로, 프로세스의 자원을 공유하며 실행되는 작은 실행 단위
- 하나의 프로세스는 여러개의 스레드를 가질 수 있고, 해당 스레드들은 코드, 데이터, heap은 공유하지만 stack은 개별적으로 관리

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4

## PCB(Process Control Block)란 무엇이며, 어떤 정보를 포함하나요?
- PCB 란 , 운영체제에서 프로세스를 관리하기 위해 해당 프로세스의 상태 정보를 담고있는 자료구조 ( 프로세스 스케줄링을 위한 프로세스 정보에 대한 임시 저장소 ) 
> PCB에 저장되는 정보
- 포인터 (Pointer): 프로세스의 현재 위치를 저장하는 포인터 정보
- 프로세스 상태 (Process state) : 프로세스의 각 상태를 저장 (생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated))
- 프로세스 식별자 (Process ID, PID) : 프로세스 고유하게 식별할 수 있는 고유 번호
- 프로그램 카운터 (Program Counter) : 현재 실행 중인 명령어의 위치를 가리키는 주소
- 레지스터 (Register) : CPU 레지스터에 있는 정보
- 메모리 관리 정보 (Memory Limits) : 해당 프로세스의 주소 공간 
- 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록 등
- CPU 스케줄링 정보 : 우선순위, 최종 실행시간, CPU 점유시간 등

## 프로세스 주소 공간이란 무엇이며, 프로세스마다 고유한 주소 공간을 가지는 이유는?
> 프로세스 주소공간
- 프로세스가 실행되는 동안 접근할 수 있는 메모리 영역
- OS는 프로세스마다 독립적인 주소 공간을 할당

> 주소 공간 구조
- Code
  + 프로그램의 실행 코드(명령어)가 저장되는 영역
  + 실행파일(.exe) 등의 명령어가 로드되며, 읽기 전용으로 설정되고 해당 영역은 수정 불가능 
- Data
  + 초기화된 전역 변수, 정적 변수가 저장되는 영역
  + 프로그램이 실행되기 전 컴파일 시점에 초기화된 데이터들이 해당 영역에 위치 
- Heap
  + 동적으로 할당된 메모리가 저장되는 영역
  + 런타임 동안 크기가 변경될 수 있고, 메모리 할당 및 해제 작업에 따라 동적으로 변경될 수 있음
  + 프로세스가 직접 관리해야하며, 메모리 누수가 발생할 수 있음 
- Stack
  + 함수 호출 시 생성되는 지역변수, 함수 호출 정보(리턴주소, 매개변수 등)가 저정되는 영역
  + 함수가 호출될때마다 쌓이며, 종료되면 할당 공간 해제
 
> 고유한 주소 공간을 가지는 이유
- 프로세스간 메모리 보호 및 보안 : 각 프로세스는 독립된 주소 공간을 가지므로 다른 프로세스 메모리에 접근할 수 없음 -> 프로세스간 메모리 보호 가능하며, 하나의 프로세스에서 발생한 오류가 다른 프로세스에 영향을 미치는 것을 방지
- 프로그램 안정성 및 충돌 방지 : 각 프로세스는 자신의 메모리 영역만을 사용하므로 메모리 충돌이 발생하지 않음
- 여러 프로세스를 동시에 실행할 수 있음

## 10/27 
## 프로세스 상태 전이(Process State Transition)를 설명해보세요.
> 프로세스 상태
- create/new : 프로세스가 생성되는 단계 
- ready : 프로세스가 생성되어 메인메모리에 적재가 되고, 필요한 자원을 모두 얻은 상태
- running : 프로세스가 cpu를 점유하여 실행중인 상태
- terminated : 프로세스가 종료되는 상태
- asleep : 메인메모리에 적재는 되었지만 필요한 자원을 얻지 못한 상태
- suspended ready : 프로세스가 실행 준비는 완료되었지만, 메모리 부족으로 인해 보조기억장치로 이동된 상태. 메모리로 다시 로드되면 Ready 상태.
- suspended blocked : 프로세스가 특정 I/O 작업이나 이벤트를 기다리는 동안 메모리 부족으로 인해 보조기억장치로 이동된 상태. 해당 작업이 완료되면 Suspended Ready 상태로 전환

> 상태 전이 
- Dispatch : 프로세스 스케줄러에 의해 결정된 우선순위에 따라 프로세스가 CPU를 점유한 상태
- TIme out : 프로세스가 제한된 시간을 다 소비하여 CPU 점유를 빼앗기는 상태
- Block : 실행중이던 프로세스가 외부 요인에 의해서 자원을 빼앗기는 상태
- Wake up : 프로세스가 자원을 할당받은 상태
- Swap in : 프로세스가 메인메모리에 적재 되는 상태
- Swap out : 프로세스가 메인메모리에서 해제 되는 상태 

## 프로세스 간 통신(IPC: Interprocess Communication) 방법에는 무엇이 있나요? (파이프, 메시지 큐, 공유 메모리 등)
> 파이프 (Pipe)
- 프로세스 간 데이터 스트림을 통해 단방향으로 통신할 수 있는 방법
- 부모-자식 프로세스 간 단방향(반이중) 통신에 자주 사용
- Unix/Linux 에서 pipe() 명령어 호출하여 생성
- 데이터를 쓰는 프로세스는 파이프가 찰 때까지 데이터를 보내고, 읽는 프로세스는 버퍼에서 데이터를 읽고, 읽는 쪽은 파이프에 데이터가 없으면 대기 상태로 들어감 
- 파이프의 버퍼는 일반적으로 작아서 프로세스 간에 빠르게 데이터를 교환할때 사용하는 것이 적합
- 예시) 쉘 명령어 ls | grep ".log"
- https://hwan-shell.tistory.com/324
  
> 메시지 큐 (Message Queues)
- 프로세스 간에 메시지를 교환할 수 있도록 커널에서 제공하는 데이터 구조
- 프로세스가 특정 큐에 메시지를 저장하고 다른 프로세스가 그 메시지를 꺼내어 사용하는 방식
- msgget() 메시지 큐 생성 -> msgsnd 메시지 추가 -> msgrcv 큐에서 메시지 읽기
- FIFO 방식
- 비동기 통신이 가능 -> 메시지를 보낸 프로세스는 메시지가 수신완료되길 기다리지 않고 다른 작업 수행 가능
- 메시지 관리 및 처리 로직이 복잡할 수 있음
- 예시) 백엔드에서 작업을 메시지 큐에 넣고, 여러 프로세스가 이를 꺼내 병렬로 작업을 처리
  
> 공유 메모리 (Shared Memory)
- 여러 프로세스가 동일한 메모리 영역을 직접 공유하여 데이터를 주고받는 방식
- shmget 공유 메모리 영역 생성 -> shmat 공유 메모리 공간을 프로세스의 메모리 공간에 연결 후 사용 -> 연결 후 프로세스는 공유 메모리의 시작 주소를 포인터로 받아서 사용
- 여러 프로세스가 동일한 메모리 공간에 접근하므로, 동기화를 이용해 데이터의 일관성 유지해야함
- 메모리 접근 속도가 빠르며, 대량의 데이터를 효율적으로 전송 가능
- 동기화를 별도로 구현해야 하므로 동기화 문제 발생 시 복잡성 증가. 메모리 누수 발생 가능성 존재
- 예시) 실시간 데이터 처리, 대용량 데이터 처리

## 멀티스레드(Multithreading)의 장점과 단점은 무엇인가요?
- 멀티 스레드는 하나의 프로세스 안에 여러개의 스레드가 있는 것
> 장점
- 멀티스레드는 스택을 제외한 동일한 메모리 공간을 공유하므로 멀티프로세스보다 데이터 공유가 쉽고 빠르므로 비용 절약과 메모리 사용량 절약 가능
- 프로세스의 컨텍스트 스위칭보다 빠르며 오버헤드가 감소해 응답시간이 빠름 

> 단점
- 하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 프로그램이 종료될수 있음
- 여러 스레드가 동시에 공유 자원에 접근하여 동기화 문제 발생
- 뮤텍스, 세마포어같은 동기화 처리 방식이 있지만, 잘못 설계시 데드락, 경쟁상태같은 문제 발생 

## 스레드 동기화(Thread Synchronization)가 중요한 이유는 무엇인가요?
- 여러 스레드가 자원을 안전하게 사용하도록 보장하고, 프로세스의 실행 순서를 보장하기 위해서 중요.

# 동시성
## 동시성 문제란 무엇인가?
- 여러 스레드나 프로세스가 동시에 같은 데이터를 읽고 쓰는 과정에서 데이터의 일관성이 깨지는 상황

> 경쟁 상태 (Race Condition) 
- 2개 이상의 스레드가 동시에 공유 자원에 접근하여 실행 순서에 따라 결과가 달라지는 상황
> 데드락 (Deadlock)
- 여러 프로세스가 서로 상대방이 점유한 자원을 기다리며 무한히 대기하는 상태 
> 기아 상태 (Starvation)
- 스레드 또는 프로세스가 필요한 자원을 지속적으로 할당받지 못해 실행되지 못하는 상태 ( 주로 우선순위가 낮은 작업 )
> 데이터 불일치
- 데이터의 일관성이 깨져 서로 모순되는 데이터가 존재하는 상태

## 교착 상태(Deadlock)란 무엇인가요? 교착 상태의 해결 방법을 설명해보세요.
- 여러 프로세스나 스레드가 서로 상대방이 점유한 자원을 기다리며 무한히 대기하는 상태

> 교착 상태 발생 조건 ( 4가지 모두 성립해야 데드락 발생 ) 
- 상호 배제(Mutual Exclusion)
  + 자원은 한번에 한 프로세스만 사용 가능
- 점유 대기(Hold and Wait)
  + 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야함 
- 비선점(Non-Preemption)
  + 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 점유할 수 없음 
- 순환 대기(Circular Wait)
  + 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야함
  + 프로세스 A 자원 X:점유 /자원 Y:요청
  + 프로세스 B 자원 Y:점유 /자원 X:요청

> 교착 상태 해결 방법
- 교착 상태 예방 (Deadlock Prevention)
  + 교착 상태 4가지 조건 중 하나를 제거하여 교착 상태 방지
  + 상호 배제 제거 : 자원을 여러 프로세스가 동시에 접근할 수 있도록 허용하는 방법
  + 점유 대기 제거 : 프로세스가 자원을 요청할 때 현재 점유 중인 자원을 모두 해제한 후 다시 요청하도록 하는 방법 
  + 비선점 제거 : 자원을 점유한 프로세스가 추가 자원을 요청할 때, 요청한 자원을 즉시 할당할 수 없는 경우 기존에 점유한 자원을 해제하고 다른 프로세스가 사용하는 방법
  + 순환 대기 제거 : 자원에 고유한 번호를 할당하고, 자원을 요청할 때 순서대로만 요청하게 하는 방법
- 교착 상태 회피 (Deadlock Avoidance)
  + 교착 상태가 발생할 수 있는 상황을 실시간 분석하여 안전한 상태에서만 자원을 할당
  + 은행원 알고리즘
  + 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
  + 안정 상태면 자원할당 , 아닌 경우 다른 프로세스들이 자원해지까지 대기
- 교착 상태 탐지 (Deadlock Detection) 및 회복 (Recovery)
  + 교착 상태가 발생할 수 있도록 허용한 후, 교착 상태를 주기적으로 검사하고, 발생 시 회복하는 방법
  + 탐지 : 자원의 상태와 프로세스의 대기 그래프를 주기적으로 검사하여, 순환 대기가 있는지 확인. 그래프에서 사이클이 발견되면 교착 상태가 발생
  + 회복
    + 프로세스 종료 : 교착 상태에 있는 프로세스들 중 일부를 종료하여 자원을 해제
    + 자원 선점: 교착 상태에 있는 프로세스 중 일부의 자원을 강제로 회수하여 다른 프로세스가 사용할 수 있도록 함
- 교착 상태 무시 (Ignore Deadlock)
  + 데드락의 발생 확률이 비교적 낮은 경우 별다른 조치 없이 무시하는 방법


## 임계 구역(Critical Section)이란 무엇이며, 이를 해결하는 방법은 무엇인가요?
> 임계 구역(Critical Section)
- 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역역

> 임계 구역에서 발생할 수 있는 문제
- 경쟁 상태, 데드락, 기아상태 등

> 해결 방법
- 뮤텍스(Mutex), 세마포어(Semaphore), 모니터(Monitor)

> 뮤텍스(Mutex)
- 임계 구역에 한번에 하나의 스레드만 접근할 수 있도록 하는 Lock
- 하나의 스레드가 임계 구역에 진입할 때 락을 획득하고, 작업이 끝나면 락을 해제함으로써 다른 스레드가 접근할 수 있게 하는 방식
- 간단한 구현, 데이터 일관성 보장 (경쟁 상태 방지)
- 락 해제, 획득 순서로 인해 데드락 발생 가능성 있음 
> 세마포어(Semaphore)
- 카운터 값을 사용해 여러 스레드가 동시에 접근할 수 있는 자원의 수를 제한하는 동기화 도구
- 다수의 스레드가 자원에 동시에 접근할수 있음
- 데드락 가능성 존재
- 세마포어의 값을 수동으로 관리해야 하므로 복잡한 시스템에서는 오류 발생할 수 있음 
> 모니터(Monitor)
- 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화 적용
- 객체 내부에 임계 구역에 대한 락과 조건변수를 포함하여 스레드들이 객체의 특정 메서드나 코드 블록에 한번에 하나씩만 접근할 수 있도록 관리하는 방식
- 자바에 synchronized
- 프로그래머가 직접 락을 관리하지 않고, 프로그래밍 언어에서의 모니터를 통해 동기화 구현 가능
- 복잡한 동작 제어

## 상호 배제(Mutual Exclusion)란 무엇인가요?
- 여러 프로세스나 스레드가 동시에 공유 자원에 접근하지 못하도록 하는 원칙
- 데이터의 일관성과 프로그램의 안정성을 보장하며 경쟁 상태 방지
- 뮤텍스, 세마포어, 모니터와 같은 기법이 상호 배제를 구현하기 위한 방식

- https://yoongrammer.tistory.com/61

## 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점은 무엇인가요?
- 사용목적과 동작 방식에 차이가 존재
- 뮤텍스는 단일 스레드의 접근만 허용. 세마포어는 카운터 값에 따라 여러 스레드의 동시 접근을 제어
- 뮤텍스는 락을 획득한 스레드만이 해제할 수 있지만, 세마포어는 자원을 점유하지 않은 스레드도 카운터를 증가 시킬수 있음
- 뮤텍스는 단일 자원의 접근 보호에 적합하며, 세마포어는 여러 자원의 접근 수를 제한하고 관리하는 용도로 적합 

## 스핀락(Spinlock)과 같은 동기화 기법은 언제 사용되나요?
- 스핀락 : 락을 획득할 때까지 계속해서 락의 상태를 확인하는 방식
- CPU를 사용해 반복적으로 락을 확인

> 사용 예시
- 멀티코어 시스템에서 락 대기 시간이 짧은 경우
  + 락이 해제될때까지의 시간이 짧은 경우에는 스핀락이 락을 기다리며 반복 확인하는 것이 스레드의 상태를 전환하는 것보다 더 빠르고 효율적일수 있음
- 오버헤드를 줄이고 싶은 경우
  + 일반적인 락의 경우 스레드가 락을 얻지 못하면 블로킹 상태로 전환 -> 락이 해제되면 다시 깨어나서 작업 재개 식의 과정에서 컨텍스트 스위칭이 발생하는데 이는 오버헤드를 발생. 이 경우 락이 짧은 시간내에 해제가 될 거같은 경우에는 스핀락으로 오버헤드를 줄일 수 있음
    
## Readers-Writers, 생산자-소비자 문제와 식사하는 철학자 문제에 대해서 설명해주세요.
- 동시성 제어 관련해서 데이터 일관성, 효율성, 자원 사용의 공정성 관리에 중점 

> Readers-Writers
- Reader : 공유 버퍼의 내용을 읽기만 하는 프로세스
- Writer : 공유 버퍼에 내용을 갱신하는 프로세스 
- 하나의 writer가 공유 자원에 접근하고 있을때 다른 reader, writer 프로세스가 동시에 접근할 경우 혼란이 발생 
- Readers Priority
  + 여러 reader는 동시에 자원에 접근할 수 있지만, writer는 reader의 자원 사용이 완료될때까지 대기
  + reader가 많은 경우 시스템 개선
  + writer가 오래 대기할 경우 writer starvation 문제가 발생할 수 있음
- Writers Priority
  + writer가 자원에 접근할 우선권을 가지고, writer가 대기중인 경우 모든 reader는 대기
  + writer의 대기 시간이 짧아지고, 빠르게 자원에 접근 가능
  + reader가 오랜 시간 대기하게 되는 reader starvation 문제 발생할 수 있음 
- 사용 예시 : db 에서의 드랜잭션 , 파일 시스템 , 캐시 시스템 

> 생산자-소비자 문제
- 생산자 : 데이터 공급 ( Inqueue )
- 소비자 : 데이터 처리 ( Dequeue )
- 하나의 공유 버퍼를 두고 데이터를 생산하는 생산자와 데이터를 소비하는 소비자 사이에서 발생하는 동기화 문제 
- 세마포어를 활용한 해결방법
  + full 세마포어와 empty 세마포어를 사용하여 버퍼의 상태를 확인하고, 이진 세마포어를 통해 생산자와 소비자가 동시에 버퍼를 수정하지않도록 함
  + full 세마포어 : 현재 버퍼에 있는 데이터의 수. 소비자가 버퍼에서 데이터를 꺼낼때 감소
  + empty 세마포어 : 버퍼에 남아있는 빈 공간의 수. 생산자가 데이터를 추가할 때 감소
  + 이진세마포어 : 생산자,소비자가 동시에 버퍼를 수정하지 못하도록 상호 배제 제공
  + 구현이 비교적 간단하며, 각 세마포어의 역할이 명확하므로 관리가 용이
  + 세마포어 수를 잘못 제어할 경우 데드락이나 경쟁 상태가 발생할 수 있음 
- 모니터를 활용한 해결방법
  + 상호 배제와 조건 변수를 활용하여 버퍼 상태에 따라 생산자, 소비자 접근을 조율.
  + 생산자, 소비자가 각각 대기 조건을 만족할 때까지 락을 걸고, 조건이 충족되면 신호를 통해 대기중인 프로세스 깨움
  + 세마포어보다 높은 수준의 추상화로 동기화 제어 가능
  + 일부 언어에서는 기능이 없거나 별도의 라이브러리가 필요 
- 예시 : 비동기 메시지 시스템 -> rabbitmq 같은 메시지 큐 시스템에서 프로듀서가 메시지를 큐에 추가하면, 컨슈머가 이를 소비하여 다른 서비스에 전달하거나 처리
  
> 식사하는 철학자 문제
- 다수의 프로세스가 공유 자원을 사용할 때 발생하는 동기화 문제의 대표적 사례.
- 교착 상태와 기아 상태 방지를 위해 고안된 문제 
- 웨이터 방식
  + 웨이터 역할의 중앙 관리자가 철학자가 자원을 요청할때 2개의 젓가락이 모두 사용 가능할 때만 접근을 허용하는 방식
  + 교착 상태를 방지할수 있고, 모든 철학자가 공평하게 자원을 사용할 수 있음
  + 중앙 관리자 프로세스가 추가되어 오버헤드가 발생할 수 있음 
- 자원 계층 방식
  + 자원의 순서를 지정하여 모든 철학자가 동일한 순서로 자원을 잡지 않도록 하여, 모든 철학자가 동시에 대기하는 순환 대기조건을 방지하는 방식
  + 구현이 비교적 간단하지만, 자원 사용 효율이 다소 떨어질 수 있음


## 조건 변수(condition variable)란 무엇인가요?
- 특정 조건을 만족하기를 기다리는 변수
- 멀티스레드에서 스레드 간의 통신 및 동기화를 위해 설계된 변수
- 조건 변수의 메서드
  + wait() : 현재 스레드는 뮤텍스를 해제하고 조건 변수가 신호를 받을 때까지 대기
  + notify(), signal() : 대기 중인 스레드 중 하나를 깨움
  + notifyAll() : 대기 중인 모든 스레드를 깨움
- 예시 ) 생산자-소비자 문제에서 생산자는 버퍼에 빈 공간이 있을때만 데이터를 추가하고 소비자는 버퍼에 데이터가 있을때만 데이터를 가져갈 수 있는데 이 조건을 충족시키기 위해 사용하는 변수가 조건변수 

# 메모리 관리 (Memory Management)

## 메모리 계층 구조에 대해서 설명해주세요.
- 프로세스 실행 시 필요한 데이터와 명령어를 CPU가 효율적으로 접근 할 수 있도록 메모리 계층을 나눠서 설계

> 레지스터
- CPU 내부에 위치한 고속 메모리
- CPU가 요청을 처리하는데 필요한 데이터를 저장하고 접근할 수 있는 임시 저장소
- 구성 요소
  + 프로그램 카운터 (PC) : 다음에 실행할 명령어의 주소 저장
  + 명령어 레지스터 (IR) : 현재 실행 중인 명령어 저장
  + 누산기 (Accumulator) : 연산 중간 결과를 저장
  + 상태 레지스터 (Flags) : 명령에 대한 상태 기록
- 동작 원리
  + 레지스터 간의 데이터 이동은 메모리간 이동 없이 CPU 내부에서 실행되므로 속도가 매우 빠름 

> 캐시메모리
- CPU와 RAM 사이에서 빈번하게 사용되는 데이터를 저장하는 메모리
- 자주 필요한 데이터를 저장해 CPU의 대기 시간을 줄이고, 빠르게 접근할 수 있도록 함
- 구성 요소 
  + L1 캐시 : 각 CPU 코어에 개별적으로 할당되며, 매우 빠르지만 용량 작음
  + L2 캐시 : CPU 코어에 연결되지만, L1보다 용량이 크고 속도는 더 느림
  + L3 캐시 : 여러 CPU 코어가 공유하며, 캐시중 용량이 가장 크지만 속도가 느림
- 동작 원리
  + Cache Hit, Cache Miss에 따라 작동
  + CPU가 데이터를 요청할 때 캐시를 먼저 찾고 데이터가 있으면 사용. 없으면 RAM에서 불러온 후 캐시에 저장한 뒤 사용

> 주기억장치 (Main Memory)
- 현재 CPU가 처리하고 있는 내용을 저장하는 기억장치
- 구성 요소
  + ROM( Read Only Memory ) : 비휘발성 메모리. 데이터를 저장한 후 반영구적으로 사용 가능.
  + RAM ( Random Access Memory ) : 휘발성 메모리. 응용 프로그램, 운영체제 등을 불러와서 CPU가 작업할 수 있도록 하는 기억장치 

> 보조기억장치 (Secondary Storage, HDD/SSD)
- 물리적인 디스크가 연결되어 있는 기억장치
- 주기억장치보다는 느리지만 전원을 종료해도 데이터를 영구적으로 보관하는 장치
- 구성요소
  + HDD ( Hard Disk Driver ) : 물리적인 디스크를 고속으로 회전시켜 데이터를 저장하는 장치
  + SSD (Solid State Driver ) : 물리적인 아닌 전기적으로 데이터를 저장하므로 HDD보다 빠름
  
> 가상 메모리 (Virtual Memory)
- 주기억장치의 용량을 초과하는 데이터를 저장할때, 사용하는 논리적 메모리 공간
- 구성요소
  + 페이지테이블, 페이지, 프레임으로 구성
  + 페이지 테이블을 통해 가상 주소와 물리 주소간의 매핑 관리
- 동작 원리
  + 페이징을 통해 필요할 때마다 하드디스크에서 데이터를 불러 RAM에 올림.
  + 필요한 데이터가 RAM에 없는 경우 하드 디스크의 영역에서 데이터를 읽어와 작업 진행
    


## 메모리에서 스택, 힙, 코드, 데이터 영역에 대해서 설명해주세요.

## 가상 메모리(Virtual Memory)란 무엇인가요?

## 페이지 테이블(Page Table)이란 무엇이며, 그 역할을 설명해보세요.

## 페이지 교체 알고리즘(FIFO, LRU, Optimal 등)의 차이점을 설명하세요.

## 페이지 폴트(Page Fault)란 무엇이며, 어떻게 처리되나요?

## TLB(Translation Lookaside Buffer)의 역할은 무엇인가요?

## 스와핑(Swapping)이란 무엇이며, 언제 발생하나요?

## 세그멘테이션(Segmentation)과 페이징(Paging)의 차이점은 무엇인가요?







