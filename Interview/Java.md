
### Java

## 1. JVM의 구조와 Java의 실행방식을 설명해주세요. 

> java의 실행방식 <br>
- java 코드는 javac 컴파일러에 의해 java 바이트 코드(.class)로 변환
- java 바이트 코드는 jvm에 의해 메모리로 로드되고, 검증된 후 실행
- jvm의 Execution Engine은 인터프리터와 JIT 컴파일러를 사용해 바이트코드를 해석하거나 기계어로 
변환해 실행
- jvm은 메모리를 자동으로 관리하며, 필요시 JNI를 통해 네이티브 메서드(c, c++ 등)도 호출
- 프로그램 실행이 완료되면 jvm은 gc과 리소스 해제를 통해 메모리를 정리하고 종료

> jvm 역할 <br>

자바 애플리케이션을 클래스 로더를 통해 읽어 자바 api와 함께 실행하는 것

- Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올림
- Runtine Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석 
- 이 과정에서 Execution Engine에 의해 gc의 작동과 스레드 동기화가 이루어짐.

> jvm 구조 <br>

클래스 로더 <br>
 - jvm 내로 .class 파일을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치 
 
실행엔진 ( Execution Engine ) 
 - 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행 <br>
   ( 인터프리터와 JIT 컴파일러 방식을 혼합하여 바이트 코드 실행) 
 * 인터프리터 <br>
   : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 ( 전체적인 속도는 느림 ) 
 * JIT 컴파일러 (Just in time) <br>
   : 인터프리터의 단점을 보완하기 위해 도입. 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 native code로 변경하고, 
   그 이후에는 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드(c, c++) 로 직접 실행하는 방식
 * 가비지 콜렉터 (Garbage Collector) <br>
 : heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수. 개발자가 따로 메모리 관리를 하지않아도 됨.


런타임 데이터 영역 (Runtime Data Areas)
 - jvm의 메모리 영역. 자바 애플리케이션이 실행할 때 사용되는 데이터들을 적재하는 영역

 * 메소드 영역 (Method Area) <br>
 : jvm이 시작될때 생성되는 공간. 바이트 코드를 처음 메모리 공간에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간 <br>
 : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름, 리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성 
 * 힙 영역 (Heap Area) <br>
 : 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역. <br>
 : new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 <br>
 : GC 대상
 
 * 스택 영역 (Stack Area) <br>
 : 메소드가 호출될때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장 <br>
 : 임시적으로 사용되는 변수, 정보들이 저장되는 영역
 * PC Register ( Program Counter register ) <br>
 : 스레드가 시작될때 생성. 현재 수행중인 jvm 명령어 주소를 저장하는 공간. <br>
 * 네이티브 메소드 스택 (Native Method Stack) <br>
 : 기계어로 작성된 프로그램을 실행시키는 영역
 
자바 네이티브 인터페이스
- 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공 <br>

네이티브 메소드 라이브러리 
- c, c++ 로 작성된 라이브러리를 칭함.


java, jvm 설명
자바 소스코드는 컴파일러가 바이트 코드(.class)로 변환합니다.  <br>
이렇게 변경된 바이트 코드는 클래스 로더가 runtime data area로 로딩시킵니다.  <br>
이 영역은 5가지 영역으로 이루어져 있으며, 메소드와 힙 영역은 모든 스레드가 공유하는 영역이고, <br>
 스택, pc 레지스터, 네이티브 메소드 스택은 스레드 마다 하나씩 생성되는 공간입니다.  <br>
 
메소드 영역은 jvm이 시작될때 생성되는 공간으로,  <br>
모든 스레드가 공유하는 영역으로 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름,  <br>
리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성등이 저장이 됩니다.  <br>

힙영역은 동적으로 생성된 객체가 저장되는 영역으로, 뉴 연산을 통하여 동적으로 생성된  <br>
인스턴스 변수가 저장됩니다.  <br>
뉴 연산을 통해 생성된 데이터는 예를 들어 클래스의 객체, 배열등이 있고,  <br>
그렇게 생성된 변수는 해당 객체가 소멸되기 전이나 gc가 정리하기전까지는 남아있습니다.  <br>

스택 영역은 지역변수, 메서드의 매개변수, 임시적으로 사용되는 변수, 메서드의 정보가 저장되는  <br>
영역입니다. 지역변수와 매개변수의 특성상 해당 메서드에 호출이 종료되면 이 안에  <br>
선언된 변수들은 사라집니다. 주로 금방 사용되고 끝나는 데이터가 저장되는 영역입니다.  <br>

pc 레지스터는 현재 수행중인 jvm의 명령어 주소를 저장하는 공간입니다. <br>
 스레드가 어떤 부분을 어떤 명령어로 수행할지를 저장하는 공간  <br>
 
네이티브 메서드 스택은 자바가 아닌 다른언어로 작성된 코드를 위한 공간으로 ,  <br>
c, c++를 수행하기 위한 공간이고, 실제 실행할 수 있는 기계어를 실행시키는 영역  <br>
이제 runtinme area에 로딩된 클래스 파일이 execution engine을 통해  <br>
해석될 차례로, 바이트코드를 기계어로 바꾸는 작업이 필요한데 , 여기서 2가지 방법이 있다.  <br>

먼저 인터프리터는 명령어를 한줄한줄 해석하면서 실행을 한다. 그리고 <br>
JIT (Just in time) 컴파일러는 인터프리터의 단점을 해결하기 위해  <br>
런타임 시간에 한꺼번에 변경하여 실행합니다.  <br>
이렇게 기계어로 변경된 것들이 runtime data area에 배치되어  <br>
스레드 동기화 또는 가비지 컬렉션을 수행하게 됩니다.  <br>

마지막으로 네이티브 메소드 인터페이스와 라이브러리는  <br>
jvm에 의해 실행되는 코드중에 네이티브로 실행되는 것이 있다면,  <br>
해당 네이티브 코드를 호출하거나 호출 될수 있더록 만든 프레임 워크이고,  <br>
네이티브 메소드 라이브러리는 네이티브 메소드 실행에 필요한 라이브러리라고 합니다.  <br>


## 2. GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

> 정의 
 - 자바의 메모리 관리 방법중 하나로 jvm의 heap 영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

> 필요이유 
 - 메모리 누수 방지 : 사용하지 않는 객체를 해제하지않으면, 메모리 누수 발생 
 - 안전성 향상 : 수동으로 메모리 관리시의 오류를 방지하여 프로그램의 안정성 증진
동작방식 
 : Mark and Sweep 알고리즘 기반으로 동작
 - Marking : 루트 객체에서 그래프 순회를 통해 참조되고 있는 모든 객체 추적
 - Sweeping : 마킹 단계에서 unreachable 상태로 표시된 객체들을 heap에서 제거
 - Compacting : 메모리 단편화를 방지하기 위해 남아있는 객체들을 한쪽으로 모아서 연속적인 메모리 블록을 만듬

## 3. 컬렉션 프레임워크에 대해서 설명해주세요.
> 정의
-  객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스들의 집합.( 자료구조의 종류를 자바 클래스로 구현한 모음집 ) <br>
- Collection 인터페이스와 Map 인터페이스로 나뉨 
> 종류 
- List : 순서가 있는 요소의 집합. 중복 요소 허용 (arraylist, linkedlist, vector) 
( 배열과 리스트의 차이점은 리스트는 자료형 크기가 고정이 아닌데, 배열은 고정) 
- Set : 순서 보장 없음. 중복되지않는 요소의 집합 (hashset, linkedhashset..), 순서가 없으므로 get 메서드 없음
- Queue : 선입선출 구조. 
- Map : key-value 쌍으로 데이터 저장. 키 중복 불가. value 중복 가능 (hashmap, linkedhashmap..) 


## 4. 제네릭에 대해서 설명해주세요.
> 정의
- java에서 코드의 재사용성과 타입 안정성을 높이기 위해 도입된 기능.
> 특징
- 제네릭을 사용하면 클래스나 메서드에서 사용할 데이터 타입을 외부에서 지정할 수 있어, 다양한 타입에 대해 동일한 코드를 작성할 수 있다. 
- 제네릭을 사용하면 컴파일 시점에서 타입 검사가 이루어지기 때문에 런타임에서 발생할 수 있는 classCastException을 방지할 수 있다. 


## 5. 애노테이션에 대해서 설명해주세요.
> 정의
- java에서 메타데이터를 제공하는 일종의 마커로, 코드에 추가적인 정보 제공 및 특정 동작을 수행하도록 하는데 사용
> 특징
- 주석처럼 코드에 부가적인 정보를 제공, 컴파일러나 런타임시에도 정보 활용 가능
> 예시
- 컴파일러 지시 : @Override, @deprecated 처럼 컴파일러에게 특정 동작을 지시
- 런타임 지시 : @Autowired 처럼 스프링 프레임워크에서 빈 주입 등 런타임 시 특정 기능을 자동으로 처리하는 동작 지시
- 빌드 및 배포 도구 : @Entity, @Table 등 JPA 어노테이션으로 ORM을 정의하며, 엔티티 클래스가 디비 데이블과 어떻게 매핑되는지 지정.
- 커스텀 어노테이션을 정의도 가능. @interface 어노테이션을 지정.


## 6. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
> 오버라이딩 
- 부모 클래스의 메소드의 동작만을 재정의하는것이므로, 메소드의 선언부(매개변수 갯수, 리턴타입)는 기존 메소드와 같아야함
- 부모 클래스의 메소드보다 좁은 접근 제어자로 변경할수 있음

> 오버로딩 (overloading) 
- 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 정의해서 다양한 상황에서 사용하는 것을 의미
- 반환 타입과는 관계가 없음
- 오버로딩의 개념없이 메서드명을 다르게하여 각기 다른 메서드로 정의해서 사용해도 상관은 없으나, 객체지향의 다형성을 추구하기 위해 사용

## 7. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 추상 클래스는 단일 상속이지만, 인터페이스는 다중 구현이 가능 
- 추상 클래스는 필드와 메서드를 모두 가질 수 있지만, 인터페이스는 기본적인 메서드만 정의 가능
- 추상 클래스는 관계를 명확히 하고, 부모의 기능을 확장시키는데 목적이 있지만, 인터페이스는 클래스가 특정 기능을 구현하도록 강제하는 목적이 있습니다. 


## 8. 클래스는 무엇이고 객체는 무엇인가요?
> 클래스
- 객체를 정의하는 틀 또는 설계도. 객체의 속성과 메서드를 정의. jvm에 메서드 영역에 저장.
> 객체
- 클래스를 기반으로 만들어진 실제 인스턴스. jvm의 힙 영역에 할당
> 정리
- 클래스는 객체 지향 프로그래밍의 기본 단위로 객체를 생성하지 위한 설계도이고, 객체는 이 클래스를 기반으로 생성된 데이터와 기능을 포함한 인스턴스.



## 9. Static이란 무엇인가요?
- 클래스 레벨에서 변수, 메서드, 초기화 블록을 정의할때 사용
- static 으로 선언된 변수나 메서드는 클래스에 속하며, 이는 클래스가 메모리에 로드될때 초기화되며, 인스턴스화 없이 클래스 이름을 통해 직접 접근
> static 변수와 인스턴스 변수의 차이점은 ? 
- static 변수는 클래스에 속하며, 모든 인스턴스가 공유하는 반면, 인스턴스 변수는 각 객체에 속하며 객체마다 고유한 값을 가짐
> static 메서드에서는 인스턴스 변수를 사용할 수 없는 이유는? 
- static 메서드는 클래스 레벨에서 호출되므로, 인스턴스화되지 않은 상태에서 실행
> static 블록의 역할은? 
- 클래스가 메모리에 로드될때 한번 실행되며, 복잡한 정적 변수 초기화나 외부 리소스 로드에 사용
> static 메서드를 오버라이딩 할 수 있는가? 
- 클래스 레벨에 속하므로 오버라이딩 할 수 없음. 대신 자식 클래스에서 동일한 이름의 static 메서드를 정의하는 것을 메서드 숨김으로 처리
> static import와 일반 import의 차이? 
- static import를 사용하면 클래스 이름을 명시하지않고도 직접사용가능 
> static은 jvm에 어느 메모리 영역에 로딩되나요? 
- 메서드 영역에 로딩. 
- java 7 이전에는 메서드 영역이 permge에 구현. java 8 이후에는 메서드 영역이 metaspace 에 구현되어 네이티브 메모리 사용
-> jvm의 런타임 데이터 영역이 변경된건 아니지만, 메서드 영역이 어떻게 관리되는지에 변화가 있는것(permgen -> metaspace) 

## 10. 자바의 원시타입(Primitive type)들은 무엇이 있으며 각각 몇 바이트를 차지하나요?

정수형: byte (1바이트), short (2바이트), int (4바이트), long (8바이트)
실수형: float (4바이트), double (8바이트)
문자형: char (2바이트, 유니코드)
논리형: boolean (크기 명시 없음, 보통 1비트 또는 1바이트)
> primitive type과 wrapper class 차이점은?
- primitive type은 값 자체를 저장하며, 메모리 효율적이고 성능이 좋음
- wrapper class는 primitive type을 객체로 감싸며, null을 허용하고, 제네릭 상황에서 사용

> java에 데이터 타입이란, 변수에 적재할 데이터가 메모리에 어떻게 저장되고 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 키워드
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장

## 11. 접근 제어자의 종류와 이에 대해 설명해주세요.
- 클래스, 변수, 메서드 등에 대한 접근 권한을 설정하여 코드의 캡슐화/정보 은닉를 높이는데 사용
- private : 같은 클래스 내에서만 접근 가능 
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한 없음
> private으로 선언된 변수에 접근할 수 있는 방법은?
- private 변수에 직접 접근할 수는 없지만, 해당 변수를 읽거나 설정하기 위한 public 또는 protected getter/setter 메서드를 통해 접근 가능
> 상속받은 클래스에서 부모 클래스의 private 변수를 사용할 수 있나요?
- 아니요. 부모 클래스의 private 변수는 자식클래스에서 접근 할 수 없습니다. 부모클래스에서 제공하는 protected, public 메서드를 통해 접근해야함 
> 왜 접근 제어자를 제공하나요?
- java의 접근 제어자는 캡슐화를 통해 내부 구현을 숨기고, 데이터 보호 및 코드 재사용성을 높이며, 잘못된 접근을 방지하여 코드의 안정성과 유지보수성을 높이는 역할
> java에서 인터페이스의 메서드는 기본적으로 어떤 제어자를 가지나요? 
- public으로 선언되며, 인터페이스 메서드는 항상 public이며, 이를 구현하는 클래스도 public으로 구현해야함 
> 한 클래스 내에서 두개의 메서드가 같은 이름을 가질 떄, 접근 제어자를 다르게 할 수 있나요? 
- 네. 같은 클래스에서 메서드 오버로딩이 가능하며, 각 메서드는 다른 접근 제어자를 가질수 있다. 하지만 오버라이팅 된 메서드의 접근 제어자는 부모 메서드보다 좁게 설정할수는 없음

## 12. 객체 지향에 대해서 설명해주세요.
- 객체(Objects)들이 모여서 상호 협력하면서 데이터를 처리하는 방식의 프로그래밍 설계 방법(데이터와 그 데이터를 처리하는 메서드를 하나의 객체로 묶어, 이러한 객체들 간의 상호작용을 통해 프로그램을 설계하고 개발하는 프로그래밍 )
- 객체 지향 프로그래밍 : 객체를 중심으로 소프트웨어를 설계하고 개발하는 패러다임으로, 객체들이 서로 상호작용하여 프로그램이 동작하게됨. 코드의 재사용성, 확장성, 유지보수성을 높이는것
- 객체 지향 4가지 핵심 원칙 : 캡슐화, 상속, 다형성, 추상화
- 추상화 ( Abstraction ) : 클래스를 정의할 때 불필요한 부분들을 생략하고, 객체의 속성에서 중요한 것에 중점을 두어 개략화 하는 것
-> 데이터 추상화 : 객체의 관련 속성만 표시 ( 대상을 간단한 개념으로 일반화 ) 
-> 제어 추상화 : 불필요한 세부정보는 숨김 ( 사용자에게 해당 메서드의 작동방식과 같은 내부 로직은 숨김 )
- 상속 ( Inheritance ) : 상위 클래스의 속성과 기능을 재사용하여 하위 클래스가 전부 물려받는것
- 캡슐화 ( Encapsulation ) : 객체의 속성(Field)과 행위(Method)를 하나로 묶고, 외부로부터 내부를 감싸 숨겨 은닉. 또한 외부의 잘못된 접근으로 값이 변하는 의도치 않은 동작을 방지하는 효과
ex) protected, default , private
- 다형성 ( Polymorphism ) : 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
ex) 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 .. 

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID
## 13. SOLID 에 대해서 설명해주세요 ( 객체 지향 5대 원칙 ) 
- SRP( Single Responsibility Principle ) : 단일 책임 원칙
- OCP ( Open Closed Principle ) : 개방 폐쇄 원칙
- LSP ( Listov Substution Principle ) : 리스코프 치환 원칙
- ISP ( Interface Segregation Principle ) : 인터페이스 분리 원칙
- DIP ( Dependency Inversion Principle ) : 의존 역전 원칙

- SRP : 하나의 클래스는 하나의 책임만 가져야 함. 즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로 여러개 설계하라는 원칙
- OCP : 확장에 열려있어야 하며, 수정에는 닫혀있어야한다. 즉, 기능 추가 요청이 오면 클래스는 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성하는 설계 기법
        추상화 사용을 통한 관계 구축을 권장-> 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- LSP : 자식 클래스는 부모 클래스의 기능을 확장하되, 부모 클래스의 기능을 깨지 않도록 일관성을 유지해야 한다는 원칙
- ISP : 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙
- DIP : 어떤 class 를 참조해서 사용해야하는 상황이 생긴다면, 그 class 를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스, 인터페이스) 로 참조하라는 원칙

> SOLID 원칙이 왜 중요한가? 
- SOLID 원칙은 코드의 유지보수성, 확장성, 재사용성을 높이기 위해 중요
## 14. 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성 : 두 객체가 메모리상에서 같은 객체인지를 판단. 즉, 동일한 메모리 주소를 가리키는지 확인. "==" 연산자를 사용하여 비교
- 동등성 : 두 객체의 값이나 상태가 같은지를 판단. 즉, 객체가 다르더라도 내부 값이 동일하면 동등하다고 판단. "equals()" 메서드를 사용하여 비교
> 동등성을 비교할때 equals() 메서드를 오버라이딩 해야하는 이유는?
- 기본적으로 object 클래스의 equals() 메서드는 동일성을 비교함. 그래서 동등성 비교를 위해서는 오버라이딩을 해야함.

## 15. 원시타입과 참조타입의 차이에 대해 설명해주세요.
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장
> 원시타입과 참조타입의 차이점은 무엇인가요?
- 원시타입은 값 자체를 저장하고, 스택 메모리에 저장. 참조타입은 객체의 주소를 저장하며, 스택에는 주소값이 실제 객체는 힙 메모리에 저장

## 16. String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- 모두 문자열을 다루지만, 동작 방식, 성능, 스레드 안정성에 차이가 있음
- String 
: String 클래스는 불변 객체. 한변 생성된 문자열은 변경할 수 없고, 문자열을 수정하는 작업에는 항상 새로운 객체를 생성 
: 문자열을 변경할 때마다 새로운 객체를 생성하므로, 메모리 낭비 발생, 성능 저하, String 객체는 불변이므로 스레드 안전
- Stringbuilder 
: 가변 객체로, 문자열을 수정할 때 객체를 새로 생성하지 않고, 기존 객체를 수정 
: 문자열을 자주 변경한느 작업에서 사용되며, 스레드 안정성이 필요 없는 상황에서 성능 최적화 가능
- StringBuffer 
: Stringbuilder와 유사하지만, 동기화 되어 있어 스레드 안전. 다중 스레드 환경에서 문자열을 자주 수정해야 하는 경우에 사용
> Stringbuilder와 StringBuffer의 차이점은? 
- StringBuilder는 동기화되지 않아 단일 스레드 환경에서 성능 우수. StringBuffer는 동기화되어 스레드안전하므로 멀티 스레드 환경에서 사용

> 동기화란? 
- 자바에서 멀티 스레드 환경에서 공유 자원에 대한 접근을 조절하는 매커니즘 
- 여러 스레드가 동시에 동일한 객체나 메서드에 접근할 때 데이터 무결성이나 일관성을 보장하기 위해 사용

> StringBuffer가 동기화된 클래스라는것은 무슨 의미인가요? 
- StringBuffer는 동기화된 메서드를 제공, 여러 스레드가 동시에 접근해도 안전하게 사용 가능. 한번에 하나의 스레드만 접근하도록 제어하여 데이터 충돌을 방지 


