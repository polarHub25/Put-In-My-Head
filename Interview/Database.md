# 데이터베이스

## 데이터베이스란 무엇인가요?
> 데이터베이스 정의
- 체계적으로 정리된 데이터의 집합으로, 애플리케이션에서 데이터를 효율적으로 저장, 검색, 수정할 수 있도록 설계된 시스템. 데이터 베이스는 데이터베이스 관리시스템(DBMS)에 의해 제어됨.
- 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터(Operational Data) : 업무를 수행하는데 반드시 필요한 자료
- 공용 데이터(Shared Data) : 여러 시스템들이 공동으로 소유하고 유지하는 자료

> 데이터베이스 특징
- 실시간 접근성(Real-Time Accessibility) : 실시간 처리에 의한 응답이 가능해야한다
- 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적. 새로운 데이터의 Insert, Delete, Update로 최신 데이터를 유지한다
- 동시공용(Concurrent Sharing) : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야한다
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는데이터를 참조할 때 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터 내용으로 찾는다

> 데이터베이스와 파일 시스템의 차이점은?
- 데이터베이스는 구조화된 방식으로 데이터를 저장하고 관계를 정의할 수 있지만, 파일 시스템은 단순히 데이터를 파일 형태로 저장.

> 데이터와 정보의 차이점은?
- 데이터(Data) : 현실 세계에서 측정하고 수집한 사실이나 값
- 정보(Information) : 어떤 목적이나 의도에 맞게 데이터를 가공 처리한 것

## RDBMS와 NoSQL의 차이점은 무엇인가요?
> RDBMS
- 관계형 데이터베이스 관리 시스템 (관계형 데이터베이스를 생성하고 수정, 삭제 관리할 수 있는 소프트웨어)
- 정해진 스키마를 기반으로 데이터를 테이블 형식으로 저장
- 테이블 간의 관계는 외래키를 통해 정의, 데이터의 무결성과 참조 무결성 유지
- ACID 트랜잭션을 지원하여 데이터 무결성 보장
- 성능 향상은 Scale up 
- MySQL, Oracle, SQLite, PostgreSQL..

> NoSQL
- Document Database, Graph Database, Key-Value Database, Wide Column Database 등 다양한 데이터 모델 지원
- 스키마가 없어서 데이터 구조가 자주 변경되거나 다양한 형태의 데이터 저장 가능
- BASE 속성을 통해 일관성을 약하지만 가용성을 높임
- 성능 향상은 Scale out

> 차이점
- RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터가 고정된 스키마를 가진 테이블 형태로 저장. 데이터 간의 관계를 명확하게 정의하고, SQL을 통해 데이터를 관리. 주로 ACID 속성을 준수하여 트랜잭션의 일관성과 무결성을 보장
- NoSQL은 비관계형 데이터베이스로, 다양한 모델을 지원하며, 스키마가 유연. 수평 확장을 통해 대규모 데이터를 효율적으로 처리하며, 일관성보다는 가용성을 우선시하는 경우가 많아서 BASE 속성을 따르는 경우가 많음

> 적합한 사용 사례
- RDBMS는 은행, 금융 시스템과 같이 데이터 무결성과 일관성이 중요한 애플리케이션에 적합
- NoSQL은 대규모 데이터를 빠르게 처리해야 하거나 스키마가 자주 변경되는 애플리케이션에 적합

> 수직확장과 수평확장 비교
- RDBMS의 수직확장은 서버의 하드웨어 성능을 향상시켜 처리 능력을 높이는 방법. 데이터의 일관성을 유지하면서 성능을 개선할 수 있지만, 하드웨어 업그레이드 비용이 높고 확장성이 제한적
- NoSQL의 수평 확장은 여러 서버를 추가하여 데이터와 트래픽을 분산 처리하는 방식. 확장성이 뛰어나 대규모 데이터를 처리하는데 적합하지만, 데이터 일관성을 유지하기 어려울 수 있고, 복잡한 분산 처리 로직을 구현해야함

> BASE 속성 ( 기본적으로 가용성을 유지하며 데이터가 결국 일관적이게 되는 상태 ) 
- Basically Available: 시스템에 장애가 발생하더라도 항상 작동해야한다. 
- Soft state: 데이터가 반드시 항상 일관성을 유지할 필요는 없다 
- Eventually consistent: 결국 데이터는 결국 일관성을 유지하게 된다.
  

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
> 정의
- SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위해 사용하는 표준 프로그래밍 언어입니다. SQL의 주요 기능은 데이터 조회(SELECT), 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE) 등이 있으며, DDL(Data Definition Language), DML(Data Manipulation Language), DCL(Data Control Language) 

> DDL
- DDL(Data Definition Language)은 데이터베이스 구조를 정의하는 SQL 명령어 집합으로, CREATE, ALTER, DROP 등이 있습니다.
> DML
- DML(Data Manipulation Language)은 데이터베이스에 저장된 데이터를 조작하는 SQL 명령어로, SELECT, INSERT, UPDATE, DELETE 등이 있습니다.
> DCL
- DCL(Data Control Language)은 데이터베이스 사용 권한을 제어하는 SQL 명령어로, GRANT와 REVOKE가 있습니다.


## 데이터베이스 스키마란 무엇인가요?
> 정의
- 데이터베이스의 구조(개체, 속성, 관계)와 제약 조건에 대한 정의

> 종류
1. 외부 스키마(External Schema, 서브 스키마, 사용자 뷰)
  - 사용자들이 사용할 데이터들을 보여주는 것이므로 추상화가 되어있고, 여러 사용자가 바라보는 관점에 따라 여러 스키마가 존재할 수 있음 
  - 사용자는 데이터베이스에서 데이터를 사용하는 사람이므로 응용 프로그래머로 볼수있음
  - 사용자는 어떤 데이터가 필요한지 결정하므로 쿼리를 이용해서 데이터 조작 가능
  - 응용 프로그래머는 외부 스키마를 통해 구조를 확인하고, DML을 사용해서 데이터를 이용 

2. 개념 스키마(Conceptual Schema, 전체적인 뷰)
  - 데이터베이스의 전체적인 논리적 구조
  - 데이터베이스의 구조, 구체적으로 어떤 데이터가 있고, 각 테이블간의 관계 정의
  - 데이터베이스 관리자(DBA)에 의해서 구성
  - DDL, DCL를 사용하여 구조를 설계
    
3. 내부 스키마(Internal SCheam, 저장 스키마)
  - 물리적 저장장치의 입장에서 본 데이터베이스 구조
  - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  - 데이터의 필드 이름, 해당 필드는 몇 바이트이며 인덱스가 있는지 등을 정의
  - 시스템 프로그래머나 설계자가 보는 관점의 스키마

> 내부 스키마에서 인덱스를 설계할 때 고려해야할 사항은?
- 쿼리 성능을 최적화하기 위해 자주 조회되는 열에 대해서 인덱스를 생성하는것이 중요합니다. 또한 너무 많은 인덱스는 쓰기 성능에 영향을 줄 수 있으므로, 필요한 인덱스만 생성하는것이 중요합니다.

> 스키마 변경이 필요한 상황에서 어떻게 처리하나요?
- 변경의 필요성을 분석하고, 데이터 무결성 및 기존 데이터와의 호환성을 고려해야합니다. 또한 변경사항에 따른 영향도 파악과 테스트를 진행해야하며, 백업, 변경 계힉, 스키마 변경 진행, 데이터 마이그레이션, 테스트, 롤백 계획을 진행해야합니다. 


## 테이블과 뷰(View)의 차이점은 무엇인가요?
> 테이블
- 데이터베이스에서 데이터를 실제로 저장하는 구조
- 테이블에 데이터를 삽입, 수정, 삭제 가능
- 제약 조건 정의 가능

> 뷰(View)
- 하나 이상의 테이블을 기반으로 하는 가상의 테이블
- 실제 데이터를 저장하지 않고, 쿼리 결과를 동적으로 생성하여 제공하는 논리적 구조
- 보안 목적으로 특정 사용자에게만 필요한 데이터를 제공하는데 유용
- 데이터를 삽입, 수정, 삭제할 수 없으나, 특정 조건 만족시에는 가능한 경우도 존재
- CREATE VIEW 뷰이름 AS SELECT 구문;

> 차이점
- 테이블은 데이터를 물리적으로 저장하는 구조이고 뷰는 데이터를 저장하지 않고 데이터를 조회하는 가상의 테이블. 테이블에서는 데이터를 삽입, 삭제, 수정 할수 있지만, 뷰에서는 기본적으로는 불가능. 또한 뷰는 특정 데이터를 쉽게 조회하거나 보안 목적으로 사용

> VIEW와 Materialized View 차이점에 대해서 설명해주세요
- VIEW는 실시간 데이터를 조회하며, 물리적으로 데이터를 저장하지 않는 가상 테이블이고, 데이터가 실시간으로 반영되지만, 복잡한 쿼리에서는 성능이 저하될수 있습니다. Materialized View는 쿼리 결과를 사전에 계산하여 저장하는 테이블로, 빠른 조회 성능을 제공하지만, 갱신이 필요하며 데이터가 항상 최신이 아닐수 있습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
> 기본키
- 테이블 내에서 각 행을 고유하게 식별하는 키
- 중복과 NULL을 가질수 없음
- 기본키는 자동으로 인덱싱되어 검색 성능 향상

> 외래키
- 두 테이블 간의 관계를 설정
- 참조 무결성 유지
- 외래키는 중복될 수 있으며, NULL 값도 가질수있음
  
> 차이점
- 기본키는 테이블 내에서 각 행을 고유하게 식별하기 위한 키이며, 중복될 수 없고 NULL 값을 가질 수 없습니다. 반면, 외래키는 한 테이블이 다른 테이블의 기본키를 참조하여 관계를 설정하는 키로, 중복될 수 있으며 NULL 값을 가질 수 있습니다. 기본키는 테이블의 고유성을 보장하고, 외래키는 테이블 간의 참조 무결성을 유지합니다.

> 외래키가 참조하는 테이블에서 행이 삭제되면 어떻게 되나요?
- 외래키 제약 조건에 따라 달라짐.
- CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블에서도 삭제와 수정이 같이 이루어짐
- SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 NULL로 변경
- NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정하면 참조하는 테이블의 데이터는 변경되지않음
- RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
> ACID 란
- ACID는 데이터베이스 트랜잭션의 신뢰성을 보장하는 네 가지 속성 

- Atomicity(원자성): 트랜잭션 내의 모든 연산이 모두 성공하거나 모두 실패해야 한다. 
- Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스가 일관된 상태를 유지해야한다.
- Isolation(격리성): 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 보장합니다.
- Durability(영속성): 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야한다.

> ACID 속성 중 어느 하나가 실패하면 어떤 일이 발생하나요?
- 데이터베이스가 일관된 상태를 유지하지 못하며, 트랜잭션이 중단되거나 롤백될 수 있습니다.
> 트랜잭션 격리 수준이란 무엇인가요?
- 트랜잭션이 서로 얼마나 격리되어 있는지를 정의하는 설정으로 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등의 수준이 있습니다.

## 트랜잭션이란 무엇인가요?
> 트랜잭션이란
- 데이터베이스에서 일련의 연산을 수행하는 논리적 작업 단위로, 하나의 트랜잭션 내에서 모든 작업이 성공하거나 모두 실패해야 합니다. 트랜잭션은 데이터의 일관성을 유지하고, 데이터베이스에 대한 여러 연산을 하나의 단위로 묶어 처리합니다.

> 트랜잭션의 네 가지 특성은 무엇인가요?
- ACID 속성(원자성, 일관성, 격리성, 영속성)입니다.
> 트랜잭션이 롤백되는 상황은 언제인가요?
- 오류가 발생하거나, 조건이 만족되지 않을 때 롤백이 발생할 수 있습니다.
> 트랜잭션에서 SAVEPOINT란 무엇인가요?
- 트랜잭션 내에서 설정할 수 있는 임시 저장점으로, 롤백 시 특정 SAVEPOINT까지 되돌릴 수 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
> 정의
- 정규화(Normalization)는 데이터 중복을 최소화하고, 데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 최적화하는 과정입니다. 정규화를 통해 데이터의 무결성을 유지하고, 업데이트, 삭제 시 발생할 수 있는 이상 현상을 방지합니다.
- 제 1정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는것
- 제 2정규화 : 제 1정규화를 진행한 테이블에 대해 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안되는것을 의미)을 만족하도록 테이블을 분해하는것
- 제 3정규화 : 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것
- BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는것

> 정규화의 단점은 무엇인가요?
- 과도한 정규화는 성능 저하를 초래할 수 있으며, 복잡한 쿼리를 생성할 수 있습니다.
> 정규화와 반정규화의 차이점은 무엇인가요?
- 정규화는 데이터 중복을 줄이고 데이터 무결성을 유지하는 것이 목적이며, 반정규화는 성능 최적화를 위해 의도적으로 데이터 중복을 허용하는 과정입니다.

- https://datarian.io/blog/database-normalization

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
> 정의
- 역정규화(Denormalization)는 성능 최적화를 위해 의도적으로 정규화된 데이터베이스를 일부 비정규화하는 과정입니다. 이를 통해 데이터 조회 성능을 향상시키고, 복잡한 JOIN 연산을 줄일 수 있습니다. 주로 읽기 성능을 중시하는 시스템에서 사용됩니다.

> 역정규화의 단점은 무엇인가요?
- 데이터 중복이 증가하여 데이터 무결성이 저하될 수 있으며, 저장 공간이 더 많이 필요할 수 있습니다.
> 역정규화의 구체적인 예를 들어보세요.
- 고객 정보와 주문 정보를 하나의 테이블로 합쳐, 각 주문 조회 시 고객 정보를 함께 조회할 수 있도록 하는 것이 예입니다.
> 정규화와 역정규화의 균형을 어떻게 맞추나요?
- 시스템의 요구사항에 따라, 읽기 및 쓰기 성능, 데이터 무결성, 유지보수 용이성 등을 고려해 결정합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
- INNER JOIN: 두 테이블에서 공통적으로 존재하는 데이터 반환 ( 교집합 ) 
- LEFT JOIN: 왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환. 오른쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- RIGHT JOIN: 오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환. 왼쪽 테이블에 일치하는 행이 없으면 NULL을 반환.
- FULL JOIN: 양쪽 테이블에서 일치하는 모든 행을 반환하며, 일치하지 않는 행은 NULL

> SELF JOIN이란 무엇인가요?
- 자기 자신과의 JOIN을 의미하며, 같은 테이블의 다른 행을 연결하여 조회할 때 사용됩니다.
> CROSS JOIN이란 무엇인가요?
- 두 테이블의 모든 행 조합을 반환하는 JOIN입니다. 결과는 테이블의 곱(Cartesian Product)입니다.
> JOIN에서 ON과 USING의 차이점은 무엇인가요?
- ON은 모든 조건을 사용해 조인을 설정할 수 있으며, USING은 동일한 이름의 열에 대해 자동으로 조인을 설정합니다.


## GROUP BY와 HAVING의 차이점은 무엇인가요?
- GROUP BY는 결과 집합을 그룹화하는 데 사용되며, HAVING은 그룹화된 결과에 조건을 적용하는 데 사용됩니다.

> GROUP BY에서 COUNT와 함께 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;
> HAVING에서 COUNT를 사용하는 예는 무엇인가요?
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name HAVING COUNT(*) > 1;

## WHERE와 HAVING의 차이점은 무엇인가요?
- WHERE는 SQL 쿼리에서 개별 행에 대해 조건을 적용하여 필터링하고, HAVING은 GROUP BY 절로 그룹화된 결과에 조건을 적용하여 필터링합니다. WHERE는 그룹화 전에 필터링을 수행하고, HAVING은 그룹화 후에 필터링을 수행합니다.

> WHERE 절에서 사용할 수 없는 SQL 함수를 예로 들어보세요.
- 집계 함수(예: COUNT, SUM, AVG 등)는 WHERE 절에서 사용할 수 없고, HAVING 절에서 사용해야 합니다.
> HAVING을 WHERE 대신 사용하는 경우는 언제인가요?
- 집계된 데이터에 조건을 적용할 때 HAVING을 사용합니다.

## DISTINCT 키워드는 무엇을 하는가요?
- DISTINCT 키워드는 SELECT 문에서 사용하여 중복된 값을 제거하고 고유한 값을 반환합니다. 이를 통해 쿼리 결과에서 중복된 행을 제외하고 고유한 결과를 얻을 수 있습니다.

> DISTINCT와 GROUP BY의 차이점은 무엇인가요?
- DISTINCT는 중복된 값을 제거하여 고유한 결과를 반환하고, GROUP BY는 데이터를 그룹화하여 집계함수를 사용하는 데 주로 사용됩니다.
> DISTINCT를 사용하는 예를 들어보세요.
- SELECT DISTINCT column_name FROM table_name;


## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
- 서브쿼리(Subquery)는 하나의 SQL 문 안에 포함된 또 다른 쿼리입니다. 
- 복잡한 계산이나 연산을 괄호로 묶어서 수행할 수 있음
- 서브 쿼리는 메인 쿼리의 속성을 그대로 받지만, 메인 쿼리에서는 서브 쿼리의 내용을 참조할 수 없음. 반대로 서브쿼리에서 메인 쿼리의 내용을 참조는 가능

> 종류
1. 스칼라 서브쿼리
   - SELECT 절에 위치하며 한 레코드당 하나의 값을 반환하는 서브쿼리(단일행, 단일컬럼을 반환)
   - 다중행 값 조회되면 "ORA-01427: single-row subquery returns more than one row" 오류 발생
2. 인라인 뷰
   - FROM 절에 위치하는 서브쿼리로 결과는 반드시 하나의 테이블로 리턴
   - 인라인 뷰는 SQL 문이 실행될때 임시적으로 생성되는 동적인 뷰
   - 단점 : SQL을 좀 더 빠른 속도로 사용하기 위한 것이지만, 잘못 사용하게 되면 액세스 속도를 저하 시키는 경우도 많음 
3. 중첩 서브쿼리
   - WHERE 절에 위치하며 메인쿼리 테이블의 특정 컬럼 값과 비교한 값을 반환하는 용도로 주로 사용
   - 단일행, 다중행 반환 가능 

> 서브쿼리와 JOIN 중 어느 것이 더 효율적인가요?
- 상황에 따라 다르지만, JOIN이 일반적으로 더 효율적일 수 있습니다.

## UNION과 UNION ALL의 차이점은 무엇인가요?
- UNION은 두 개의 SELECT 결과를 결합하여 중복된 행을 제거한 후 반환합니다. 반면, UNION ALL은 두 SELECT 결과를 결합하여 중복된 행을 포함한 모든 결과를 반환합니다.

> UNION을 사용한 쿼리의 예를 들어보세요.
- SELECT column_name FROM table1 UNION SELECT column_name FROM table2;
> UNION ALL을 사용하는 이유는 무엇인가요?
- 중복된 데이터를 포함한 전체 결과를 반환하려는 경우 사용합니다.
> UNION과 JOIN의 차이점은 무엇인가요?
- UNION은 두 개의 쿼리 결과를 수직으로 결합하는 반면, JOIN은 두 개의 테이블을 수평으로 결합합니다.

## EXISTS와 IN의 차이점은 무엇인가요?
> EXISTS
- 서브쿼리가 결과를 반환하는지 여부를 확인
- 서브쿼리가 하나 이상의 행을 반환하면 TRUE, 그렇지 않으면 FALSE 반환
- 메인 쿼리의 각 행에 대해 서브쿼리를 싱행하고, 조건을 만족하는 첫 번째 행을 찾으면 실행을 중단
- 서브쿼리가 결과를 반환할 수 있는지 여부만을 확인하므로, 서브쿼리 결과가 크더라도 비교적 효율적으로 작동
- 처리 순서 : 메인쿼리 -> 서브쿼리 
``` SQL
SELECT department_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.department_id = d.department_id);
```
> IN
- 서브쿼리가 반환한 결과 중 하나라도 메인 쿼리의 조건과 일치하는지 확인
- 서브쿼리에서 반환된 모든 값을 메모리에 로드한 후, 메인 쿼리의 각 행에 대해 서브쿼리 목록과 비교
- 반환하는 결과가 작은 경우에 효율적으로 작동
-  처리 순서 : 서브쿼리 -> 메인쿼리 
``` SQL
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1700);
```

> 어떤 상황에서 EXISTS를 사용하는 것이 IN보다 더 효율적인가요?
- 서브쿼리가 매우 큰 결과 집합을 반환하거나, 메인 쿼리와 서브쿼리의 테이블 간에 상관 관계가 있을 때 EXISTS를 사용하는 것이 더 효율적일 수 있습니다. EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 실행을 중지하기 때문에, 서브쿼리의 결과가 클 때 성능이 더 좋습니다. 또한, 서브쿼리가 인덱스된 열에 대해 실행될 때 EXISTS가 더 효율적으로 동작할 수 있습니다.
>  IN 연산자를 사용할 때 주의해야 할 점은 무엇인가요?
- IN 연산자를 사용할 때 주의해야 할 점은 서브쿼리가 반환하는 결과 목록이 너무 크지 않도록 하는 것입니다. 서브쿼리의 결과가 큰 경우 성능이 저하될 수 있습니다. 또한, IN 연산자 사용 시 NULL 값을 포함한 비교가 이루어질 때 결과가 예상과 다를 수 있으므로, NULL 처리에 유의해야 합니다. NULL 값이 포함된 경우, 비교 연산에서 불확실성을 초래할 수 있습니다.
  
## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
- 여러 행으로부터 하나의결과값을 반환하는 함수. 
> 종류 
- COUNT: 행의 개수를 반환
- SUM: 열의 합계를 반환
- AVG: 열의 평균값을 반환
- MIN: 열의 최소값을 반환
- MAX: 열의 최대값을 반환

> COUNT와 DISTINCT를 함께 사용하는 방법은 무엇인가요?
- SELECT COUNT(DISTINCT column_name) FROM table_name;
> 집계 함수에서 NULL 값은 어떻게 처리되나요?
- 대부분의 집계 함수는 NULL 값을 무시합니다. 그러나 COUNT(*)는 NULL 값을 포함합니다.
> 집계 함수를 GROUP BY와 함께 사용하는 예를 보여주세요.
- SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;


## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
- 하나 이상의 테이블을 기반으로 생성된 가상의 테이블
- 실제 데이터를 저장하지 않고 기본 테이블의 데이터를 조회할 수 있는 SQL 쿼리의 결과를 저장한 논리적 구조
- 복잡한 쿼리를 단순화하고, 특정 데이터를 쉽게 조회하거나 보안을 강화하기 위해 사용

> 장점
- 사용자가 접근할 수 있는 데이터를 제한하여 보안 강화
- 자주 사용하는 복잡한 쿼리를 뷰로 정의해 두면 간단한 SELECT 문으로 동일한 결과 반환 가능
- 특정 데이터를 표준화된 방식으로 제공함으로써 여러 사용자에게 일관된 데이터를 사용할 수 있게 함
- 동일한 뷰를 여러 쿼리에서 사용하므로 코드의 중복을 줄이고, 유지보수 쉽게 가능

> 단점
- 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 복잡한 뷰나 조인이 많은 뷰는 성능 저하를 초래할 수 있음
- 데이터의 삽입, 수정, 삭제하는것이 제한
- 기본 테이블의 구조가 변경되면 오류가 발생할 수 있어 유지보수 필요

> VIEW가 기본 테이블에서 데이터를 가져올 때 실시간으로 쿼리를 실행하는데, 이로 인해 어떤 문제점이 발생할 수 있나요?
- VIEW는 실시간으로 기본 테이블에 대한 쿼리를 실행하므로, 기본 테이블이 큰 경우 또는 VIEW가 복잡한 조인을 포함하는 경우 성능 문제가 발생할 수 있습니다. 특히, 여러 테이블을 조인하거나 중첩된 VIEW를 사용하는 경우 쿼리 실행 시간이 길어질 수 있으며, 전체 시스템 성능에 부정적인 영향을 미칠 수 있습니다.


## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- CASE문은 SQL에서 조건에 따라 다른 값을 반환할 수 있도록 하는 조건부 표현식
  
```` SQL
SELECT column_name,
       CASE
           WHEN 조건1 THEN 결과1
           WHEN 조건2 THEN 결과2
           ELSE 결과3
       END AS new_column_name
FROM table_name;
````

> CASE문을 사용하여 집계 데이터를 구분하는 예를 들어보세요.
- SELECT SUM(CASE WHEN column_name > 100 THEN 1 ELSE 0 END) FROM table_name;

> CASE 문을 사용해서 조건부로 데이터를 업데이트할 수 있나요?
```SQL
UPDATE employees
SET bonus = CASE
               WHEN salary > 100000 THEN salary * 0.1
               WHEN salary BETWEEN 50000 AND 100000 THEN salary * 0.05
               ELSE 0
           END;
```


